/* 
  This file was generated by KaRaMeL <https://github.com/FStarLang/karamel>
  KaRaMeL invocation: /Users/jonathan/Code/eurydice/eurydice symcrust.llbc --output c/ -fcomments
  F* version: <unknown>
  KaRaMeL version: 7f0d2a76
 */

#include "symcrust.h"

const
uint16_t
symcrust_ntt_MlKemZetaBitRevTimesR[128U] =
  {
    2285U, 2571U, 2970U, 1812U, 1493U, 1422U, 287U, 202U, 3158U, 622U, 1577U, 182U, 962U, 2127U,
    1855U, 1468U, 573U, 2004U, 264U, 383U, 2500U, 1458U, 1727U, 3199U, 2648U, 1017U, 732U, 608U,
    1787U, 411U, 3124U, 1758U, 1223U, 652U, 2777U, 1015U, 2036U, 1491U, 3047U, 1785U, 516U, 3321U,
    3009U, 2663U, 1711U, 2167U, 126U, 1469U, 2476U, 3239U, 3058U, 830U, 107U, 1908U, 3082U, 2378U,
    2931U, 961U, 1821U, 2604U, 448U, 2264U, 677U, 2054U, 2226U, 430U, 555U, 843U, 2078U, 871U,
    1550U, 105U, 422U, 587U, 177U, 3094U, 3038U, 2869U, 1574U, 1653U, 3083U, 778U, 1159U, 3182U,
    2552U, 1483U, 2727U, 1119U, 1739U, 644U, 2457U, 349U, 418U, 329U, 3173U, 3254U, 817U, 1097U,
    603U, 610U, 1322U, 2044U, 1864U, 384U, 2114U, 3193U, 1218U, 1994U, 2455U, 220U, 2142U, 1670U,
    2144U, 1799U, 2051U, 794U, 1819U, 2475U, 2459U, 478U, 3221U, 3021U, 996U, 991U, 958U, 1869U,
    1522U, 1628U
  };

const
uint16_t
symcrust_ntt_MlKemZetaBitRevTimesRTimesNegQInvModR[128U] =
  {
    19U, 34037U, 50790U, 64748U, 52011U, 12402U, 37345U, 16694U, 20906U, 37778U, 3799U, 15690U,
    54846U, 64177U, 11201U, 34372U, 5827U, 48172U, 26360U, 29057U, 59964U, 1102U, 44097U, 26241U,
    28072U, 41223U, 10532U, 56736U, 47109U, 56677U, 38860U, 16162U, 5689U, 6516U, 64039U, 34569U,
    23564U, 45357U, 44825U, 40455U, 12796U, 38919U, 49471U, 12441U, 56401U, 649U, 25986U, 37699U,
    45652U, 28249U, 15886U, 8898U, 28309U, 56460U, 30198U, 47286U, 52109U, 51519U, 29155U, 12756U,
    48704U, 61224U, 24155U, 17914U, 334U, 54354U, 11477U, 52149U, 32226U, 14233U, 45042U, 21655U,
    27738U, 52405U, 64591U, 4586U, 14882U, 42443U, 59354U, 60043U, 33525U, 32502U, 54905U, 35218U,
    36360U, 18741U, 28761U, 52897U, 18485U, 45436U, 47975U, 47011U, 14430U, 46007U, 5275U, 12618U,
    31183U, 45239U, 40101U, 63390U, 7382U, 50180U, 41144U, 32384U, 20926U, 6279U, 54590U, 14902U,
    41321U, 11044U, 48546U, 51066U, 55200U, 21497U, 7933U, 20198U, 22501U, 42325U, 54629U, 17442U,
    33899U, 23859U, 36892U, 20257U, 41538U, 57779U, 17422U, 42404U
  };

uint32_t symcrust_ntt_SymCryptMlKemModAdd(uint32_t a, uint32_t b)
{
  EURYDICE_ASSERT(a < SYMCRUST_NTT_Q, "panic!");
  EURYDICE_ASSERT(b < SYMCRUST_NTT_Q, "panic!");
  uint32_t res = a + b - SYMCRUST_NTT_Q;
  if (!(res >> 16U == 0U))
  {
    EURYDICE_ASSERT(res >> 16U == 65535U, "panic!");
  }
  uint32_t res0 = res + (SYMCRUST_NTT_Q & res >> 16U);
  EURYDICE_ASSERT(res0 < SYMCRUST_NTT_Q, "panic!");
  return res0;
}

uint32_t symcrust_ntt_SymCryptMlKemModSub(uint32_t a, uint32_t b)
{
  EURYDICE_ASSERT(a < 2U * SYMCRUST_NTT_Q, "panic!");
  EURYDICE_ASSERT(b <= SYMCRUST_NTT_Q, "panic!");
  uint32_t res = a - b;
  if (!(res >> 16U == 0U))
  {
    EURYDICE_ASSERT(res >> 16U == 65535U, "panic!");
  }
  uint32_t res0 = res + (SYMCRUST_NTT_Q & res >> 16U);
  EURYDICE_ASSERT(res0 < SYMCRUST_NTT_Q, "panic!");
  return res0;
}

uint32_t symcrust_ntt_SymCryptMlKemMontMul(uint32_t a, uint32_t b, uint32_t bMont)
{
  EURYDICE_ASSERT(a < SYMCRUST_NTT_Q, "panic!");
  EURYDICE_ASSERT(b < SYMCRUST_NTT_Q, "panic!");
  EURYDICE_ASSERT(bMont <= SYMCRUST_NTT_RMASK, "panic!");
  EURYDICE_ASSERT(bMont == (b * SYMCRUST_NTT_NEGQINVMODR & SYMCRUST_NTT_RMASK), "panic!");
  uint32_t res = a * b;
  uint32_t inv = a * bMont & SYMCRUST_NTT_RMASK;
  res = res + inv * SYMCRUST_NTT_Q;
  EURYDICE_ASSERT((res & SYMCRUST_NTT_RMASK) == 0U, "panic!");
  res = res >> (uint32_t)SYMCRUST_NTT_RLOG2;
  return symcrust_ntt_SymCryptMlKemModSub(res, SYMCRUST_NTT_Q);
}

void
symcrust_ntt_SymCryptMlKemMontgomeryReduceAndAddPolyElementAccumulatorToPolyElement(
  uint32_t *paSrc,
  uint16_t *peDst
)
{
  for (size_t i = (size_t)0U; i < SYMCRUST_NTT_MLWE_POLYNOMIAL_COEFFICIENTS; i++)
  {
    uint32_t a = paSrc[i];
    EURYDICE_ASSERT(a <= 4U * (3328U * 3328U + 3494U * 3312U), "panic!");
    paSrc[i] = 0U;
    uint32_t c = (uint32_t)peDst[i];
    EURYDICE_ASSERT(c < SYMCRUST_NTT_Q, "panic!");
    uint32_t
    inv =
      /* montgomery reduce sum of products */ a
      * SYMCRUST_NTT_NEGQINVMODR
      & SYMCRUST_NTT_RMASK;
    a = (a + inv * SYMCRUST_NTT_Q) >> (uint32_t)SYMCRUST_NTT_RLOG2;
    EURYDICE_ASSERT(a <= 4711U, "panic!");
    c = c + /* add destination */ a ;
    EURYDICE_ASSERT(c <= 8039U, "panic!");
    c =
      c
      -
        2U
        *
          /* subtraction and conditional additions for constant time range reduction */
            SYMCRUST_NTT_Q
          ;
    if (!(c >= (uint32_t)((int32_t)-2 * (int32_t)SYMCRUST_NTT_Q)))
    {
      EURYDICE_ASSERT(c < 1381U, "panic!");
    }
    c = c + (SYMCRUST_NTT_Q & c >> 16U);
    if (!(c >= (uint32_t)-(int32_t)SYMCRUST_NTT_Q))
    {
      EURYDICE_ASSERT(c < SYMCRUST_NTT_Q, "panic!");
    }
    c = c + (SYMCRUST_NTT_Q & c >> 16U);
    EURYDICE_ASSERT(c < SYMCRUST_NTT_Q, "panic!");
    peDst[i] = (uint16_t)c;
  }
}

void
symcrust_ntt_SymCryptMlKemPolyElementAdd(uint16_t *peSrc1, uint16_t *peSrc2, uint16_t *peDst)
{
  for (size_t i = (size_t)0U; i < SYMCRUST_NTT_MLWE_POLYNOMIAL_COEFFICIENTS; i++)
  {
    uint32_t uu____0 = symcrust_ntt_SymCryptMlKemModAdd((uint32_t)peSrc1[i], (uint32_t)peSrc2[i]);
    peDst[i] = (uint16_t)uu____0;
  }
}

uint32_t symcrust_ntt_min(uint32_t x, uint32_t y)
{
  uint32_t uu____0;
  if (x <= y)
  {
    uu____0 = x;
  }
  else
  {
    uu____0 = y;
  }
  return uu____0;
}

void
symcrust_ntt_SymCryptMlKemPolyElementCompressAndEncode(
  uint16_t *peSrc,
  uint32_t nBitsPerCoefficient,
  Eurydice_slice pbDst
)
{
  /* _Out_writes_bytes_(nBitsPerCoefficient*(MLWE_POLYNOMIAL_COEFFICIENTS / 8)) */
  size_t cbDstWritten = (size_t)0U;
  uint32_t accumulator = 0U;
  uint32_t nBitsInAccumulator = 0U;
  EURYDICE_ASSERT(nBitsPerCoefficient > 0U, "panic!");
  EURYDICE_ASSERT(nBitsPerCoefficient <= 12U, "panic!");
  for (size_t i = (size_t)0U; i < SYMCRUST_NTT_MLWE_POLYNOMIAL_COEFFICIENTS; i++)
  {
    uint32_t nBitsInCoefficient = nBitsPerCoefficient;
    uint32_t coefficient = (uint32_t)peSrc[i];
    EURYDICE_ASSERT(coefficient < SYMCRUST_NTT_Q, "panic!");
    if
    (
      /* first compress the coefficient when nBitsPerCoefficient < 12 we compress per Compress_d in draft FIPS 203; */
        nBitsPerCoefficient

      < 12U
    )
    {
      uint64_t
      multiplication =
        (uint64_t)/* Multiply by 2^(nBitsPerCoefficient+1) / Q by multiplying by constant and shifting right */
          coefficient

        * (uint64_t)SYMCRUST_NTT_COMPRESS_MULCONSTANT;
      coefficient =
        (uint32_t)(multiplication
        >> (uint32_t)(SYMCRUST_NTT_COMPRESS_SHIFTCONSTANT - (nBitsPerCoefficient + 1U)));
      /* add "half" to round to nearest integer */
      coefficient++;
      /* final divide by two to get multiplication by 2^nBitsPerCoefficient / Q */
      coefficient = coefficient >> 1U;
      if (coefficient <= 1U << (uint32_t)nBitsPerCoefficient)
      {
        coefficient =
          coefficient
          & ((1U << (uint32_t)/* modular reduction by masking */ nBitsPerCoefficient ) - 1U);
        EURYDICE_ASSERT(coefficient < 1U << (uint32_t)nBitsPerCoefficient, "panic!");
      }
      else
      {
        KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
        KRML_HOST_EXIT(255U);
      }
    }
    size_t *x1 = &cbDstWritten;
    uint32_t *x2 = &accumulator;
    uint32_t *x3 = &nBitsInAccumulator;
    uint32_t *x4 = &nBitsInCoefficient;
    uint32_t *x5 = &coefficient;
    while (true)
    {
      uint32_t nBitsToEncode = symcrust_ntt_min(x4[0U], 32U - x3[0U]);
      uint32_t bitsToEncode = x5[0U] & ((1U << (uint32_t)nBitsToEncode) - 1U);
      x5[0U] = x5[0U] >> (uint32_t)nBitsToEncode;
      x4[0U] = x4[0U] - nBitsToEncode;
      x2[0U] = x2[0U] | bitsToEncode << (uint32_t)x3[0U];
      x3[0U] = x3[0U] + nBitsToEncode;
      if (x3[0U] == 32U)
      {
        Eurydice_slice
        uu____0 =
          Eurydice_slice_subslice2(/* encode the coefficient simple loop to add bits to accumulator and write accumulator to output */
              pbDst
            ,
            x1[0U],
            x1[0U] + (size_t)4U,
            uint8_t);
        uint8_t ret[4U];
        core_num__u32_8__to_le_bytes(x2[0U], ret);
        Eurydice_slice_copy(uu____0, Eurydice_array_to_slice((size_t)4U, ret, uint8_t), uint8_t);
        x1[0U] = x1[0U] + (size_t)4U;
        x2[0U] = 0U;
        x3[0U] = 0U;
        if (!(x4[0U] > 0U))
        {
          break;
        }
      }
      else if (!(x4[0U] > 0U))
      {
        break;
      }
    }
  }
  EURYDICE_ASSERT(nBitsInAccumulator == 0U, "panic!");
  EURYDICE_ASSERT(cbDstWritten
    == (size_t)(nBitsPerCoefficient * ((uint32_t)SYMCRUST_NTT_MLWE_POLYNOMIAL_COEFFICIENTS / 8U)),
    "panic!");
}

symcrust_ntt_MLKEM_ERROR
symcrust_ntt_SymCryptMlKemPolyElementDecodeAndDecompress(
  Eurydice_slice pbSrc,
  uint32_t nBitsPerCoefficient,
  uint16_t *peDst
)
{
  /* _In_reads_bytes_(nBitsPerCoefficient*(MLWE_POLYNOMIAL_COEFFICIENTS / 8)) */
  size_t cbSrcRead = (size_t)0U;
  uint32_t accumulator = 0U;
  uint32_t nBitsInAccumulator = 0U;
  EURYDICE_ASSERT(nBitsPerCoefficient > 0U, "panic!");
  EURYDICE_ASSERT(nBitsPerCoefficient <= 12U, "panic!");
  /* FIXME */
  size_t i = (size_t)0U;
  symcrust_ntt_MLKEM_ERROR uu____0;
  while (true)
  {
    if (i < SYMCRUST_NTT_MLWE_POLYNOMIAL_COEFFICIENTS)
    {
      uint32_t coefficient = 0U;
      uint32_t nBitsInCoefficient = 0U;
      size_t *x2 = &cbSrcRead;
      uint32_t *x3 = &accumulator;
      uint32_t *x4 = &nBitsInAccumulator;
      uint32_t *x5 = &coefficient;
      uint32_t *x6 = &nBitsInCoefficient;
      while (true)
      {
        if (x4[0U] == 0U)
        {
          uint8_t uu____1[4U];
          symcrust_ntt_slice_to_sub_array((size_t)4U,
            /* first gather and decode bits from pbSrc FIXME *accumulator = u32::from_le_bytes(&pbSrc[*cbSrcRead..*cbSrcRead+4]).try_into().unwrap()); FIXME *accumulator = u32::from_le_bytes(&pbSrc[*cbSrcRead..*cbSrcRead+4]).try_into().unwrap()); */
              pbSrc
            ,
            x2[0U],
            uu____1,
            void *);
          x3[0U] = core_num__u32_8__from_le_bytes(uu____1);
          x2[0U] = x2[0U] + (size_t)4U;
          x4[0U] = 32U;
          uint32_t nBitsToDecode = symcrust_ntt_min(nBitsPerCoefficient - x6[0U], x4[0U]);
          EURYDICE_ASSERT(nBitsToDecode <= x4[0U], "panic!");
          uint32_t bitsToDecode = x3[0U] & ((1U << (uint32_t)nBitsToDecode) - 1U);
          x3[0U] = x3[0U] >> (uint32_t)nBitsToDecode;
          x4[0U] = x4[0U] - nBitsToDecode;
          x5[0U] = x5[0U] | bitsToDecode << (uint32_t)x6[0U];
          x6[0U] = x6[0U] + nBitsToDecode;
          if (!(nBitsPerCoefficient > x6[0U]))
          {
            return (void *)0U;
          }
        }
        else
        {
          uint32_t nBitsToDecode = symcrust_ntt_min(nBitsPerCoefficient - x6[0U], x4[0U]);
          EURYDICE_ASSERT(nBitsToDecode <= x4[0U], "panic!");
          uint32_t bitsToDecode = x3[0U] & ((1U << (uint32_t)nBitsToDecode) - 1U);
          x3[0U] = x3[0U] >> (uint32_t)nBitsToDecode;
          x4[0U] = x4[0U] - nBitsToDecode;
          x5[0U] = x5[0U] | bitsToDecode << (uint32_t)x6[0U];
          x6[0U] = x6[0U] + nBitsToDecode;
          if (!(nBitsPerCoefficient > x6[0U]))
          {
            return (void *)0U;
          }
        }
      }
      if (nBitsInCoefficient == nBitsPerCoefficient)
      {
        if
        (
          /* decompress the coefficient when nBitsPerCoefficient < 12 we decompress per Decompress_d in draft FIPS 203 otherwise we perform input validation per 203 6.2 Input validation 2 (Modulus check) */
            nBitsPerCoefficient

          < 12U
        )
        {
          coefficient =
            coefficient
            *
              /* Multiply by Q / 2^(nBitsPerCoefficient-1) by multiplying by constant and shifting right */
                SYMCRUST_NTT_Q
              ;
          coefficient = coefficient >> (uint32_t)(nBitsPerCoefficient - 1U);
          /* add "half" to round to nearest integer */
          coefficient++;
          /* final divide by two to get multiplication by Q / 2^nBitsPerCoefficient */
          coefficient = coefficient >> 1U;
          coefficient =
            symcrust_ntt_SymCryptMlKemModSub(/* modular reduction by conditional subtraction */
                coefficient
              ,
              SYMCRUST_NTT_Q);
          EURYDICE_ASSERT(coefficient < SYMCRUST_NTT_Q, "panic!");
          peDst[i] = (uint16_t)coefficient;
          i++;
        }
        else if (coefficient > SYMCRUST_NTT_Q)
        {
          uu____0 = symcrust_ntt_INVALID_BLOB;
          break;
        }
        else
        {
          peDst[i] = (uint16_t)coefficient;
          i++;
        }
      }
      else
      {
        KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
        KRML_HOST_EXIT(255U);
      }
    }
    else if (nBitsInAccumulator == 0U)
    {
      if
      (
        cbSrcRead
        ==
          (size_t)(nBitsPerCoefficient * ((uint32_t)SYMCRUST_NTT_MLWE_POLYNOMIAL_COEFFICIENTS / 8U))
      )
      {
        uu____0 = symcrust_ntt_NO_ERROR;
        break;
      }
      else
      {
        KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
        KRML_HOST_EXIT(255U);
      }
    }
    else
    {
      KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
      KRML_HOST_EXIT(255U);
    }
  }
  return uu____0;
}

void symcrust_ntt_SymCryptMlKemPolyElementINTTLayerC(uint16_t *peSrc, size_t k, size_t len)
{
  for (size_t start = (size_t)0U; start < (size_t)256U; start = start + (size_t)2U * len)
  {
    uint32_t twiddleFactor = (uint32_t)symcrust_ntt_MlKemZetaBitRevTimesR[k];
    uint32_t twiddleFactorMont = (uint32_t)symcrust_ntt_MlKemZetaBitRevTimesRTimesNegQInvModR[k];
    k--;
    for (size_t j = (size_t)0U; j < len; j++)
    {
      uint32_t c0 = (uint32_t)peSrc[start + j];
      EURYDICE_ASSERT(c0 < SYMCRUST_NTT_Q, "panic!");
      uint32_t c1 = (uint32_t)peSrc[start + j + len];
      EURYDICE_ASSERT(c1 < SYMCRUST_NTT_Q, "panic!");
      uint32_t tmp = symcrust_ntt_SymCryptMlKemModAdd(c0, c1);
      c1 = symcrust_ntt_SymCryptMlKemModSub(c1, c0);
      c1 = symcrust_ntt_SymCryptMlKemMontMul(c1, twiddleFactor, twiddleFactorMont);
      peSrc[start + j] = (uint16_t)tmp;
      peSrc[start + j + len] = (uint16_t)c1;
    }
  }
}

void symcrust_ntt_SymCryptMlKemPolyElementINTTLayer(uint16_t *peSrc, size_t k, size_t len)
{
  symcrust_ntt_SymCryptMlKemPolyElementINTTLayerC(peSrc, k, len);
}

void symcrust_ntt_SymCryptMlKemPolyElementINTTAndMulR(uint16_t *peSrc)
{
  symcrust_ntt_SymCryptMlKemPolyElementINTTLayer(peSrc, (size_t)127U, (size_t)2U);
  symcrust_ntt_SymCryptMlKemPolyElementINTTLayer(peSrc, (size_t)63U, (size_t)4U);
  symcrust_ntt_SymCryptMlKemPolyElementINTTLayer(peSrc, (size_t)31U, (size_t)8U);
  symcrust_ntt_SymCryptMlKemPolyElementINTTLayer(peSrc, (size_t)15U, (size_t)16U);
  symcrust_ntt_SymCryptMlKemPolyElementINTTLayer(peSrc, (size_t)7U, (size_t)32U);
  symcrust_ntt_SymCryptMlKemPolyElementINTTLayer(peSrc, (size_t)3U, (size_t)64U);
  symcrust_ntt_SymCryptMlKemPolyElementINTTLayer(peSrc, (size_t)1U, (size_t)128U);
  for (size_t i = (size_t)0U; i < SYMCRUST_NTT_MLWE_POLYNOMIAL_COEFFICIENTS; i++)
  {
    uint32_t
    uu____0 =
      symcrust_ntt_SymCryptMlKemMontMul((uint32_t)peSrc[i],
        SYMCRUST_NTT_INTTFIXUPTIMESRSQR,
        SYMCRUST_NTT_INTTFIXUPTIMESRSQRTIMESNEGQINVMODR);
    peSrc[i] = (uint16_t)uu____0;
  }
}

const
uint16_t
symcrust_ntt_zetaTwoTimesBitRevPlus1TimesR[128U] =
  {
    2226U, 1103U, 430U, 2899U, 555U, 2774U, 843U, 2486U, 2078U, 1251U, 871U, 2458U, 1550U, 1779U,
    105U, 3224U, 422U, 2907U, 587U, 2742U, 177U, 3152U, 3094U, 235U, 3038U, 291U, 2869U, 460U,
    1574U, 1755U, 1653U, 1676U, 3083U, 246U, 778U, 2551U, 1159U, 2170U, 3182U, 147U, 2552U, 777U,
    1483U, 1846U, 2727U, 602U, 1119U, 2210U, 1739U, 1590U, 644U, 2685U, 2457U, 872U, 349U, 2980U,
    418U, 2911U, 329U, 3000U, 3173U, 156U, 3254U, 75U, 817U, 2512U, 1097U, 2232U, 603U, 2726U, 610U,
    2719U, 1322U, 2007U, 2044U, 1285U, 1864U, 1465U, 384U, 2945U, 2114U, 1215U, 3193U, 136U, 1218U,
    2111U, 1994U, 1335U, 2455U, 874U, 220U, 3109U, 2142U, 1187U, 1670U, 1659U, 2144U, 1185U, 1799U,
    1530U, 2051U, 1278U, 794U, 2535U, 1819U, 1510U, 2475U, 854U, 2459U, 870U, 478U, 2851U, 3221U,
    108U, 3021U, 308U, 996U, 2333U, 991U, 2338U, 958U, 2371U, 1869U, 1460U, 1522U, 1807U, 1628U,
    1701U
  };

void
symcrust_ntt_SymCryptMlKemPolyElementMulAndAccumulate(
  uint16_t *peSrc1,
  uint16_t *peSrc2,
  uint32_t *paDst
)
{
  for (size_t i = (size_t)0U; i < SYMCRUST_NTT_MLWE_POLYNOMIAL_COEFFICIENTS / (size_t)2U; i++)
  {
    uint32_t a0 = (uint32_t)peSrc1[(size_t)2U * i];
    EURYDICE_ASSERT(a0 < SYMCRUST_NTT_Q, "panic!");
    uint32_t a1 = (uint32_t)peSrc1[(size_t)2U * i + (size_t)1U];
    EURYDICE_ASSERT(a1 < SYMCRUST_NTT_Q, "panic!");
    uint32_t b0 = (uint32_t)peSrc2[(size_t)2U * i];
    EURYDICE_ASSERT(b0 < SYMCRUST_NTT_Q, "panic!");
    uint32_t b1 = (uint32_t)peSrc2[(size_t)2U * i + (size_t)1U];
    EURYDICE_ASSERT(b1 < SYMCRUST_NTT_Q, "panic!");
    uint32_t c0 = (uint32_t)paDst[(size_t)2U * i];
    EURYDICE_ASSERT(c0 <= 3U * (3328U * 3328U + 3494U * 3312U), "panic!");
    uint32_t c1 = (uint32_t)paDst[(size_t)2U * i + (size_t)1U];
    EURYDICE_ASSERT(c1 <= 3U * (3328U * 3328U + 3494U * 3312U), "panic!");
    uint32_t a0b0 = /* multiplication results in range [0, 3328*3328] */ a0  * b0;
    uint32_t a1b1 = a1 * b1;
    uint32_t a0b1 = a0 * b1;
    uint32_t a1b0 = a1 * b0;
    uint32_t
    inv =
      /* we need a1*b1*zetaTwoTimesBitRevPlus1TimesR[i] eagerly reduce a1*b1 with montgomery reduction a1b1 = red(a1*b1) -> range [0,3494] (3494 is maximum result of first step of montgomery reduction of x*y for x,y in [0,3328]) we do not need to do final reduction yet */
        a1b1

      * SYMCRUST_NTT_NEGQINVMODR
      & SYMCRUST_NTT_RMASK;
    uint32_t a1b10 = (a1b1 + inv * SYMCRUST_NTT_Q) >> (uint32_t)SYMCRUST_NTT_RLOG2;
    EURYDICE_ASSERT(a1b10 <= 3494U, "panic!");
    uint32_t
    a1b1zetapow =
      /* now multiply a1b1 by power of zeta */ a1b10
      * (uint32_t)symcrust_ntt_zetaTwoTimesBitRevPlus1TimesR[i];
    a0b0 = a0b0 + /* sum pairs of products */ a1b1zetapow ;
    EURYDICE_ASSERT(a0b0 <= 3328U * 3328U + 3494U * 3312U, "panic!");
    a0b1 = a0b1 + a1b0;
    EURYDICE_ASSERT(a0b1 <= 2U * 3328U * 3328U, "panic!");
    EURYDICE_ASSERT(/* We sum at most 4 pairs of products into an accumulator in ML-KEM */
        SYMCRUST_NTT_MATRIX_MAX_NROWS

      <= (size_t)4U,
      "panic!");
    c0 = c0 + a0b0;
    EURYDICE_ASSERT(c0 < 4U * 3328U * 3328U + 4U * 3494U * 3312U, "panic!");
    c1 = c1 + a0b1;
    EURYDICE_ASSERT(c1 < 5U * 3328U * 3328U + 3U * 3494U * 3312U, "panic!");
    paDst[(size_t)2U * i] = c0;
    paDst[(size_t)2U * i + (size_t)1U] = c1;
  }
}

void symcrust_ntt_SymCryptMlKemPolyElementMulR(uint16_t *peSrc, uint16_t *peDst)
{
  for (size_t i = (size_t)0U; i < SYMCRUST_NTT_MLWE_POLYNOMIAL_COEFFICIENTS; i++)
  {
    uint32_t
    uu____0 =
      symcrust_ntt_SymCryptMlKemMontMul((uint32_t)peSrc[i],
        SYMCRUST_NTT_RSQR,
        SYMCRUST_NTT_RSQRTIMESNEGQINVMODR);
    peDst[i] = (uint16_t)uu____0;
  }
}

void symcrust_ntt_SymCryptMlKemPolyElementNTTLayerC(uint16_t *peSrc, size_t k, size_t len)
{
  for (size_t start = (size_t)0U; start < (size_t)256U; start = start + (size_t)2U * len)
  {
    uint32_t twiddleFactor = (uint32_t)symcrust_ntt_MlKemZetaBitRevTimesR[k];
    uint32_t twiddleFactorMont = (uint32_t)symcrust_ntt_MlKemZetaBitRevTimesRTimesNegQInvModR[k];
    k++;
    for (size_t j = (size_t)0U; j < len; j++)
    {
      uint32_t c0 = (uint32_t)peSrc[start + j];
      EURYDICE_ASSERT(c0 < SYMCRUST_NTT_Q, "panic!");
      uint32_t c1 = (uint32_t)peSrc[start + j + len];
      EURYDICE_ASSERT(c1 < SYMCRUST_NTT_Q, "panic!");
      uint32_t
      c1TimesTwiddle = symcrust_ntt_SymCryptMlKemMontMul(c1, twiddleFactor, twiddleFactorMont);
      c1 = symcrust_ntt_SymCryptMlKemModSub(c0, c1TimesTwiddle);
      c0 = symcrust_ntt_SymCryptMlKemModAdd(c0, c1TimesTwiddle);
      peSrc[start + j] = (uint16_t)c0;
      peSrc[start + j + len] = (uint16_t)c1;
    }
  }
}

void symcrust_ntt_SymCryptMlKemPolyElementNTTLayer(uint16_t *peSrc, size_t k, size_t len)
{
  symcrust_ntt_SymCryptMlKemPolyElementNTTLayerC(peSrc, k, len);
}

void symcrust_ntt_SymCryptMlKemPolyElementNTT(uint16_t *peSrc)
{
  symcrust_ntt_SymCryptMlKemPolyElementNTTLayer(peSrc, (size_t)1U, (size_t)128U);
  symcrust_ntt_SymCryptMlKemPolyElementNTTLayer(peSrc, (size_t)2U, (size_t)64U);
  symcrust_ntt_SymCryptMlKemPolyElementNTTLayer(peSrc, (size_t)4U, (size_t)32U);
  symcrust_ntt_SymCryptMlKemPolyElementNTTLayer(peSrc, (size_t)8U, (size_t)16U);
  symcrust_ntt_SymCryptMlKemPolyElementNTTLayer(peSrc, (size_t)16U, (size_t)8U);
  symcrust_ntt_SymCryptMlKemPolyElementNTTLayer(peSrc, (size_t)32U, (size_t)4U);
  symcrust_ntt_SymCryptMlKemPolyElementNTTLayer(peSrc, (size_t)64U, (size_t)2U);
}

void
symcrust_ntt_SymCryptMlKemPolyElementSampleCBDFromBytes(
  Eurydice_slice pbSrc,
  uint32_t eta,
  uint16_t *peDst
)
{
  /* Note (Rust): using an index rather than incrementing pbSrc in place. */
  size_t src_i = (size_t)0U;
  if (!(eta == 2U))
  {
    EURYDICE_ASSERT(eta == 3U, "panic!");
  }
  if (eta == 3U)
  {
    for (size_t i = (size_t)0U; i < SYMCRUST_NTT_MLWE_POLYNOMIAL_COEFFICIENTS; i++)
    {
      uint8_t ret[4U];
      symcrust_ntt_slice_to_sub_array((size_t)4U,
        /* unconditionally load 4 bytes into sampleBits, but only treat the load as being 3 bytes (24-bits -> 4 coefficients) for eta==3 to align to byte boundaries. Source buffer must be 1 byte larger than shake output */
          pbSrc
        ,
        src_i,
        ret,
        void *);
      uint32_t sampleBits = core_num__u32_8__from_le_bytes(ret);
      src_i = src_i + (size_t)3U;
      sampleBits =
        (/* sum bit samples - each consecutive slice of eta bits is summed together */ sampleBits
        & 2396745U)
        + (sampleBits >> 1U & 2396745U)
        + (sampleBits >> 2U & 2396745U);
      uint32_t *x2 = &sampleBits;
      KRML_MAYBE_FOR4(j,
        (size_t)0U,
        (size_t)4U,
        (size_t)1U,
        uint32_t
        coefficient =
          /* each coefficient is formed by taking the difference of two consecutive slices of eta bits the first eta bits are positive, the second eta bits are negative */
            x2[0U]

          & 63U;
        x2[0U] = x2[0U] >> 6U;
        coefficient = (coefficient & 3U) - (coefficient >> 3U);
        if (!(coefficient >= (uint32_t)(int32_t)-3))
        {
          EURYDICE_ASSERT(coefficient <= 3U, "panic!");
        }
        coefficient = coefficient + (SYMCRUST_NTT_Q & coefficient >> 16U);
        EURYDICE_ASSERT(coefficient < SYMCRUST_NTT_Q, "panic!");
        /* each coefficient is formed by taking the difference of two consecutive slices of eta bits the first eta bits are positive, the second eta bits are negative */
          peDst
        [i
        + j]
        = (uint16_t)coefficient;);
    }
  }
  else
  {
    for (size_t i = (size_t)0U; i < SYMCRUST_NTT_MLWE_POLYNOMIAL_COEFFICIENTS; i++)
    {
      uint8_t ret[4U];
      symcrust_ntt_slice_to_sub_array((size_t)4U,
        /* unconditionally load 4 bytes (32-bits -> 8 coefficients) into sampleBits */ pbSrc ,
        src_i,
        ret,
        void *);
      uint32_t sampleBits = core_num__u32_8__from_le_bytes(ret);
      src_i = src_i + (size_t)4U;
      sampleBits =
        (/* sum bit samples - each consecutive slice of eta bits is summed together */ sampleBits
        & 1431655765U)
        + (sampleBits >> 1U & 1431655765U);
      uint32_t *x2 = &sampleBits;
      KRML_MAYBE_FOR8(j,
        (size_t)0U,
        (size_t)8U,
        (size_t)1U,
        uint32_t
        coefficient =
          /* each coefficient is formed by taking the difference of two consecutive slices of eta bits the first eta bits are positive, the second eta bits are negative */
            x2[0U]

          & 15U;
        x2[0U] = x2[0U] >> 4U;
        coefficient = (coefficient & 3U) - (coefficient >> 2U);
        if (!(coefficient >= (uint32_t)(int32_t)-2))
        {
          EURYDICE_ASSERT(coefficient <= 2U, "panic!");
        }
        coefficient = coefficient + (SYMCRUST_NTT_Q & coefficient >> 16U);
        EURYDICE_ASSERT(coefficient < SYMCRUST_NTT_Q, "panic!");
        /* each coefficient is formed by taking the difference of two consecutive slices of eta bits the first eta bits are positive, the second eta bits are negative */
          peDst
        [i
        + j]
        = (uint16_t)coefficient;);
    }
  }
}

void
symcrust_ntt_SymCryptMlKemPolyElementSampleNTTFromShake128(uint8_t *pState, uint16_t *peDst)
{
  size_t i = (size_t)0U;
  uint8_t shakeOutputBuf[24U] = { 0U };
  size_t
  currBufIndex =
    Eurydice_slice_len(Eurydice_array_to_slice((size_t)24U, shakeOutputBuf, uint8_t),
      uint8_t);
  while (i < SYMCRUST_NTT_MLWE_POLYNOMIAL_COEFFICIENTS)
  {
    size_t uu____0 = currBufIndex;
    EURYDICE_ASSERT(uu____0
      <= Eurydice_slice_len(Eurydice_array_to_slice((size_t)24U, shakeOutputBuf, uint8_t), uint8_t),
      "panic!");
    size_t uu____1 = currBufIndex;
    if
    (
      uu____1
      == Eurydice_slice_len(Eurydice_array_to_slice((size_t)24U, shakeOutputBuf, uint8_t), uint8_t)
    )
    {
      symcrust_ntt_SymCryptShake128Extract(/* Note (Rust): shakeOutputBuf[..] seems unnecessary and trips Eurydice (FIXME, see #14) */
          pState
        ,
        Eurydice_array_to_slice((size_t)24U, shakeOutputBuf, uint8_t),
        false);
      currBufIndex = (size_t)0U;
    }
    uint8_t ret0[2U];
    symcrust_ntt_slice_to_sub_array((size_t)2U,
      Eurydice_array_to_slice((size_t)24U, shakeOutputBuf, uint8_t),
      currBufIndex,
      ret0,
      void *);
    uint16_t sample0 = (uint32_t)core_num__u16_7__from_le_bytes(ret0) & 4095U;
    uint8_t ret[2U];
    symcrust_ntt_slice_to_sub_array((size_t)2U,
      Eurydice_array_to_slice((size_t)24U,
        /* TODO: Aeneas crashes if we comment the code below this line */ shakeOutputBuf ,
        uint8_t),
      currBufIndex + (size_t)1U,
      ret,
      void *);
    uint16_t sample1 = (uint32_t)core_num__u16_7__from_le_bytes(ret) >> 4U;
    currBufIndex = currBufIndex + (size_t)3U;
    peDst[i] = sample0;
    i = i + (size_t)((uint32_t)sample0 < SYMCRUST_NTT_Q);
    if (i < SYMCRUST_NTT_MLWE_POLYNOMIAL_COEFFICIENTS)
    {
      peDst[i] = sample1;
      i = i + (size_t)((uint32_t)sample1 < SYMCRUST_NTT_Q);
    }
  }
}

void
symcrust_ntt_SymCryptMlKemPolyElementSub(uint16_t *peSrc1, uint16_t *peSrc2, uint16_t *peDst)
{
  for (size_t i = (size_t)0U; i < SYMCRUST_NTT_MLWE_POLYNOMIAL_COEFFICIENTS; i++)
  {
    uint32_t uu____0 = symcrust_ntt_SymCryptMlKemModSub((uint32_t)peSrc1[i], (uint32_t)peSrc2[i]);
    peDst[i] = (uint16_t)uu____0;
  }
}

