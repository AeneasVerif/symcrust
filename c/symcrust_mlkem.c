/* 
  This file was generated by KaRaMeL <https://github.com/FStarLang/karamel>
  KaRaMeL invocation: /Users/jonathan/Code/eurydice/eurydice symcrust.llbc --output c/ -fcomments --config c.yaml
  F* version: <unknown>
  KaRaMeL version: 52173e05
 */

#include "internal/symcrust_mlkem.h"

#include "symcrust_common.h"
#include "internal/symcrust_hash.h"
#include "internal/symcrust_common.h"

const uint16_t symcrust_key_POLYELEMENT_ZERO[256U] = { 0U };

symcrust_key_InternalParams
symcrust_key_get_internal_params_from_params(symcrust_key_Params params)
{
  if (!(params == symcrust_key_Params_MlKem512))
  {
    if (params == symcrust_key_Params_MlKem768)
    {
      return SYMCRUST_KEY_INTERNAL_PARAMS_ML_KEM768;
    }
    else
    {
      return SYMCRUST_KEY_INTERNAL_PARAMS_ML_KEM1024;
    }
  }
  return SYMCRUST_KEY_INTERNAL_PARAMS_ML_KEM512;
}

core_result_Result_67 symcrust_key_key_allocate2(symcrust_key_Params params)
{
  if (!(params == symcrust_key_Params_MlKem512))
  {
    if (params == symcrust_key_Params_MlKem768)
    {
      /* !!! Make sure to build using &PreKey2, not &Key2, otherwise, the errors are really hard to parse. !!! Make sure to build using &PreKey2, not &Key2, otherwise, the errors are really hard to parse. */
      uint8_t uu____0[32U] = { 0U };
      uint8_t uu____1[32U] = { 0U };
      uint8_t uu____2[32U] = { 0U };
      uint8_t uu____3[1536U] = { 0U };
      uint8_t uu____4[32U] = { 0U };
      core_result_Result_67 lit0;
      lit0.tag = core_result_Ok;
      symcrust_key_PreKey2_7d lit;
      lit.algorithm_info = 0U;
      lit.params = SYMCRUST_KEY_KEY_ALLOCATE2_PARAMS;
      lit.has_private_seed = false;
      lit.has_private_key = false;
      memcpy(lit.private_seed, uu____0, (size_t)32U * sizeof (uint8_t));
      memcpy(lit.private_random, uu____1, (size_t)32U * sizeof (uint8_t));
      memcpy(lit.public_seed, uu____2, (size_t)32U * sizeof (uint8_t));
      memcpy(lit.encoded_t, uu____3, (size_t)1536U * sizeof (uint8_t));
      memcpy(lit.encaps_key_hash, uu____4, (size_t)32U * sizeof (uint8_t));
      lit.n_rows = SYMCRUST_KEY_KEY_ALLOCATE2_N_ROWS;
      uint16_t repeat_expression[15U][256U];
      KRML_MAYBE_FOR15(i,
        (size_t)0U,
        (size_t)15U,
        (size_t)1U,
        memcpy(repeat_expression[i],
          symcrust_key_POLYELEMENT_ZERO,
          (size_t)256U * sizeof (uint16_t)););
      memcpy(lit.data, repeat_expression, (size_t)15U * sizeof (uint16_t [256U]));
      lit0.val.case_Ok.ptr =
        (symcrust_key_Key *)Eurydice_box_new(lit,
          symcrust_key_PreKey2_7d,
          symcrust_key_PreKey2_7d *);
      lit0.val.case_Ok.len = (size_t)15U;
      return lit0;
    }
    else
    {
      uint8_t uu____5[32U] = { 0U };
      uint8_t uu____6[32U] = { 0U };
      uint8_t uu____7[32U] = { 0U };
      uint8_t uu____8[1536U] = { 0U };
      uint8_t uu____9[32U] = { 0U };
      core_result_Result_67 lit0;
      lit0.tag = core_result_Ok;
      symcrust_key_PreKey2_76 lit;
      lit.algorithm_info = 0U;
      lit.params = SYMCRUST_KEY_KEY_ALLOCATE2_PARAMS;
      lit.has_private_seed = false;
      lit.has_private_key = false;
      memcpy(lit.private_seed, uu____5, (size_t)32U * sizeof (uint8_t));
      memcpy(lit.private_random, uu____6, (size_t)32U * sizeof (uint8_t));
      memcpy(lit.public_seed, uu____7, (size_t)32U * sizeof (uint8_t));
      memcpy(lit.encoded_t, uu____8, (size_t)1536U * sizeof (uint8_t));
      memcpy(lit.encaps_key_hash, uu____9, (size_t)32U * sizeof (uint8_t));
      lit.n_rows = SYMCRUST_KEY_KEY_ALLOCATE2_N_ROWS;
      uint16_t repeat_expression[24U][256U];
      for (size_t i = (size_t)0U; i < (size_t)24U; i++)
      {
        memcpy(repeat_expression[i],
          symcrust_key_POLYELEMENT_ZERO,
          (size_t)256U * sizeof (uint16_t));
      }
      memcpy(lit.data, repeat_expression, (size_t)24U * sizeof (uint16_t [256U]));
      lit0.val.case_Ok.ptr =
        (symcrust_key_Key *)Eurydice_box_new(lit,
          symcrust_key_PreKey2_76,
          symcrust_key_PreKey2_76 *);
      lit0.val.case_Ok.len = (size_t)24U;
      return lit0;
    }
  }
  uint8_t uu____10[32U] = { 0U };
  uint8_t uu____11[32U] = { 0U };
  uint8_t uu____12[32U] = { 0U };
  uint8_t uu____13[1536U] = { 0U };
  uint8_t uu____14[32U] = { 0U };
  core_result_Result_67 lit0;
  lit0.tag = core_result_Ok;
  symcrust_key_PreKey2_51 lit;
  lit.algorithm_info = 0U;
  lit.params = SYMCRUST_KEY_KEY_ALLOCATE2_PARAMS;
  lit.has_private_seed = false;
  lit.has_private_key = false;
  memcpy(lit.private_seed, uu____10, (size_t)32U * sizeof (uint8_t));
  memcpy(lit.private_random, uu____11, (size_t)32U * sizeof (uint8_t));
  memcpy(lit.public_seed, uu____12, (size_t)32U * sizeof (uint8_t));
  memcpy(lit.encoded_t, uu____13, (size_t)1536U * sizeof (uint8_t));
  memcpy(lit.encaps_key_hash, uu____14, (size_t)32U * sizeof (uint8_t));
  lit.n_rows = SYMCRUST_KEY_KEY_ALLOCATE2_N_ROWS;
  uint16_t repeat_expression[8U][256U];
  KRML_MAYBE_FOR8(i,
    (size_t)0U,
    (size_t)8U,
    (size_t)1U,
    memcpy(repeat_expression[i], symcrust_key_POLYELEMENT_ZERO, (size_t)256U * sizeof (uint16_t)););
  memcpy(lit.data, repeat_expression, (size_t)8U * sizeof (uint16_t [256U]));
  lit0.val.case_Ok.ptr =
    (symcrust_key_Key *)Eurydice_box_new(lit, symcrust_key_PreKey2_51, symcrust_key_PreKey2_51 *);
  lit0.val.case_Ok.len = (size_t)8U;
  return lit0;
}

core_result_Result_67 symcrust_key_key_allocate(symcrust_key_Params params)
{
  return symcrust_key_key_allocate2(params);
}

/**
This function found in impl {(core::cmp::PartialEq<symcrust::key::Params> for symcrust::key::Params)#2}
*/
inline bool symcrust_key_eq_f1(symcrust_key_Params *self, symcrust_key_Params *other)
{
  ptrdiff_t __self_discr;
  symcrust_key_Params scrut0 = self[0U];
  if (scrut0 == symcrust_key_Params_MlKem512)
  {
    __self_discr = (ptrdiff_t)1;
  }
  else if (scrut0 == symcrust_key_Params_MlKem768)
  {
    __self_discr = (ptrdiff_t)2;
  }
  else
  {
    __self_discr = (ptrdiff_t)3;
  }
  ptrdiff_t __arg1_discr;
  symcrust_key_Params scrut = other[0U];
  if (scrut == symcrust_key_Params_MlKem512)
  {
    __arg1_discr = (ptrdiff_t)1;
  }
  else if (scrut == symcrust_key_Params_MlKem768)
  {
    __arg1_discr = (ptrdiff_t)2;
  }
  else
  {
    __arg1_discr = (ptrdiff_t)3;
  }
  return __self_discr == __arg1_discr;
}

/**
This function found in impl {symcrust::key::PreKey2<@Slice<@Array<u16, 256: usize>>>}
*/
size_t symcrust_key_matrix_len_fd(Eurydice_dst_8c self)
{
  return self.ptr->n_rows * self.ptr->n_rows;
}

/**
This function found in impl {symcrust::key::PreKey2<@Slice<@Array<u16, 256: usize>>>}
*/
Eurydice_slice symcrust_key_atranspose_fd(Eurydice_dst_8c self)
{
  size_t m_len = symcrust_key_matrix_len_fd(self);
  return
    Eurydice_slice_subslice2(Eurydice_slice_of_dst(&self.ptr->data,
        self.len,
        uint16_t [256U],
        Eurydice_slice),
      (size_t)0U,
      m_len,
      uint16_t [256U]);
}

/**
This function found in impl {symcrust::key::PreKey2<@Slice<@Array<u16, 256: usize>>>}
*/
Eurydice_slice symcrust_key_atranspose_mut_fd(Eurydice_dst_8c self)
{
  size_t m_len = symcrust_key_matrix_len_fd(self);
  return
    Eurydice_slice_subslice2(Eurydice_slice_of_dst(&self.ptr->data,
        self.len,
        uint16_t [256U],
        Eurydice_slice),
      (size_t)0U,
      m_len,
      uint16_t [256U]);
}

/**
This function found in impl {symcrust::key::PreKey2<@Slice<@Array<u16, 256: usize>>>}
*/
Eurydice_slice_uint16_t_256size_t__x3 symcrust_key_ats_mut_fd(Eurydice_dst_8c self)
{
  size_t m_len = symcrust_key_matrix_len_fd(self);
  Eurydice_slice_uint16_t_256size_t__x2
  uu____0 =
    Eurydice_slice_split_at_mut(Eurydice_slice_of_dst(&self.ptr->data,
        self.len,
        uint16_t [256U],
        Eurydice_slice),
      m_len,
      uint16_t [256U],
      Eurydice_slice_uint16_t_256size_t__x2);
  Eurydice_slice a = uu____0.fst;
  Eurydice_slice ts = uu____0.snd;
  Eurydice_slice_uint16_t_256size_t__x2
  uu____1 =
    Eurydice_slice_split_at_mut(ts,
      self.ptr->n_rows,
      uint16_t [256U],
      Eurydice_slice_uint16_t_256size_t__x2);
  Eurydice_slice t = uu____1.fst;
  Eurydice_slice s = uu____1.snd;
  Eurydice_slice_uint16_t_256size_t__x3 lit;
  lit.fst = a;
  lit.snd = t;
  lit.thd = s;
  return lit;
}

/**
This function found in impl {symcrust::key::PreKey2<@Slice<@Array<u16, 256: usize>>>}
*/
Eurydice_slice symcrust_key_s_fd(Eurydice_dst_8c self)
{
  size_t m_len = symcrust_key_matrix_len_fd(self);
  Eurydice_slice
  uu____0 = Eurydice_slice_of_dst(&self.ptr->data, self.len, uint16_t [256U], Eurydice_slice);
  return
    Eurydice_slice_subslice2(uu____0,
      m_len + self.ptr->n_rows,
      m_len + (size_t)2U * self.ptr->n_rows,
      uint16_t [256U]);
}

/**
This function found in impl {symcrust::key::PreKey2<@Slice<@Array<u16, 256: usize>>>}
*/
Eurydice_slice symcrust_key_s_mut_fd(Eurydice_dst_8c self)
{
  size_t m_len = symcrust_key_matrix_len_fd(self);
  Eurydice_slice
  uu____0 = Eurydice_slice_of_dst(&self.ptr->data, self.len, uint16_t [256U], Eurydice_slice);
  return
    Eurydice_slice_subslice2(uu____0,
      m_len + self.ptr->n_rows,
      m_len + (size_t)2U * self.ptr->n_rows,
      uint16_t [256U]);
}

/**
This function found in impl {symcrust::key::PreKey2<@Slice<@Array<u16, 256: usize>>>}
*/
Eurydice_slice symcrust_key_t_fd(Eurydice_dst_8c self)
{
  size_t m_len = symcrust_key_matrix_len_fd(self);
  Eurydice_slice
  uu____0 = Eurydice_slice_of_dst(&self.ptr->data, self.len, uint16_t [256U], Eurydice_slice);
  return Eurydice_slice_subslice2(uu____0, m_len, m_len + self.ptr->n_rows, uint16_t [256U]);
}

/**
This function found in impl {symcrust::key::PreKey2<@Slice<@Array<u16, 256: usize>>>}
*/
tuple_48 symcrust_key_t_encoded_t_mut_fd(Eurydice_dst_8c self)
{
  size_t m_len = symcrust_key_matrix_len_fd(self);
  Eurydice_slice
  uu____0 = Eurydice_slice_of_dst(&self.ptr->data, self.len, uint16_t [256U], Eurydice_slice);
  tuple_48 lit;
  lit.fst = Eurydice_slice_subslice2(uu____0, m_len, m_len + self.ptr->n_rows, uint16_t [256U]);
  lit.snd = self.ptr->encoded_t;
  return lit;
}

/**
This function found in impl {symcrust::key::PreKey2<@Slice<@Array<u16, 256: usize>>>}
*/
Eurydice_slice symcrust_key_t_mut_fd(Eurydice_dst_8c self)
{
  size_t m_len = symcrust_key_matrix_len_fd(self);
  Eurydice_slice
  uu____0 = Eurydice_slice_of_dst(&self.ptr->data, self.len, uint16_t [256U], Eurydice_slice);
  return Eurydice_slice_subslice2(uu____0, m_len, m_len + self.ptr->n_rows, uint16_t [256U]);
}

#define MATRIX_MAX_NROWS ((size_t)4U)

#define symcrust_ntt_slice_to_sub_array(x_0, x_1, x_2, x_3, _ret_t) symcrust_ntt_slice_to_sub_array_(x_0, x_1, x_2, x_3)

extern void
symcrust_ntt_slice_to_sub_array_(size_t x0, Eurydice_slice x1, size_t x2, uint8_t *x3);

static uint32_t min(uint32_t x, uint32_t y)
{
  uint32_t uu____0;
  if (x <= y)
  {
    uu____0 = x;
  }
  else
  {
    uu____0 = y;
  }
  return uu____0;
}

#define Q (3329U)

static KRML_MUSTINLINE uint32_t mod_reduce(uint32_t a)
{
  EURYDICE_ASSERT(a < 2U * Q, "panic!");
  uint32_t res = core_num__u32_8__wrapping_sub(a, Q);
  if (!(res >> 16U == 0U))
  {
    EURYDICE_ASSERT(res >> 16U == 65535U, "panic!");
  }
  uint32_t res0 = core_num__u32_8__wrapping_add(res, Q & res >> 16U);
  EURYDICE_ASSERT(res0 < Q, "panic!");
  return res0;
}

static symcrust_common_Error
poly_element_decode_and_decompress(
  Eurydice_slice pb_src,
  uint32_t n_bits_per_coefficient,
  uint16_t *pe_dst
)
{
  /* _In_reads_bytes_(n_bits_per_coefficient*(MLWE_POLYNOMIAL_COEFFICIENTS / 8)) */
  size_t cb_src_read = (size_t)0U;
  uint32_t accumulator = 0U;
  uint32_t n_bits_in_accumulator = 0U;
  EURYDICE_ASSERT(n_bits_per_coefficient > 0U, "panic!");
  EURYDICE_ASSERT(n_bits_per_coefficient <= 12U, "panic!");
  for (size_t i = (size_t)0U; i < SYMCRUST_KEY_MLWE_POLYNOMIAL_COEFFICIENTS; i++)
  {
    uint32_t coefficient = 0U;
    uint32_t n_bits_in_coefficient = 0U;
    size_t *x2 = &cb_src_read;
    uint32_t *x3 = &accumulator;
    uint32_t *x4 = &n_bits_in_accumulator;
    uint32_t *x5 = &coefficient;
    uint32_t *x6 = &n_bits_in_coefficient;
    while (true)
    {
      if (x4[0U] == 0U)
      {
        uint8_t uu____0[4U];
        symcrust_ntt_slice_to_sub_array((size_t)4U,
          /* first gather and decode bits from pb_src FIXME *accumulator = u32::from_le_bytes(&pb_src[*cb_src_read..*cb_src_read+4]).try_into().unwrap()); FIXME *accumulator = u32::from_le_bytes(&pb_src[*cb_src_read..*cb_src_read+4]).try_into().unwrap()); */
            pb_src
          ,
          x2[0U],
          uu____0,
          void *);
        x3[0U] = core_num__u32_8__from_le_bytes(uu____0);
        x2[0U] = x2[0U] + (size_t)4U;
        x4[0U] = 32U;
        uint32_t n_bits_to_decode = min(n_bits_per_coefficient - x6[0U], x4[0U]);
        EURYDICE_ASSERT(n_bits_to_decode <= x4[0U], "panic!");
        uint32_t bits_to_decode = x3[0U] & ((1U << (uint32_t)n_bits_to_decode) - 1U);
        x3[0U] = x3[0U] >> (uint32_t)n_bits_to_decode;
        x4[0U] = x4[0U] - n_bits_to_decode;
        x5[0U] = x5[0U] | bits_to_decode << (uint32_t)x6[0U];
        x6[0U] = x6[0U] + n_bits_to_decode;
        if (!(n_bits_per_coefficient > x6[0U]))
        {
          break;
        }
      }
      else
      {
        uint32_t n_bits_to_decode = min(n_bits_per_coefficient - x6[0U], x4[0U]);
        EURYDICE_ASSERT(n_bits_to_decode <= x4[0U], "panic!");
        uint32_t bits_to_decode = x3[0U] & ((1U << (uint32_t)n_bits_to_decode) - 1U);
        x3[0U] = x3[0U] >> (uint32_t)n_bits_to_decode;
        x4[0U] = x4[0U] - n_bits_to_decode;
        x5[0U] = x5[0U] | bits_to_decode << (uint32_t)x6[0U];
        x6[0U] = x6[0U] + n_bits_to_decode;
        if (!(n_bits_per_coefficient > x6[0U]))
        {
          break;
        }
      }
    }
    EURYDICE_ASSERT(n_bits_in_coefficient == n_bits_per_coefficient, "panic!");
    if
    (
      /* decompress the coefficient when n_bits_per_coefficient < 12 we decompress per Decompress_d in draft FIPS 203 otherwise we perform input validation per 203 6.2 Input validation 2 (Modulus check) */
        n_bits_per_coefficient

      < 12U
    )
    {
      coefficient =
        coefficient *
          /* Multiply by Q / 2^(n_bits_per_coefficient-1) by multiplying by constant and shifting right */
            Q
          ;
      coefficient = coefficient >> (uint32_t)(n_bits_per_coefficient - 1U);
      /* add "half" to round to nearest integer */
      coefficient++;
      /* final divide by two to get multiplication by Q / 2^n_bits_per_coefficient */
      coefficient = coefficient >> 1U;
      coefficient = mod_reduce(/* modular reduction by conditional subtraction */ coefficient );
      EURYDICE_ASSERT(coefficient < Q, "panic!");
    }
    else if (coefficient > Q)
    {
      return symcrust_common_Error_InvalidBlob;
    }
    pe_dst[i] = (uint16_t)coefficient;
  }
  EURYDICE_ASSERT(n_bits_in_accumulator == 0U, "panic!");
  EURYDICE_ASSERT(cb_src_read ==
      (size_t)(n_bits_per_coefficient * ((uint32_t)SYMCRUST_KEY_MLWE_POLYNOMIAL_COEFFICIENTS / 8U)),
    "panic!");
  return symcrust_common_Error_NoError;
}

static symcrust_common_Error
vector_decode_and_decompress(
  Eurydice_slice pb_src,
  uint32_t n_bits_per_coefficient,
  Eurydice_slice pv_dst
)
{
  size_t n_rows = Eurydice_slice_len(pv_dst, uint16_t [256U]);
  EURYDICE_ASSERT(n_rows > (size_t)0U, "panic!");
  EURYDICE_ASSERT(n_rows <= MATRIX_MAX_NROWS, "panic!");
  EURYDICE_ASSERT(n_bits_per_coefficient > 0U, "panic!");
  EURYDICE_ASSERT(n_bits_per_coefficient <= 12U, "panic!");
  EURYDICE_ASSERT(Eurydice_slice_len(pb_src, uint8_t) ==
      n_rows * (size_t)n_bits_per_coefficient *
        (SYMCRUST_KEY_MLWE_POLYNOMIAL_COEFFICIENTS / (size_t)8U),
    "panic!");
  for (size_t i = (size_t)0U; i < n_rows; i++)
  {
    size_t
    pb_src_index =
      i * (size_t)n_bits_per_coefficient * (SYMCRUST_KEY_MLWE_POLYNOMIAL_COEFFICIENTS / (size_t)8U);
    Eurydice_slice
    uu____0 =
      Eurydice_slice_subslice_from(pb_src,
        pb_src_index,
        uint8_t,
        size_t,
        Eurydice_derefed_slice);
    symcrust_common_Error
    sc_error =
      poly_element_decode_and_decompress(uu____0,
        n_bits_per_coefficient,
        Eurydice_slice_index(pv_dst, i, uint16_t [256U], uint16_t (*)[256U]));
    if (!(sc_error == symcrust_common_Error_NoError))
    {
      return sc_error;
    }
  }
  return symcrust_common_Error_NoError;
}

static const
uint16_t
ZETA_BIT_REV_TIMES_R[128U] =
  {
    2285U, 2571U, 2970U, 1812U, 1493U, 1422U, 287U, 202U, 3158U, 622U, 1577U, 182U, 962U, 2127U,
    1855U, 1468U, 573U, 2004U, 264U, 383U, 2500U, 1458U, 1727U, 3199U, 2648U, 1017U, 732U, 608U,
    1787U, 411U, 3124U, 1758U, 1223U, 652U, 2777U, 1015U, 2036U, 1491U, 3047U, 1785U, 516U, 3321U,
    3009U, 2663U, 1711U, 2167U, 126U, 1469U, 2476U, 3239U, 3058U, 830U, 107U, 1908U, 3082U, 2378U,
    2931U, 961U, 1821U, 2604U, 448U, 2264U, 677U, 2054U, 2226U, 430U, 555U, 843U, 2078U, 871U,
    1550U, 105U, 422U, 587U, 177U, 3094U, 3038U, 2869U, 1574U, 1653U, 3083U, 778U, 1159U, 3182U,
    2552U, 1483U, 2727U, 1119U, 1739U, 644U, 2457U, 349U, 418U, 329U, 3173U, 3254U, 817U, 1097U,
    603U, 610U, 1322U, 2044U, 1864U, 384U, 2114U, 3193U, 1218U, 1994U, 2455U, 220U, 2142U, 1670U,
    2144U, 1799U, 2051U, 794U, 1819U, 2475U, 2459U, 478U, 3221U, 3021U, 996U, 991U, 958U, 1869U,
    1522U, 1628U
  };

static const
uint16_t
ZETA_BIT_REV_TIMES_R_TIMES_NEG_Q_INV_MOD_R[128U] =
  {
    19U, 34037U, 50790U, 64748U, 52011U, 12402U, 37345U, 16694U, 20906U, 37778U, 3799U, 15690U,
    54846U, 64177U, 11201U, 34372U, 5827U, 48172U, 26360U, 29057U, 59964U, 1102U, 44097U, 26241U,
    28072U, 41223U, 10532U, 56736U, 47109U, 56677U, 38860U, 16162U, 5689U, 6516U, 64039U, 34569U,
    23564U, 45357U, 44825U, 40455U, 12796U, 38919U, 49471U, 12441U, 56401U, 649U, 25986U, 37699U,
    45652U, 28249U, 15886U, 8898U, 28309U, 56460U, 30198U, 47286U, 52109U, 51519U, 29155U, 12756U,
    48704U, 61224U, 24155U, 17914U, 334U, 54354U, 11477U, 52149U, 32226U, 14233U, 45042U, 21655U,
    27738U, 52405U, 64591U, 4586U, 14882U, 42443U, 59354U, 60043U, 33525U, 32502U, 54905U, 35218U,
    36360U, 18741U, 28761U, 52897U, 18485U, 45436U, 47975U, 47011U, 14430U, 46007U, 5275U, 12618U,
    31183U, 45239U, 40101U, 63390U, 7382U, 50180U, 41144U, 32384U, 20926U, 6279U, 54590U, 14902U,
    41321U, 11044U, 48546U, 51066U, 55200U, 21497U, 7933U, 20198U, 22501U, 42325U, 54629U, 17442U,
    33899U, 23859U, 36892U, 20257U, 41538U, 57779U, 17422U, 42404U
  };

#define RMASK (65535U)

#define NEG_Q_INV_MOD_R (3327U)

#define RLOG2 (16U)

static KRML_MUSTINLINE uint32_t mont_mul(uint32_t a, uint32_t b, uint32_t b_mont)
{
  EURYDICE_ASSERT(a < Q, "panic!");
  EURYDICE_ASSERT(b < Q, "panic!");
  EURYDICE_ASSERT(b_mont <= RMASK, "panic!");
  EURYDICE_ASSERT(b_mont == (b * NEG_Q_INV_MOD_R & RMASK), "panic!");
  uint32_t res = a * b;
  uint32_t inv = a * b_mont & RMASK;
  res = res + inv * Q;
  EURYDICE_ASSERT((res & RMASK) == 0U, "panic!");
  res = res >> (uint32_t)RLOG2;
  return mod_reduce(res);
}

static KRML_MUSTINLINE uint32_t mod_sub(uint32_t a, uint32_t b)
{
  EURYDICE_ASSERT(a < Q, "panic!");
  EURYDICE_ASSERT(b < Q, "panic!");
  uint32_t res = core_num__u32_8__wrapping_sub(a, b);
  if (!(res >> 16U == 0U))
  {
    EURYDICE_ASSERT(res >> 16U == 65535U, "panic!");
  }
  uint32_t res0 = core_num__u32_8__wrapping_add(res, Q & res >> 16U);
  EURYDICE_ASSERT(res0 < Q, "panic!");
  return res0;
}

static KRML_MUSTINLINE uint32_t mod_add(uint32_t a, uint32_t b)
{
  EURYDICE_ASSERT(a < Q, "panic!");
  EURYDICE_ASSERT(b < Q, "panic!");
  return mod_reduce(a + b);
}

static void poly_element_ntt_layer_c(uint16_t *pe_src, size_t k, size_t len)
{
  for (size_t start = (size_t)0U; start < (size_t)256U; start = start + (size_t)2U * len)
  {
    uint32_t twiddle_factor = (uint32_t)ZETA_BIT_REV_TIMES_R[k];
    uint32_t twiddle_factor_mont = (uint32_t)ZETA_BIT_REV_TIMES_R_TIMES_NEG_Q_INV_MOD_R[k];
    k++;
    for (size_t j = (size_t)0U; j < len; j++)
    {
      uint32_t c0 = (uint32_t)pe_src[start + j];
      EURYDICE_ASSERT(c0 < Q, "panic!");
      uint32_t c1 = (uint32_t)pe_src[start + j + len];
      EURYDICE_ASSERT(c1 < Q, "panic!");
      uint32_t c1_times_twiddle = mont_mul(c1, twiddle_factor, twiddle_factor_mont);
      c1 = mod_sub(c0, c1_times_twiddle);
      c0 = mod_add(c0, c1_times_twiddle);
      pe_src[start + j] = (uint16_t)c0;
      pe_src[start + j + len] = (uint16_t)c1;
    }
  }
}

static KRML_MUSTINLINE void poly_element_ntt_layer(uint16_t *pe_src, size_t k, size_t len)
{
  poly_element_ntt_layer_c(pe_src, k, len);
}

static void poly_element_ntt(uint16_t *pe_src)
{
  poly_element_ntt_layer(pe_src, (size_t)1U, (size_t)128U);
  poly_element_ntt_layer(pe_src, (size_t)2U, (size_t)64U);
  poly_element_ntt_layer(pe_src, (size_t)4U, (size_t)32U);
  poly_element_ntt_layer(pe_src, (size_t)8U, (size_t)16U);
  poly_element_ntt_layer(pe_src, (size_t)16U, (size_t)8U);
  poly_element_ntt_layer(pe_src, (size_t)32U, (size_t)4U);
  poly_element_ntt_layer(pe_src, (size_t)64U, (size_t)2U);
}

static void vector_ntt(Eurydice_slice pv_src)
{
  size_t n_rows = Eurydice_slice_len(pv_src, uint16_t [256U]);
  EURYDICE_ASSERT(n_rows > (size_t)0U, "panic!");
  EURYDICE_ASSERT(n_rows <= MATRIX_MAX_NROWS, "panic!");
  for (size_t i = (size_t)0U; i < n_rows; i++)
  {
    poly_element_ntt(Eurydice_slice_index(pv_src, i, uint16_t [256U], uint16_t (*)[256U]));
  }
}

static const
uint16_t
ZETA_TO_TIMES_BIT_REV_PLUS_1_TIMES_R[128U] =
  {
    2226U, 1103U, 430U, 2899U, 555U, 2774U, 843U, 2486U, 2078U, 1251U, 871U, 2458U, 1550U, 1779U,
    105U, 3224U, 422U, 2907U, 587U, 2742U, 177U, 3152U, 3094U, 235U, 3038U, 291U, 2869U, 460U,
    1574U, 1755U, 1653U, 1676U, 3083U, 246U, 778U, 2551U, 1159U, 2170U, 3182U, 147U, 2552U, 777U,
    1483U, 1846U, 2727U, 602U, 1119U, 2210U, 1739U, 1590U, 644U, 2685U, 2457U, 872U, 349U, 2980U,
    418U, 2911U, 329U, 3000U, 3173U, 156U, 3254U, 75U, 817U, 2512U, 1097U, 2232U, 603U, 2726U, 610U,
    2719U, 1322U, 2007U, 2044U, 1285U, 1864U, 1465U, 384U, 2945U, 2114U, 1215U, 3193U, 136U, 1218U,
    2111U, 1994U, 1335U, 2455U, 874U, 220U, 3109U, 2142U, 1187U, 1670U, 1659U, 2144U, 1185U, 1799U,
    1530U, 2051U, 1278U, 794U, 2535U, 1819U, 1510U, 2475U, 854U, 2459U, 870U, 478U, 2851U, 3221U,
    108U, 3021U, 308U, 996U, 2333U, 991U, 2338U, 958U, 2371U, 1869U, 1460U, 1522U, 1807U, 1628U,
    1701U
  };

static void
poly_element_mul_and_accumulate(uint16_t *pe_src1, uint16_t *pe_src2, uint32_t *pa_dst)
{
  for (size_t i = (size_t)0U; i < SYMCRUST_KEY_MLWE_POLYNOMIAL_COEFFICIENTS / (size_t)2U; i++)
  {
    uint32_t a0 = (uint32_t)pe_src1[(size_t)2U * i];
    EURYDICE_ASSERT(a0 < Q, "panic!");
    uint32_t a1 = (uint32_t)pe_src1[(size_t)2U * i + (size_t)1U];
    EURYDICE_ASSERT(a1 < Q, "panic!");
    uint32_t b0 = (uint32_t)pe_src2[(size_t)2U * i];
    EURYDICE_ASSERT(b0 < Q, "panic!");
    uint32_t b1 = (uint32_t)pe_src2[(size_t)2U * i + (size_t)1U];
    EURYDICE_ASSERT(b1 < Q, "panic!");
    uint32_t c0 = pa_dst[(size_t)2U * i];
    EURYDICE_ASSERT(c0 <= 3U * (3328U * 3328U + 3494U * 3312U), "panic!");
    uint32_t c1 = pa_dst[(size_t)2U * i + (size_t)1U];
    EURYDICE_ASSERT(c1 <= 3U * (3328U * 3328U + 3494U * 3312U), "panic!");
    uint32_t a0b0 = /* multiplication results in range [0, 3328*3328] */ a0  * b0;
    uint32_t a1b1 = a1 * b1;
    uint32_t a0b1 = a0 * b1;
    uint32_t a1b0 = a1 * b0;
    uint32_t
    inv =
      core_num__u32_8__wrapping_mul(/* we need a1*b1*zetaTwoTimesBitRevPlus1TimesR[i] eagerly reduce a1*b1 with montgomery reduction a1b1 = red(a1*b1) -> range [0,3494] (3494 is maximum result of first step of montgomery reduction of x*y for x,y in [0,3328]) we do not need to do final reduction yet */
          a1b1
        ,
        NEG_Q_INV_MOD_R)
      & RMASK;
    uint32_t a1b10 = (a1b1 + inv * Q) >> (uint32_t)RLOG2;
    EURYDICE_ASSERT(a1b10 <= 3494U, "panic!");
    uint32_t
    a1b1zetapow =
      /* now multiply a1b1 by power of zeta */ a1b10  *
        (uint32_t)ZETA_TO_TIMES_BIT_REV_PLUS_1_TIMES_R[i];
    a0b0 = a0b0 + /* sum pairs of products */ a1b1zetapow ;
    EURYDICE_ASSERT(a0b0 <= 3328U * 3328U + 3494U * 3312U, "panic!");
    a0b1 = a0b1 + a1b0;
    EURYDICE_ASSERT(a0b1 <= 2U * 3328U * 3328U, "panic!");
    EURYDICE_ASSERT(!!(/* We sum at most 4 pairs of products into an accumulator in ML-KEM */
        MATRIX_MAX_NROWS

      <= (size_t)4U),
      "assert failure");
    c0 = c0 + a0b0;
    EURYDICE_ASSERT(c0 < 4U * 3328U * 3328U + 4U * 3494U * 3312U, "panic!");
    c1 = c1 + a0b1;
    EURYDICE_ASSERT(c1 < 5U * 3328U * 3328U + 3U * 3494U * 3312U, "panic!");
    pa_dst[(size_t)2U * i] = c0;
    pa_dst[(size_t)2U * i + (size_t)1U] = c1;
  }
}

static void
montgomery_reduce_and_add_poly_element_accumulator_to_poly_element(
  uint32_t *pa_src,
  uint16_t *pe_dst
)
{
  for (size_t i = (size_t)0U; i < SYMCRUST_KEY_MLWE_POLYNOMIAL_COEFFICIENTS; i++)
  {
    uint32_t a = pa_src[i];
    EURYDICE_ASSERT(a <= 4U * (3328U * 3328U + 3494U * 3312U), "panic!");
    pa_src[i] = 0U;
    uint32_t c = (uint32_t)pe_dst[i];
    EURYDICE_ASSERT(c < Q, "panic!");
    uint32_t
    inv =
      core_num__u32_8__wrapping_mul(/* montgomery reduce sum of products */ a , NEG_Q_INV_MOD_R) &
        RMASK;
    a = (a + inv * Q) >> (uint32_t)RLOG2;
    EURYDICE_ASSERT(a <= 4711U, "panic!");
    c = c + /* add destination */ a ;
    EURYDICE_ASSERT(c <= 8039U, "panic!");
    c =
      core_num__u32_8__wrapping_sub(/* subtraction and conditional additions for constant time range reduction */
          c
        ,
        2U * Q);
    if (!(c >= (uint32_t)((int32_t)-2 * (int32_t)Q)))
    {
      EURYDICE_ASSERT(c < 1381U, "panic!");
    }
    c = core_num__u32_8__wrapping_add(c, Q & c >> 16U);
    if (!(c >= (uint32_t)-(int32_t)Q))
    {
      EURYDICE_ASSERT(c < Q, "panic!");
    }
    c = core_num__u32_8__wrapping_add(c, Q & c >> 16U);
    EURYDICE_ASSERT(c < Q, "panic!");
    pe_dst[i] = (uint16_t)c;
  }
}

/**
A monomorphic instance of symcrust.common.wipe_slice
with types uint32_t

*/
static void wipe_slice_df(Eurydice_slice pb_dst)
{
  uint8_t *uu____0 = (uint8_t *)core_slice___Slice_T___as_mut_ptr(pb_dst, uint32_t, uint32_t *);
  size_t uu____1 = Eurydice_slice_len(pb_dst, uint32_t);
  symcrust_common_wipe(uu____0, uu____1 * core_mem_size_of(uint32_t, size_t));
}

/**
A monomorphic instance of symcrust.common.wipe_slice
with types uint16_t

*/
static void wipe_slice_de(Eurydice_slice pb_dst)
{
  uint8_t *uu____0 = (uint8_t *)core_slice___Slice_T___as_mut_ptr(pb_dst, uint16_t, uint16_t *);
  size_t uu____1 = Eurydice_slice_len(pb_dst, uint16_t);
  symcrust_common_wipe(uu____0, uu____1 * core_mem_size_of(uint16_t, size_t));
}

static void
vector_mont_dot_product(
  Eurydice_slice pv_src1,
  Eurydice_slice pv_src2,
  uint16_t *pe_dst,
  uint32_t *pa_tmp
)
{
  size_t n_rows = Eurydice_slice_len(pv_src1, uint16_t [256U]);
  EURYDICE_ASSERT(n_rows > (size_t)0U, "panic!");
  EURYDICE_ASSERT(n_rows <= MATRIX_MAX_NROWS, "panic!");
  EURYDICE_ASSERT(Eurydice_slice_len(pv_src2, uint16_t [256U]) == n_rows, "panic!");
  wipe_slice_df(Eurydice_array_to_slice((size_t)256U,
      /* Zero pa_tmp and pe_dst */ pa_tmp ,
      uint32_t));
  wipe_slice_de(Eurydice_array_to_slice((size_t)256U, pe_dst, uint16_t));
  for (size_t i = (size_t)0U; i < n_rows; i++)
  {
    poly_element_mul_and_accumulate(Eurydice_slice_index(pv_src1,
        i,
        uint16_t [256U],
        uint16_t (*)[256U]),
      Eurydice_slice_index(pv_src2, i, uint16_t [256U], uint16_t (*)[256U]),
      pa_tmp);
  }
  montgomery_reduce_and_add_poly_element_accumulator_to_poly_element(/* write accumulator to dest and zero accumulator */
      pa_tmp
    ,
    pe_dst);
}

static void poly_element_intt_layer_c(uint16_t *pe_src, size_t k, size_t len)
{
  for (size_t start = (size_t)0U; start < (size_t)256U; start = start + (size_t)2U * len)
  {
    uint32_t twiddle_factor = (uint32_t)ZETA_BIT_REV_TIMES_R[k];
    uint32_t twiddle_factor_mont = (uint32_t)ZETA_BIT_REV_TIMES_R_TIMES_NEG_Q_INV_MOD_R[k];
    k--;
    for (size_t j = (size_t)0U; j < len; j++)
    {
      uint32_t c0 = (uint32_t)pe_src[start + j];
      EURYDICE_ASSERT(c0 < Q, "panic!");
      uint32_t c1 = (uint32_t)pe_src[start + j + len];
      EURYDICE_ASSERT(c1 < Q, "panic!");
      uint32_t tmp = mod_add(c0, c1);
      c1 = mod_sub(c1, c0);
      c1 = mont_mul(c1, twiddle_factor, twiddle_factor_mont);
      pe_src[start + j] = (uint16_t)tmp;
      pe_src[start + j + len] = (uint16_t)c1;
    }
  }
}

static KRML_MUSTINLINE void poly_element_intt_layer(uint16_t *pe_src, size_t k, size_t len)
{
  poly_element_intt_layer_c(pe_src, k, len);
}

#define INTT_FIXUP_TIMES_RSQR (1441U)

#define INTT_FIXUP_TIMES_RSQR_TIMES_NEQ_Q_INV_MOD_R (10079U)

static void poly_element_intt_and_mul_r(uint16_t *pe_src)
{
  poly_element_intt_layer(pe_src, (size_t)127U, (size_t)2U);
  poly_element_intt_layer(pe_src, (size_t)63U, (size_t)4U);
  poly_element_intt_layer(pe_src, (size_t)31U, (size_t)8U);
  poly_element_intt_layer(pe_src, (size_t)15U, (size_t)16U);
  poly_element_intt_layer(pe_src, (size_t)7U, (size_t)32U);
  poly_element_intt_layer(pe_src, (size_t)3U, (size_t)64U);
  poly_element_intt_layer(pe_src, (size_t)1U, (size_t)128U);
  for (size_t i = (size_t)0U; i < SYMCRUST_KEY_MLWE_POLYNOMIAL_COEFFICIENTS; i++)
  {
    uint32_t
    uu____0 =
      mont_mul((uint32_t)pe_src[i],
        INTT_FIXUP_TIMES_RSQR,
        INTT_FIXUP_TIMES_RSQR_TIMES_NEQ_Q_INV_MOD_R);
    pe_src[i] = (uint16_t)uu____0;
  }
}

static void poly_element_sub(uint16_t *pe_src1, uint16_t *pe_src2, uint16_t *pe_dst)
{
  for (size_t i = (size_t)0U; i < SYMCRUST_KEY_MLWE_POLYNOMIAL_COEFFICIENTS; i++)
  {
    uint32_t uu____0 = mod_sub((uint32_t)pe_src1[i], (uint32_t)pe_src2[i]);
    pe_dst[i] = (uint16_t)uu____0;
  }
}

#define COMPRESS_MULCONSTANT (10321339U)

#define COMPRESS_SHIFTCONSTANT (35U)

static void
poly_element_compress_and_encode(
  uint16_t *pe_src,
  uint32_t n_bits_per_coefficient,
  Eurydice_slice pb_dst
)
{
  /* _Out_writes_bytes_(n_bits_per_coefficient*(MLWE_POLYNOMIAL_COEFFICIENTS / 8)) */
  size_t cb_dst_written = (size_t)0U;
  uint32_t accumulator = 0U;
  uint32_t n_bits_in_accumulator = 0U;
  EURYDICE_ASSERT(n_bits_per_coefficient > 0U, "panic!");
  EURYDICE_ASSERT(n_bits_per_coefficient <= 12U, "panic!");
  for (size_t i = (size_t)0U; i < SYMCRUST_KEY_MLWE_POLYNOMIAL_COEFFICIENTS; i++)
  {
    uint32_t n_bits_in_coefficient = n_bits_per_coefficient;
    uint32_t coefficient = (uint32_t)pe_src[i];
    EURYDICE_ASSERT(coefficient < Q, "panic!");
    if
    (
      /* first compress the coefficient when n_bits_per_coefficient < 12 we compress per Compress_d in draft FIPS 203; */
        n_bits_per_coefficient

      < 12U
    )
    {
      uint64_t
      multiplication =
        (uint64_t)/* Multiply by 2^(n_bits_per_coefficient+1) / Q by multiplying by constant and shifting right */
          coefficient

        * (uint64_t)COMPRESS_MULCONSTANT;
      coefficient =
        (uint32_t)(multiplication >>
          (uint32_t)(COMPRESS_SHIFTCONSTANT - (n_bits_per_coefficient + 1U)));
      /* add "half" to round to nearest integer */
      coefficient++;
      /* final divide by two to get multiplication by 2^n_bits_per_coefficient / Q */
      coefficient = coefficient >> 1U;
      EURYDICE_ASSERT(coefficient <= 1U << (uint32_t)n_bits_per_coefficient, "panic!");
      coefficient =
        coefficient &
          ((1U << (uint32_t)/* modular reduction by masking */ n_bits_per_coefficient ) - 1U);
      EURYDICE_ASSERT(coefficient < 1U << (uint32_t)n_bits_per_coefficient, "panic!");
    }
    size_t *x1 = &cb_dst_written;
    uint32_t *x2 = &accumulator;
    uint32_t *x3 = &n_bits_in_accumulator;
    uint32_t *x4 = &n_bits_in_coefficient;
    uint32_t *x5 = &coefficient;
    while (true)
    {
      uint32_t n_bits_to_encode = min(x4[0U], 32U - x3[0U]);
      uint32_t bits_to_encode = x5[0U] & ((1U << (uint32_t)n_bits_to_encode) - 1U);
      x5[0U] = x5[0U] >> (uint32_t)n_bits_to_encode;
      x4[0U] = x4[0U] - n_bits_to_encode;
      x2[0U] = x2[0U] | bits_to_encode << (uint32_t)x3[0U];
      x3[0U] = x3[0U] + n_bits_to_encode;
      if (x3[0U] == 32U)
      {
        Eurydice_slice
        uu____0 =
          Eurydice_slice_subslice2(/* encode the coefficient simple loop to add bits to accumulator and write accumulator to output */
              pb_dst
            ,
            x1[0U],
            x1[0U] + (size_t)4U,
            uint8_t);
        uint8_t ret[4U];
        core_num__u32_8__to_le_bytes(x2[0U], ret);
        Eurydice_slice_copy(uu____0, Eurydice_array_to_slice((size_t)4U, ret, uint8_t), uint8_t);
        x1[0U] = x1[0U] + (size_t)4U;
        x2[0U] = 0U;
        x3[0U] = 0U;
        if (!(x4[0U] > 0U))
        {
          break;
        }
      }
      else if (!(x4[0U] > 0U))
      {
        break;
      }
    }
  }
  EURYDICE_ASSERT(n_bits_in_accumulator == 0U, "panic!");
  EURYDICE_ASSERT(cb_dst_written ==
      (size_t)(n_bits_per_coefficient * ((uint32_t)SYMCRUST_KEY_MLWE_POLYNOMIAL_COEFFICIENTS / 8U)),
    "panic!");
}

static void
poly_element_sample_cbd_from_bytes(Eurydice_slice pb_src, uint32_t eta, uint16_t *pe_dst)
{
  /* Note (Rust): using an index rather than incrementing pb_src in place. */
  size_t src_i = (size_t)0U;
  if (!(eta == 2U))
  {
    EURYDICE_ASSERT(eta == 3U, "panic!");
  }
  void *uu____0 = (void *)0U;
  if (!(eta == 3U))
  {
    for (size_t i = (size_t)0U; i < SYMCRUST_KEY_MLWE_POLYNOMIAL_COEFFICIENTS; i = i + (size_t)8U)
    {
      uint8_t ret[4U];
      symcrust_ntt_slice_to_sub_array((size_t)4U,
        /* unconditionally load 4 bytes (32-bits -> 8 coefficients) into sample_bits */ pb_src ,
        src_i,
        ret,
        void *);
      uint32_t sample_bits = core_num__u32_8__from_le_bytes(ret);
      src_i = src_i + (size_t)4U;
      sample_bits =
        (/* sum bit samples - each consecutive slice of eta bits is summed together */ sample_bits
        & 1431655765U)
        + (sample_bits >> 1U & 1431655765U);
      uint32_t *x2 = &sample_bits;
      KRML_MAYBE_FOR8(j,
        (size_t)0U,
        (size_t)8U,
        (size_t)1U,
        uint32_t
        coefficient =
          /* each coefficient is formed by taking the difference of two consecutive slices of eta bits the first eta bits are positive, the second eta bits are negative */
            x2[0U]

          & 15U;
        x2[0U] = x2[0U] >> 4U;
        coefficient = core_num__u32_8__wrapping_sub(coefficient & 3U, coefficient >> 2U);
        if (!(coefficient >= (uint32_t)(int32_t)-2))
        {
          EURYDICE_ASSERT(coefficient <= 2U, "panic!");
        }
        coefficient = core_num__u32_8__wrapping_add(coefficient, Q & coefficient >> 16U);
        EURYDICE_ASSERT(coefficient < Q, "panic!");
        /* each coefficient is formed by taking the difference of two consecutive slices of eta bits the first eta bits are positive, the second eta bits are negative */
          pe_dst
        [i + j]
        = (uint16_t)coefficient;);
    }
    return;
  }
  for (size_t i = (size_t)0U; i < SYMCRUST_KEY_MLWE_POLYNOMIAL_COEFFICIENTS; i = i + (size_t)4U)
  {
    uint8_t ret[4U];
    symcrust_ntt_slice_to_sub_array((size_t)4U, pb_src, src_i, ret, void *);
    uint32_t sample_bits = core_num__u32_8__from_le_bytes(ret);
    src_i = src_i + (size_t)3U;
    sample_bits =
      (sample_bits & 2396745U) + (sample_bits >> 1U & 2396745U) + (sample_bits >> 2U & 2396745U);
    uint32_t *x2 = &sample_bits;
    KRML_MAYBE_FOR4(j,
      (size_t)0U,
      (size_t)4U,
      (size_t)1U,
      uint32_t
      coefficient =
        /* each coefficient is formed by taking the difference of two consecutive slices of eta bits the first eta bits are positive, the second eta bits are negative */
          x2[0U]

        & 63U;
      x2[0U] = x2[0U] >> 6U;
      coefficient = core_num__u32_8__wrapping_sub(coefficient & 3U, coefficient >> 3U);
      if (!(coefficient >= (uint32_t)(int32_t)-3))
      {
        EURYDICE_ASSERT(coefficient <= 3U, "panic!");
      }
      coefficient = core_num__u32_8__wrapping_add(coefficient, Q & coefficient >> 16U);
      EURYDICE_ASSERT(coefficient < Q, "panic!");
      pe_dst[i + j] = (uint16_t)coefficient;);
  }
}

static void vector_set_zero(Eurydice_slice pv_src)
{
  size_t n_rows = Eurydice_slice_len(pv_src, uint16_t [256U]);
  EURYDICE_ASSERT(n_rows > (size_t)0U, "panic!");
  EURYDICE_ASSERT(n_rows <= MATRIX_MAX_NROWS, "panic!");
  for (size_t i = (size_t)0U; i < n_rows; i++)
  {
    wipe_slice_de(Eurydice_array_to_slice((size_t)256U,
        Eurydice_slice_index(pv_src, i, uint16_t [256U], uint16_t (*)[256U]),
        uint16_t));
  }
}

static KRML_MUSTINLINE void
poly_element_mul_and_accumulate_aux(
  Eurydice_slice pm_src1,
  size_t n_rows,
  size_t i,
  size_t j,
  uint16_t *pe_src2,
  uint32_t *pa_tmp
)
{
  uint16_t
  *src1 = Eurydice_slice_index(pm_src1, i * n_rows + j, uint16_t [256U], uint16_t (*)[256U]);
  poly_element_mul_and_accumulate(src1, pe_src2, pa_tmp);
}

typedef struct _size_t__x2_s
{
  size_t *fst;
  size_t *snd;
}
_size_t__x2;

static void
matrix_vector_mont_mul_and_add(
  Eurydice_slice pm_src1,
  Eurydice_slice pv_src2,
  Eurydice_slice pv_dst,
  uint32_t *pa_tmp,
  uint8_t n_rows
)
{
  size_t n_rows0 = (size_t)n_rows;
  EURYDICE_ASSERT(n_rows0 > (size_t)0U, "panic!");
  EURYDICE_ASSERT(n_rows0 <= MATRIX_MAX_NROWS, "panic!");
  _size_t__x2 uu____0;
  /* original Rust expression is not an lvalue in C */
  size_t lvalue0 = Eurydice_slice_len(pv_src2, uint16_t [256U]);
  uu____0.fst = &lvalue0;
  uu____0.snd = &n_rows0;
  size_t *left_val = uu____0.fst;
  size_t *right_val0 = uu____0.snd;
  EURYDICE_ASSERT(left_val[0U] == right_val0[0U], "panic!");
  _size_t__x2 uu____1;
  /* original Rust expression is not an lvalue in C */
  size_t lvalue = Eurydice_slice_len(pv_dst, uint16_t [256U]);
  uu____1.fst = &lvalue;
  uu____1.snd = &n_rows0;
  size_t *left_val0 = uu____1.fst;
  size_t *right_val = uu____1.snd;
  EURYDICE_ASSERT(left_val0[0U] == right_val[0U], "panic!");
  wipe_slice_df(Eurydice_array_to_slice((size_t)256U, /* Zero pa_tmp */ pa_tmp , uint32_t));
  for (size_t i = (size_t)0U; i < n_rows0; i++)
  {
    for (size_t j = (size_t)0U; j < n_rows0; j++)
    {
      poly_element_mul_and_accumulate_aux(pm_src1,
        n_rows0,
        i,
        j,
        Eurydice_slice_index(pv_src2, j, uint16_t [256U], uint16_t (*)[256U]),
        pa_tmp);
    }
    montgomery_reduce_and_add_poly_element_accumulator_to_poly_element(/* write accumulator to dest and zero accumulator */
        pa_tmp
      ,
      Eurydice_slice_index(pv_dst, i, uint16_t [256U], uint16_t (*)[256U]));
  }
}

static void vector_intt_and_mul_r(Eurydice_slice pv_src)
{
  size_t n_rows = Eurydice_slice_len(pv_src, uint16_t [256U]);
  EURYDICE_ASSERT(n_rows > (size_t)0U, "panic!");
  EURYDICE_ASSERT(n_rows <= MATRIX_MAX_NROWS, "panic!");
  for (size_t i = (size_t)0U; i < n_rows; i++)
  {
    poly_element_intt_and_mul_r(Eurydice_slice_index(pv_src,
        i,
        uint16_t [256U],
        uint16_t (*)[256U]));
  }
}

static void poly_element_add(uint16_t *pe_src1, uint16_t *pe_src2, uint16_t *pe_dst)
{
  for (size_t i = (size_t)0U; i < SYMCRUST_KEY_MLWE_POLYNOMIAL_COEFFICIENTS; i++)
  {
    uint32_t uu____0 = mod_add((uint32_t)pe_src1[i], (uint32_t)pe_src2[i]);
    pe_dst[i] = (uint16_t)uu____0;
  }
}

static void
vector_compress_and_encode(
  Eurydice_slice pv_src,
  uint32_t n_bits_per_coefficient,
  Eurydice_slice pb_dst
)
{
  size_t n_rows = Eurydice_slice_len(pv_src, uint16_t [256U]);
  EURYDICE_ASSERT(n_rows > (size_t)0U, "panic!");
  EURYDICE_ASSERT(n_rows <= MATRIX_MAX_NROWS, "panic!");
  EURYDICE_ASSERT(n_bits_per_coefficient > 0U, "panic!");
  EURYDICE_ASSERT(n_bits_per_coefficient <= 12U, "panic!");
  EURYDICE_ASSERT(Eurydice_slice_len(pb_dst, uint8_t) ==
      n_rows *
        (size_t)(n_bits_per_coefficient * ((uint32_t)SYMCRUST_KEY_MLWE_POLYNOMIAL_COEFFICIENTS / 8U)),
    "panic!");
  for (size_t i = (size_t)0U; i < n_rows; i++)
  {
    size_t
    pb_dst_index =
      /* Note (Rust): had to change this to do range computation as opposed to in-place pointer increment */
        i

      * (size_t)n_bits_per_coefficient
      * (SYMCRUST_KEY_MLWE_POLYNOMIAL_COEFFICIENTS / (size_t)8U);
    uint16_t *uu____0 = Eurydice_slice_index(pv_src, i, uint16_t [256U], uint16_t (*)[256U]);
    uint32_t uu____1 = n_bits_per_coefficient;
    poly_element_compress_and_encode(uu____0,
      uu____1,
      Eurydice_slice_subslice_from(pb_dst, pb_dst_index, uint8_t, size_t, Eurydice_derefed_slice));
  }
}

symcrust_common_Error
symcrust_mlkem_encapsulate_internal(
  Eurydice_dst_8c pk_mlkem_key,
  Eurydice_slice pb_agreed_secret,
  Eurydice_slice pb_ciphertext,
  uint8_t *pb_random,
  symcrust_ntt_InternalComputationTemporaries *p_comp_temps
)
{
  size_t cb_agreed_secret = Eurydice_slice_len(pb_agreed_secret, uint8_t);
  size_t cb_ciphertext = Eurydice_slice_len(pb_ciphertext, uint8_t);
  uint8_t cbd_sample_buffer[193U] = { 0U };
  /* ERROR sc_error = NO_ERROR; PVECTOR pvr_inner; PVECTOR pv_tmp; PPOLYELEMENT pe_tmp0, pe_tmp1; PPOLYELEMENT_ACCUMULATOR pa_tmp; PSHA3_512_STATE pHashState = &p_comp_temps->hash_state0.sha3_512State; PSHAKE256_STATE pShakeBaseState = &p_comp_temps->hash_state0.shake256State; PSHAKE256_STATE pShakeWorkState = &p_comp_temps->hash_state1.shake256State; SIZE_T cb_u, cb_v; UINT32 i; */
  uint8_t n_rows = pk_mlkem_key.ptr->params.n_rows;
  uint8_t n_bits_of_u = pk_mlkem_key.ptr->params.n_bits_of_u;
  uint8_t n_bits_of_v = pk_mlkem_key.ptr->params.n_bits_of_v;
  uint8_t n_eta1 = pk_mlkem_key.ptr->params.n_eta1;
  uint8_t n_eta2 = pk_mlkem_key.ptr->params.n_eta2;
  size_t
  cb_u =
    (size_t)/* let cbPolyElement = pk_mlkem_key->params.cbPolyElement; let cb_vector = pk_mlkem_key->params.cb_vector; u vector encoded with n_bits_of_u * MLWE_POLYNOMIAL_COEFFICIENTS bits per polynomial */
      n_rows

    * (size_t)n_bits_of_u
    * (SYMCRUST_KEY_MLWE_POLYNOMIAL_COEFFICIENTS / (size_t)8U);
  size_t
  cb_v =
    (size_t)/* v polynomial encoded with n_bits_of_v * MLWE_POLYNOMIAL_COEFFICIENTS bits */
      n_bits_of_v

    * (SYMCRUST_KEY_MLWE_POLYNOMIAL_COEFFICIENTS / (size_t)8U);
  if (!(cb_agreed_secret != SYMCRUST_MLKEM_SIZEOF_AGREED_SECRET))
  {
    if (!(cb_ciphertext != cb_u + cb_v))
    {
      Eurydice_slice
      pvr_inner =
        Eurydice_array_to_subslice2(p_comp_temps->ab_vector_buffer0,
          (size_t)0U,
          (size_t)n_rows,
          uint16_t [256U]);
      Eurydice_slice
      pv_tmp =
        Eurydice_array_to_subslice2(p_comp_temps->ab_vector_buffer1,
          (size_t)0U,
          (size_t)n_rows,
          uint16_t [256U]);
      uint16_t *pe_tmp0 = p_comp_temps->ab_poly_element_buffer0;
      uint16_t *pe_tmp1 = p_comp_temps->ab_poly_element_buffer1;
      uint32_t *pa_tmp = p_comp_temps->ab_poly_element_accumulator_buffer;
      symcrust_hash_sha3_512_init(&p_comp_temps->hash_state0);
      symcrust_hash_sha3_512_append(&p_comp_temps->hash_state0,
        Eurydice_array_to_slice((size_t)32U, pb_random, uint8_t));
      symcrust_hash_sha3_512_append(&p_comp_temps->hash_state0,
        Eurydice_array_to_slice((size_t)32U, pk_mlkem_key.ptr->encaps_key_hash, uint8_t));
      symcrust_hash_HashState *uu____0 = &p_comp_temps->hash_state0;
      symcrust_hash_sha3_512_result(uu____0,
        core_result__core__result__Result_T__E___unwrap(core_convert___core__convert__TryInto_U__Clause2_Error__for_T__6__try_into(core_array___core__convert__TryFrom___a_mut___Slice_T____core__array__TryFromSliceError__for___a_mut___Array_T__N____10__try_from((size_t)64U,
              uint8_t,
              core_result_Result_a0 (*)(Eurydice_slice x0)),
            Eurydice_array_to_subslice2(cbd_sample_buffer,
              (size_t)0U,
              symcrust_hash_SHA3_512_RESULT_SIZE,
              uint8_t),
            Eurydice_slice,
            uint8_t *,
            core_array_TryFromSliceError,
            core_result_Result_a0),
          uint8_t *,
          core_array_TryFromSliceError,
          uint8_t *));
      Eurydice_slice
      uu____1 =
        Eurydice_slice_subslice2(/* Write K to pb_agreed_secret */ pb_agreed_secret ,
          (size_t)0U,
          SYMCRUST_MLKEM_SIZEOF_AGREED_SECRET,
          uint8_t);
      Eurydice_slice_copy(uu____1,
        Eurydice_array_to_subslice2(cbd_sample_buffer,
          (size_t)0U,
          SYMCRUST_MLKEM_SIZEOF_AGREED_SECRET,
          uint8_t),
        uint8_t);
      symcrust_hash_shake256_init(&p_comp_temps->hash_state0);
      symcrust_hash_HashState *uu____2 = &p_comp_temps->hash_state0;
      symcrust_hash_shake256_append(uu____2,
        Eurydice_array_to_subslice2(cbd_sample_buffer,
          cb_agreed_secret,
          cb_agreed_secret + (size_t)32U,
          uint8_t));
      for (uint8_t i = 0U; i < n_rows; i = (uint32_t)i + 1U)
      {
        cbd_sample_buffer[0U] = i;
        symcrust_hash_shake256_state_copy(&p_comp_temps->hash_state0, &p_comp_temps->hash_state1);
        symcrust_hash_HashState *uu____3 = &p_comp_temps->hash_state1;
        symcrust_hash_shake256_append(uu____3,
          Eurydice_array_to_subslice2(cbd_sample_buffer, (size_t)0U, (size_t)1U, uint8_t));
        symcrust_hash_HashState *uu____4 = &p_comp_temps->hash_state1;
        symcrust_hash_shake256_extract(uu____4,
          Eurydice_array_to_subslice2(cbd_sample_buffer,
            (size_t)0U,
            (size_t)64U * (size_t)n_eta1,
            uint8_t),
          false);
        poly_element_sample_cbd_from_bytes(Eurydice_array_to_slice((size_t)193U,
            cbd_sample_buffer,
            uint8_t),
          (uint32_t)n_eta1,
          Eurydice_slice_index(pvr_inner, (size_t)i, uint16_t [256U], uint16_t (*)[256U]));
      }
      vector_ntt(/* Perform NTT on rInner */ pvr_inner );
      vector_set_zero(/* Set pv_tmp to 0 TODO: write a helper function -- any way to do this better? */
          pv_tmp
        );
      matrix_vector_mont_mul_and_add(symcrust_key_atranspose_mut_fd(/* pv_tmp.copy_from_slice(&vec![POLYELEMENT_ZERO; n_rows as usize].into_boxed_slice()); VectorSetZero( pv_tmp ); pv_tmp = (Atranspose o rInner) ./ R */
            pk_mlkem_key
          ),
        pvr_inner,
        pv_tmp,
        pa_tmp,
        n_rows);
      vector_intt_and_mul_r(/* pv_tmp = INTT(Atranspose o rInner) */ pv_tmp );
      for (uint8_t i = 0U; i < n_rows; i = (uint32_t)i + 1U)
      {
        cbd_sample_buffer[0U] = (uint32_t)n_rows + (uint32_t)i;
        symcrust_hash_shake256_state_copy(&p_comp_temps->hash_state0, &p_comp_temps->hash_state1);
        symcrust_hash_HashState *uu____5 = &p_comp_temps->hash_state1;
        symcrust_hash_shake256_append(uu____5,
          Eurydice_array_to_subslice2(cbd_sample_buffer, (size_t)0U, (size_t)1U, uint8_t));
        symcrust_hash_HashState *uu____6 = &p_comp_temps->hash_state1;
        symcrust_hash_shake256_extract(uu____6,
          Eurydice_array_to_subslice2(cbd_sample_buffer,
            (size_t)0U,
            (size_t)64U * (size_t)n_eta2,
            uint8_t),
          false);
        poly_element_sample_cbd_from_bytes(Eurydice_array_to_slice((size_t)193U,
            cbd_sample_buffer,
            uint8_t),
          (uint32_t)n_eta2,
          pe_tmp0);
        uint16_t copy[256U];
        memcpy(copy,
          Eurydice_slice_index(pv_tmp,
            (size_t)/* Note (Rust): in-place operation here, was: PolyElementAdd( INTERNAL_MLKEM_VECTOR_ELEMENT(i, pv_tmp), pe_tmp0, INTERNAL_MLKEM_VECTOR_ELEMENT(i, pv_tmp) ); Added a copy -- TODO: measure performance impact of the copy */
              i
            ,
            uint16_t [256U],
            uint16_t (*)[256U]),
          (size_t)256U * sizeof (uint16_t));
        poly_element_add(copy,
          pe_tmp0,
          Eurydice_slice_index(pv_tmp, (size_t)i, uint16_t [256U], uint16_t (*)[256U]));
      }
      vector_compress_and_encode(/* pv_tmp = u = INTT(Atranspose o rInner) + e1 Compress and encode u into prefix of ciphertext */
          pv_tmp
        ,
        (uint32_t)n_bits_of_u,
        Eurydice_slice_subslice2(pb_ciphertext, (size_t)0U, cb_u, uint8_t));
      vector_mont_dot_product(symcrust_key_t_mut_fd(/* pe_tmp0 = (t o r) ./ R */ pk_mlkem_key ),
        pvr_inner,
        pe_tmp0,
        pa_tmp);
      poly_element_intt_and_mul_r(/* pe_tmp0 = INTT(t o r) */ pe_tmp0 );
      cbd_sample_buffer[0U] = 2U * (uint32_t)/* Expand e2 polynomial in pe_tmp1 */ n_rows ;
      symcrust_hash_shake256_state_copy(&p_comp_temps->hash_state0, &p_comp_temps->hash_state1);
      symcrust_hash_HashState *uu____7 = &p_comp_temps->hash_state1;
      symcrust_hash_shake256_append(uu____7,
        Eurydice_array_to_subslice2(cbd_sample_buffer, (size_t)0U, (size_t)1U, uint8_t));
      symcrust_hash_HashState *uu____8 = &p_comp_temps->hash_state1;
      symcrust_hash_shake256_extract(uu____8,
        Eurydice_array_to_subslice2(cbd_sample_buffer,
          (size_t)0U,
          (size_t)64U * (size_t)n_eta2,
          uint8_t),
        false);
      poly_element_sample_cbd_from_bytes(Eurydice_array_to_slice((size_t)193U,
          cbd_sample_buffer,
          uint8_t),
        (uint32_t)n_eta2,
        pe_tmp1);
      uint16_t copy[256U];
      /* peTmp = INTT(t o r) + e2 Note (Rust): in-place operation, was: PolyElementAdd( pe_tmp0, pe_tmp1, pe_tmp0 ); FIXME (measure performance issues, adjust) */
      memcpy(copy, pe_tmp0, (size_t)256U * sizeof (uint16_t));
      poly_element_add(copy, pe_tmp1, pe_tmp0);
      LowStar_Ignore_ignore(poly_element_decode_and_decompress(Eurydice_array_to_slice((size_t)32U,
            /* pe_tmp1 = mu */ pb_random ,
            uint8_t),
          1U,
          pe_tmp1),
        symcrust_common_Error,
        void *);
      uint16_t copy0[256U];
      /* pe_tmp0 = v = INTT(t o r) + e2 + mu */
      memcpy(copy0, pe_tmp0, (size_t)256U * sizeof (uint16_t));
      poly_element_add(/* FIXME (same as above) */ copy0 , pe_tmp1, pe_tmp0);
      /* Compress and encode v into remainder of ciphertext */
      uint16_t *uu____9 = pe_tmp0;
      uint32_t uu____10 = (uint32_t)n_bits_of_v;
      poly_element_compress_and_encode(uu____9,
        uu____10,
        Eurydice_slice_subslice_from(pb_ciphertext, cb_u, uint8_t, size_t, Eurydice_derefed_slice));
      return symcrust_common_Error_NoError;
    }
  }
  return symcrust_common_Error_InvalidArgument;
}

symcrust_common_Error
symcrust_mlkem_decapsulate(
  Eurydice_dst_8c pk_mlkem_key,
  Eurydice_slice pb_ciphertext,
  Eurydice_slice pb_agreed_secret
)
{
  size_t cb_ciphertext = Eurydice_slice_len(pb_ciphertext, uint8_t);
  size_t cb_agreed_secret = Eurydice_slice_len(pb_agreed_secret, uint8_t);
  uint16_t uu____0[4U][256U];
  KRML_MAYBE_FOR4(i,
    (size_t)0U,
    (size_t)4U,
    (size_t)1U,
    memcpy(uu____0[i], symcrust_key_POLYELEMENT_ZERO, (size_t)256U * sizeof (uint16_t)););
  uint16_t uu____1[4U][256U];
  KRML_MAYBE_FOR4(i,
    (size_t)0U,
    (size_t)4U,
    (size_t)1U,
    memcpy(uu____1[i], symcrust_key_POLYELEMENT_ZERO, (size_t)256U * sizeof (uint16_t)););
  symcrust_ntt_InternalComputationTemporaries lit;
  memcpy(lit.ab_vector_buffer0, uu____0, (size_t)4U * sizeof (uint16_t [256U]));
  memcpy(lit.ab_vector_buffer1, uu____1, (size_t)4U * sizeof (uint16_t [256U]));
  memcpy(lit.ab_poly_element_buffer0,
    symcrust_key_POLYELEMENT_ZERO,
    (size_t)256U * sizeof (uint16_t));
  memcpy(lit.ab_poly_element_buffer1,
    symcrust_key_POLYELEMENT_ZERO,
    (size_t)256U * sizeof (uint16_t));
  uint32_t repeat_expression[256U] = { 0U };
  memcpy(lit.ab_poly_element_accumulator_buffer,
    repeat_expression,
    (size_t)256U * sizeof (uint32_t));
  lit.hash_state0 = symcrust_hash_UNINITIALIZED_HASH_STATE;
  lit.hash_state1 = symcrust_hash_UNINITIALIZED_HASH_STATE;
  core_result_Result_80
  p_comp_temps0 =
    alloc_boxed__alloc__boxed__Box_T___try_new(lit,
      symcrust_ntt_InternalComputationTemporaries,
      core_result_Result_80);
  symcrust_common_Error uu____2;
  if (p_comp_temps0.tag == core_result_Ok)
  {
    symcrust_ntt_InternalComputationTemporaries *p_comp_temps = p_comp_temps0.f0;
    symcrust_ntt_InternalComputationTemporaries *p_comp_temps1 = p_comp_temps;
    uint8_t pb_decrypted_random[32U] = { 0U };
    uint8_t pb_decapsulated_secret[32U] = { 0U };
    uint8_t pb_implicit_rejection_secret[32U] = { 0U };
    core_result_Result_4c
    pb_comp_ciphers =
      alloc_vec__alloc__vec__Vec_T__alloc__alloc__Global___try_with_capacity((size_t)2U *
          /* PBYTE pbReadCiphertext, pbReencapsulatedCiphertext; BOOLEAN successfulReencrypt; Note (Rust): we originally perform a single call to malloc() and use the first few bytes for the temporary computations, then for the two temporary ciphertexts. Rust does not allow to do this, so we perform two allocations. Note (Rust): rather than use the (simple) solution below, which does not allow catching memory allocation failures, we instead use the experimental try_with_capacity API: let pb_comp_ciphers = vec![0u8; 2*cb_ciphertext].into_boxed_slice(); */
            cb_ciphertext
          ,
        uint8_t,
        core_result_Result_4c);
    if (pb_comp_ciphers.tag == core_result_Ok)
    {
      alloc_vec_Vec pb_comp_ciphers0 = pb_comp_ciphers.val.case_Ok;
      alloc_vec_Vec pb_comp_ciphers1 = pb_comp_ciphers0;
      alloc_vec__alloc__vec__Vec_T__A__2__resize(&pb_comp_ciphers1,
        (size_t)2U * cb_ciphertext,
        0U,
        uint8_t,
        void *,
        void *);
      Eurydice_slice
      pb_comp_ciphers2 =
        alloc_vec__alloc__vec__Vec_T__A__1__into_boxed_slice(pb_comp_ciphers1,
          uint8_t,
          void *,
          Eurydice_slice);
      Eurydice_slice_uint8_t_x2
      uu____3 =
        Eurydice_slice_split_at_mut(pb_comp_ciphers2,
          cb_ciphertext,
          uint8_t,
          Eurydice_slice_uint8_t_x2);
      Eurydice_slice pb_read_ciphertext = uu____3.fst;
      Eurydice_slice pb_reencapsulated_ciphertext = uu____3.snd;
      /* ERROR sc_error = NO_ERROR; SIZE_T cb_u, cb_v, cbCopy; PVECTOR pvu; PPOLYELEMENT pe_tmp0, pe_tmp1; PPOLYELEMENT_ACCUMULATOR pa_tmp; PSHAKE256_STATE p_shake_state; */
      uint8_t n_rows = pk_mlkem_key.ptr->params.n_rows;
      uint8_t n_bits_of_u = pk_mlkem_key.ptr->params.n_bits_of_u;
      uint8_t n_bits_of_v = pk_mlkem_key.ptr->params.n_bits_of_v;
      size_t
      cb_u =
        (size_t)/* let cbPolyElement = pk_mlkem_key.params.cbPolyElement; let cb_vector = pk_mlkem_key.params.cb_vector; u vector encoded with n_bits_of_u * MLWE_POLYNOMIAL_COEFFICIENTS bits per polynomial */
          n_rows

        * (size_t)n_bits_of_u
        * (SYMCRUST_KEY_MLWE_POLYNOMIAL_COEFFICIENTS / (size_t)8U);
      size_t
      cb_v =
        (size_t)/* v polynomial encoded with n_bits_of_v * MLWE_POLYNOMIAL_COEFFICIENTS bits */
          n_bits_of_v

        * (SYMCRUST_KEY_MLWE_POLYNOMIAL_COEFFICIENTS / (size_t)8U);
      if (!(cb_agreed_secret != SYMCRUST_MLKEM_SIZEOF_AGREED_SECRET))
      {
        if (!(cb_ciphertext != cb_u + cb_v))
        {
          if (pk_mlkem_key.ptr->has_private_key)
          {
            Eurydice_slice_copy(/* Read the input ciphertext once to local pbReadCiphertext to ensure our view of ciphertext consistent */
                pb_read_ciphertext
              ,
              pb_ciphertext,
              uint8_t);
            Eurydice_slice
            pvu =
              Eurydice_array_to_subslice2(p_comp_temps1->ab_vector_buffer0,
                (size_t)0U,
                (size_t)n_rows,
                uint16_t [256U]);
            uint16_t *pe_tmp0 = p_comp_temps1->ab_poly_element_buffer0;
            uint16_t *pe_tmp1 = p_comp_temps1->ab_poly_element_buffer1;
            uint32_t *pa_tmp = p_comp_temps1->ab_poly_element_accumulator_buffer;
            symcrust_common_Error
            sc_error =
              vector_decode_and_decompress(Eurydice_slice_subslice2(/* Decode and decompress u */
                    pb_read_ciphertext
                  ,
                  (size_t)0U,
                  cb_u,
                  uint8_t),
                (uint32_t)n_bits_of_u,
                pvu);
            /* original Rust expression is not an lvalue in C */
            symcrust_common_Error lvalue0 = symcrust_common_Error_NoError;
            EURYDICE_ASSERT(symcrust_common_eq_3d(&sc_error, &lvalue0), "panic!");
            vector_ntt(/* Perform NTT on u */ pvu );
            vector_mont_dot_product(symcrust_key_s_mut_fd(/* pe_tmp0 = (s o NTT(u)) ./ R */
                  pk_mlkem_key
                ),
              pvu,
              pe_tmp0,
              pa_tmp);
            poly_element_intt_and_mul_r(/* pe_tmp0 = INTT(s o NTT(u)) */ pe_tmp0 );
            symcrust_common_Error
            sc_error0 =
              poly_element_decode_and_decompress(Eurydice_slice_subslice_from(/* Decode and decompress v */
                    pb_read_ciphertext
                  ,
                  cb_u,
                  uint8_t,
                  size_t,
                  Eurydice_derefed_slice),
                (uint32_t)n_bits_of_v,
                pe_tmp1);
            /* original Rust expression is not an lvalue in C */
            symcrust_common_Error lvalue1 = symcrust_common_Error_NoError;
            EURYDICE_ASSERT(symcrust_common_eq_3d(&sc_error0, &lvalue1), "panic!");
            uint16_t copy[256U];
            /* pe_tmp0 = w = v - INTT(s o NTT(u)) FIXME */
            memcpy(copy, pe_tmp0, (size_t)256U * sizeof (uint16_t));
            poly_element_sub(pe_tmp1, copy, pe_tmp0);
            poly_element_compress_and_encode(/* pbDecryptedRandom = m' = Encoding of w */ pe_tmp0 ,
              1U,
              Eurydice_array_to_slice((size_t)32U, pb_decrypted_random, uint8_t));
            symcrust_common_Error
            sc_error1 =
              symcrust_mlkem_encapsulate_internal(/* Compute: pbDecapsulatedSecret = K' = Decapsulated secret (without implicit rejection) pbReencapsulatedCiphertext = c' = Ciphertext from re-encapsulating decrypted random value */
                  pk_mlkem_key
                ,
                Eurydice_array_to_slice((size_t)32U, pb_decapsulated_secret, uint8_t),
                pb_reencapsulated_ciphertext,
                pb_decrypted_random,
                p_comp_temps1);
            /* original Rust expression is not an lvalue in C */
            symcrust_common_Error lvalue = symcrust_common_Error_NoError;
            EURYDICE_ASSERT(symcrust_common_eq_3d(&sc_error1, &lvalue), "panic!");
            /* Compute the secret we will return if using implicit rejection pbImplicitRejectionSecret = K_bar = SHAKE256( z || c ) */
            symcrust_hash_HashState *p_shake_state = &p_comp_temps1->hash_state0;
            symcrust_hash_shake256_init(p_shake_state);
            symcrust_hash_shake256_append(p_shake_state,
              Eurydice_array_to_slice((size_t)32U, pk_mlkem_key.ptr->private_random, uint8_t));
            symcrust_hash_shake256_append(p_shake_state, pb_read_ciphertext);
            symcrust_hash_shake256_extract(p_shake_state,
              Eurydice_array_to_slice((size_t)32U, pb_implicit_rejection_secret, uint8_t),
              false);
            bool
            successful_reencrypt =
              core_cmp_impls___core__cmp__PartialEq__0_mut__B___for__1_mut__A___13__eq(/* Constant time test if re-encryption successful */
                  &pb_reencapsulated_ciphertext
                ,
                &pb_read_ciphertext,
                Eurydice_derefed_slice,
                Eurydice_derefed_slice,
                bool);
            size_t
            cb_copy =
              core_num__usize_11__wrapping_sub((size_t)/* If not successful, perform side-channel-safe copy of Implicit Rejection secret over Decapsulated secret */
                  successful_reencrypt
                ,
                (size_t)1U)
              & SYMCRUST_MLKEM_SIZEOF_AGREED_SECRET;
            Eurydice_slice
            uu____4 =
              Eurydice_array_to_subslice2(pb_decapsulated_secret,
                (size_t)0U,
                cb_copy,
                uint8_t);
            Eurydice_slice_copy(uu____4,
              Eurydice_array_to_subslice2(pb_implicit_rejection_secret,
                (size_t)0U,
                cb_copy,
                uint8_t),
              uint8_t);
            Eurydice_slice_copy(/* FIXME, was: SymCryptScsCopy( pbImplicitRejectionSecret, cbCopy, pbDecapsulatedSecret, SIZEOF_AGREED_SECRET ); Write agreed secret (with implicit rejection) to pb_agreed_secret */
                pb_agreed_secret
              ,
              Eurydice_array_to_slice((size_t)32U, pb_decapsulated_secret, uint8_t),
              uint8_t);
            return symcrust_common_Error_NoError;
          }
        }
      }
      uu____2 = symcrust_common_Error_InvalidArgument;
    }
    else
    {
      uu____2 = symcrust_common_Error_MemoryAllocationFailure;
    }
  }
  else
  {
    uu____2 = symcrust_common_Error_MemoryAllocationFailure;
  }
  return uu____2;
}

symcrust_common_Error
symcrust_mlkem_encapsulate_ex(
  Eurydice_dst_8c pk_mlkem_key,
  Eurydice_slice pb_random,
  Eurydice_slice pb_agreed_secret,
  Eurydice_slice pb_ciphertext
)
{
  size_t cb_random = Eurydice_slice_len(/* wrapper enforce it */ pb_random , uint8_t);
  symcrust_common_Error uu____0;
  if
  (
    /* let cb_agreed_secret = pb_agreed_secret.len(); let cb_ciphertext = pb_ciphertext.len(); */
      cb_random

    != SYMCRUST_MLKEM_SIZEOF_ENCAPS_RANDOM
  )
  {
    uu____0 = symcrust_common_Error_InvalidArgument;
  }
  else
  {
    uint16_t uu____1[4U][256U];
    KRML_MAYBE_FOR4(i,
      (size_t)0U,
      (size_t)4U,
      (size_t)1U,
      memcpy(uu____1[i], symcrust_key_POLYELEMENT_ZERO, (size_t)256U * sizeof (uint16_t)););
    uint16_t uu____2[4U][256U];
    KRML_MAYBE_FOR4(i,
      (size_t)0U,
      (size_t)4U,
      (size_t)1U,
      memcpy(uu____2[i], symcrust_key_POLYELEMENT_ZERO, (size_t)256U * sizeof (uint16_t)););
    symcrust_ntt_InternalComputationTemporaries lit;
    memcpy(lit.ab_vector_buffer0, uu____1, (size_t)4U * sizeof (uint16_t [256U]));
    memcpy(lit.ab_vector_buffer1, uu____2, (size_t)4U * sizeof (uint16_t [256U]));
    memcpy(lit.ab_poly_element_buffer0,
      symcrust_key_POLYELEMENT_ZERO,
      (size_t)256U * sizeof (uint16_t));
    memcpy(lit.ab_poly_element_buffer1,
      symcrust_key_POLYELEMENT_ZERO,
      (size_t)256U * sizeof (uint16_t));
    uint32_t repeat_expression[256U] = { 0U };
    memcpy(lit.ab_poly_element_accumulator_buffer,
      repeat_expression,
      (size_t)256U * sizeof (uint32_t));
    lit.hash_state0 = symcrust_hash_UNINITIALIZED_HASH_STATE;
    lit.hash_state1 = symcrust_hash_UNINITIALIZED_HASH_STATE;
    core_result_Result_80
    p_comp_temps =
      alloc_boxed__alloc__boxed__Box_T___try_new(lit,
        symcrust_ntt_InternalComputationTemporaries,
        core_result_Result_80);
    if (p_comp_temps.tag == core_result_Ok)
    {
      symcrust_ntt_InternalComputationTemporaries *p_comp_temps0 = p_comp_temps.f0;
      symcrust_ntt_InternalComputationTemporaries *p_comp_temps1 = p_comp_temps0;
      Eurydice_dst_8c uu____3 = pk_mlkem_key;
      Eurydice_slice uu____4 = pb_agreed_secret;
      Eurydice_slice uu____5 = pb_ciphertext;
      uint8_t
      *uu____6 =
        core_result__core__result__Result_T__E___unwrap(core_convert___core__convert__TryInto_U__Clause2_Error__for_T__6__try_into(core_array___core__convert__TryFrom___a___Slice_T____core__array__TryFromSliceError__for___a___Array_T__N____9__try_from((size_t)32U,
              uint8_t,
              core_result_Result_a0 (*)(Eurydice_slice x0)),
            pb_random,
            Eurydice_slice,
            uint8_t *,
            core_array_TryFromSliceError,
            core_result_Result_a0),
          uint8_t *,
          core_array_TryFromSliceError,
          uint8_t *);
      return symcrust_mlkem_encapsulate_internal(uu____3, uu____4, uu____5, uu____6, p_comp_temps1);
    }
    else
    {
      uu____0 = symcrust_common_Error_MemoryAllocationFailure;
    }
  }
  return uu____0;
}

symcrust_common_Error
symcrust_mlkem_encapsulate(
  Eurydice_dst_8c pk_mlkem_key,
  Eurydice_slice pb_agreed_secret,
  Eurydice_slice pb_ciphertext
)
{
  uint8_t pbm[32U] = { 0U };
  symcrust_common_Error
  sc_error = symcrust_common_random(Eurydice_array_to_slice((size_t)32U, pbm, uint8_t));
  /* original Rust expression is not an lvalue in C */
  symcrust_common_Error lvalue = symcrust_common_Error_NoError;
  if
  (
    !symcrust_common___core__cmp__PartialEq_symcrust__common__Error__for_symcrust__common__Error__1__ne(&sc_error,
      &lvalue)
  )
  {
    return
      symcrust_mlkem_encapsulate_ex(pk_mlkem_key,
        Eurydice_array_to_slice((size_t)32U, pbm, uint8_t),
        pb_agreed_secret,
        pb_ciphertext);
  }
  return sc_error;
}

size_t symcrust_mlkem_sizeof_encoded_uncompressed_vector(size_t _n_rows)
{
  return (size_t)384U * _n_rows;
}

void
symcrust_mlkem_key_compute_encapsulation_key_hash(
  Eurydice_dst_8c pk_mlkem_key,
  symcrust_ntt_InternalComputationTemporaries *p_comp_temps
)
{
  symcrust_hash_HashState *p_state = &p_comp_temps->hash_state0;
  size_t
  cb_encoded_vector =
    symcrust_mlkem_sizeof_encoded_uncompressed_vector((size_t)pk_mlkem_key.ptr->params.n_rows);
  symcrust_hash_sha3_256_init(p_state);
  symcrust_hash_HashState *uu____0 = p_state;
  symcrust_hash_sha3_256_append(uu____0,
    Eurydice_array_to_subslice2(pk_mlkem_key.ptr->encoded_t,
      (size_t)0U,
      cb_encoded_vector,
      uint8_t));
  symcrust_hash_sha3_256_append(p_state,
    Eurydice_array_to_slice((size_t)32U, pk_mlkem_key.ptr->public_seed, uint8_t));
  symcrust_hash_sha3_256_result(p_state, pk_mlkem_key.ptr->encaps_key_hash);
}

static void
poly_element_sample_ntt_from_shake128(symcrust_hash_HashState *p_state, uint16_t *pe_dst)
{
  size_t i = (size_t)0U;
  uint8_t shake_output_buf[24U] = { 0U };
  size_t
  curr_buf_index =
    Eurydice_slice_len(Eurydice_array_to_slice((size_t)24U, shake_output_buf, uint8_t),
      uint8_t);
  while (i < SYMCRUST_KEY_MLWE_POLYNOMIAL_COEFFICIENTS)
  {
    size_t uu____0 = curr_buf_index;
    EURYDICE_ASSERT(uu____0 <=
        Eurydice_slice_len(Eurydice_array_to_slice((size_t)24U, shake_output_buf, uint8_t),
          uint8_t),
      "panic!");
    size_t uu____1 = curr_buf_index;
    if
    (
      uu____1 ==
        Eurydice_slice_len(Eurydice_array_to_slice((size_t)24U, shake_output_buf, uint8_t),
          uint8_t)
    )
    {
      symcrust_hash_shake128_extract(/* Note (Rust): shakeOutputBuf[..] seems unnecessary and trips Eurydice (FIXME, see #14) */
          p_state
        ,
        Eurydice_array_to_slice((size_t)24U, shake_output_buf, uint8_t),
        false);
      curr_buf_index = (size_t)0U;
    }
    uint8_t ret0[2U];
    symcrust_ntt_slice_to_sub_array((size_t)2U,
      Eurydice_array_to_slice((size_t)24U, shake_output_buf, uint8_t),
      curr_buf_index,
      ret0,
      void *);
    uint16_t sample0 = (uint32_t)core_num__u16_7__from_le_bytes(ret0) & 4095U;
    uint8_t ret[2U];
    symcrust_ntt_slice_to_sub_array((size_t)2U,
      Eurydice_array_to_slice((size_t)24U,
        /* TODO: Aeneas crashes if we comment the code below this line */ shake_output_buf ,
        uint8_t),
      curr_buf_index + (size_t)1U,
      ret,
      void *);
    uint16_t sample1 = (uint32_t)core_num__u16_7__from_le_bytes(ret) >> 4U;
    curr_buf_index = curr_buf_index + (size_t)3U;
    pe_dst[i] = sample0;
    i = i + (size_t)((uint32_t)sample0 < Q);
    if (i < SYMCRUST_KEY_MLWE_POLYNOMIAL_COEFFICIENTS)
    {
      pe_dst[i] = sample1;
      i = i + (size_t)((uint32_t)sample1 < Q);
    }
  }
}

void
symcrust_mlkem_key_expand_public_matrix_from_public_seed(
  Eurydice_dst_8c pk_mlkem_key,
  symcrust_ntt_InternalComputationTemporaries *p_comp_temps
)
{
  uint8_t coordinates[2U] = { 0U };
  symcrust_hash_HashState *p_shake_state_base = &p_comp_temps->hash_state0;
  symcrust_hash_HashState *p_shake_state_work = &p_comp_temps->hash_state1;
  uint8_t n_rows = pk_mlkem_key.ptr->params.n_rows;
  symcrust_hash_shake128_init(p_shake_state_base);
  symcrust_hash_shake128_append(p_shake_state_base,
    Eurydice_array_to_slice((size_t)32U, pk_mlkem_key.ptr->public_seed, uint8_t));
  for (uint8_t i = 0U; i < n_rows; i = (uint32_t)i + 1U)
  {
    coordinates[1U] = i;
    for (uint8_t j = 0U; j < n_rows; j = (uint32_t)j + 1U)
    {
      coordinates[0U] = j;
      symcrust_hash_shake128_state_copy(p_shake_state_base, p_shake_state_work);
      symcrust_hash_shake128_append(p_shake_state_work,
        Eurydice_array_to_slice((size_t)2U, coordinates, uint8_t));
      Eurydice_slice a_transpose = symcrust_key_atranspose_mut_fd(pk_mlkem_key);
      poly_element_sample_ntt_from_shake128(p_shake_state_work,
        Eurydice_slice_index(a_transpose,
          (size_t)((uint32_t)i * (uint32_t)n_rows + (uint32_t)j),
          uint16_t [256U],
          uint16_t (*)[256U]));
    }
  }
}

#define RSQR (1353U)

#define RSQR_TIMES_NEG_Q_INV_MOD_R (44983U)

static void poly_element_mul_r(uint16_t *pe_src, uint16_t *pe_dst)
{
  for (size_t i = (size_t)0U; i < SYMCRUST_KEY_MLWE_POLYNOMIAL_COEFFICIENTS; i++)
  {
    uint32_t uu____0 = mont_mul((uint32_t)pe_src[i], RSQR, RSQR_TIMES_NEG_Q_INV_MOD_R);
    pe_dst[i] = (uint16_t)uu____0;
  }
}

static void vector_mul_r(Eurydice_slice pv_src, Eurydice_slice pv_dst)
{
  size_t n_rows = Eurydice_slice_len(pv_src, uint16_t [256U]);
  EURYDICE_ASSERT(n_rows > (size_t)0U, "panic!");
  EURYDICE_ASSERT(n_rows <= MATRIX_MAX_NROWS, "panic!");
  EURYDICE_ASSERT(Eurydice_slice_len(pv_dst, uint16_t [256U]) == n_rows, "panic!");
  for (size_t i = (size_t)0U; i < n_rows; i++)
  {
    poly_element_mul_r(Eurydice_slice_index(pv_src, i, uint16_t [256U], uint16_t (*)[256U]),
      Eurydice_slice_index(pv_dst, i, uint16_t [256U], uint16_t (*)[256U]));
  }
}

static void matrix_transpose(Eurydice_slice pm_src, uint8_t n_rows)
{
  size_t n_rows0 = (size_t)n_rows;
  EURYDICE_ASSERT(n_rows0 > (size_t)0U, "panic!");
  EURYDICE_ASSERT(n_rows0 <= MATRIX_MAX_NROWS, "panic!");
  for (size_t i = (size_t)0U; i < n_rows0; i++)
  {
    for (size_t j = i + (size_t)1U; j < n_rows0; j++)
    {
      core_slice___Slice_T___swap(pm_src,
        i * n_rows0 + j,
        j * n_rows0 + i,
        uint16_t [256U],
        void *);
    }
  }
}

/**
A monomorphic instance of symcrust.common.wipe_slice
with types uint8_t

*/
static void wipe_slice_90(Eurydice_slice pb_dst)
{
  uint8_t *uu____0 = (uint8_t *)core_slice___Slice_T___as_mut_ptr(pb_dst, uint8_t, uint8_t *);
  size_t uu____1 = Eurydice_slice_len(pb_dst, uint8_t);
  symcrust_common_wipe(uu____0, uu____1 * core_mem_size_of(uint8_t, size_t));
}

void
symcrust_mlkem_key_expand_from_private_seed(
  Eurydice_dst_8c pk_mlkem_key,
  symcrust_ntt_InternalComputationTemporaries *p_comp_temps
)
{
  uint8_t private_seed_hash[64U] = { 0U };
  uint8_t cbd_sample_buffer[193U] = { 0U };
  /* PVECTOR pv_tmp; PPOLYELEMENT_ACCUMULATOR pa_tmp; UINT32 i; */
  uint8_t n_rows = pk_mlkem_key.ptr->params.n_rows;
  uint8_t n_eta1 = pk_mlkem_key.ptr->params.n_eta1;
  size_t cb_encoded_vector = symcrust_mlkem_sizeof_encoded_uncompressed_vector((size_t)n_rows);
  EURYDICE_ASSERT(!!pk_mlkem_key.ptr->has_private_seed, "assert failure");
  if (!(n_eta1 == 2U))
  {
    EURYDICE_ASSERT(n_eta1 == 3U, "panic!");
  }
  uint8_t *uu____0 = cbd_sample_buffer;
  core_ops_range_Range_08 lit0;
  lit0.start = (size_t)0U;
  lit0.end =
    Eurydice_slice_len(Eurydice_array_to_slice((size_t)32U,
        pk_mlkem_key.ptr->private_seed,
        uint8_t),
      uint8_t);
  Eurydice_slice
  uu____1 =
    Eurydice_array_to_subslice((size_t)193U,
      uu____0,
      lit0,
      uint8_t,
      core_ops_range_Range_08,
      Eurydice_derefed_slice);
  Eurydice_slice_copy(uu____1,
    Eurydice_array_to_slice((size_t)32U, pk_mlkem_key.ptr->private_seed, uint8_t),
    uint8_t);
  uint8_t uu____2 = n_rows;
  cbd_sample_buffer[Eurydice_slice_len(Eurydice_array_to_slice((size_t)32U,
      pk_mlkem_key.ptr->private_seed,
      uint8_t),
    uint8_t)]
  = uu____2;
  uint8_t *uu____3 = cbd_sample_buffer;
  core_ops_range_Range_08 lit1;
  lit1.start = (size_t)0U;
  lit1.end =
    Eurydice_slice_len(Eurydice_array_to_slice((size_t)32U,
        pk_mlkem_key.ptr->private_seed,
        uint8_t),
      uint8_t)
    + (size_t)1U;
  symcrust_hash_sha3_512(Eurydice_array_to_subslice((size_t)193U,
      uu____3,
      lit1,
      uint8_t,
      core_ops_range_Range_08,
      Eurydice_derefed_slice),
    private_seed_hash);
  size_t
  pk_len =
    Eurydice_slice_len(Eurydice_array_to_slice((size_t)32U, pk_mlkem_key.ptr->public_seed, uint8_t),
      uint8_t);
  Eurydice_slice
  uu____4 = Eurydice_array_to_slice((size_t)32U, pk_mlkem_key.ptr->public_seed, uint8_t);
  Eurydice_slice_copy(uu____4,
    Eurydice_array_to_subslice2(private_seed_hash, (size_t)0U, pk_len, uint8_t),
    uint8_t);
  symcrust_mlkem_key_expand_public_matrix_from_public_seed(pk_mlkem_key, p_comp_temps);
  symcrust_hash_shake256_init(&p_comp_temps->hash_state0);
  symcrust_hash_HashState *uu____5 = &p_comp_temps->hash_state0;
  uint8_t *uu____6 = private_seed_hash;
  core_ops_range_Range_08 lit;
  lit.start =
    Eurydice_slice_len(Eurydice_array_to_slice((size_t)32U, pk_mlkem_key.ptr->public_seed, uint8_t),
      uint8_t);
  lit.end =
    Eurydice_slice_len(Eurydice_array_to_slice((size_t)32U, pk_mlkem_key.ptr->public_seed, uint8_t),
      uint8_t)
    + (size_t)32U;
  symcrust_hash_shake256_append(uu____5,
    Eurydice_array_to_subslice((size_t)64U,
      uu____6,
      lit,
      uint8_t,
      core_ops_range_Range_08,
      Eurydice_derefed_slice));
  for (uint8_t i = 0U; i < n_rows; i = (uint32_t)i + 1U)
  {
    cbd_sample_buffer[0U] = i;
    symcrust_hash_shake256_state_copy(&p_comp_temps->hash_state0, &p_comp_temps->hash_state1);
    symcrust_hash_HashState *uu____7 = &p_comp_temps->hash_state1;
    symcrust_hash_shake256_append(uu____7,
      Eurydice_array_to_subslice2(cbd_sample_buffer, (size_t)0U, (size_t)1U, uint8_t));
    symcrust_hash_HashState *uu____8 = &p_comp_temps->hash_state1;
    symcrust_hash_shake256_extract(uu____8,
      Eurydice_array_to_subslice2(cbd_sample_buffer,
        (size_t)0U,
        (size_t)64U * (size_t)n_eta1,
        uint8_t),
      false);
    Eurydice_slice uu____9 = Eurydice_array_to_slice((size_t)193U, cbd_sample_buffer, uint8_t);
    uint32_t uu____10 = (uint32_t)n_eta1;
    poly_element_sample_cbd_from_bytes(uu____9,
      uu____10,
      Eurydice_slice_index(symcrust_key_s_mut_fd(pk_mlkem_key),
        (size_t)i,
        uint16_t [256U],
        uint16_t (*)[256U]));
  }
  for (uint8_t i = 0U; i < n_rows; i = (uint32_t)i + 1U)
  {
    cbd_sample_buffer[0U] = (uint32_t)n_rows + (uint32_t)i;
    symcrust_hash_shake256_state_copy(&p_comp_temps->hash_state0, &p_comp_temps->hash_state1);
    symcrust_hash_HashState *uu____11 = &p_comp_temps->hash_state1;
    symcrust_hash_shake256_append(uu____11,
      Eurydice_array_to_subslice2(cbd_sample_buffer, (size_t)0U, (size_t)1U, uint8_t));
    symcrust_hash_HashState *uu____12 = &p_comp_temps->hash_state1;
    symcrust_hash_shake256_extract(uu____12,
      Eurydice_array_to_subslice2(cbd_sample_buffer,
        (size_t)0U,
        (size_t)64U * (size_t)n_eta1,
        uint8_t),
      false);
    Eurydice_slice uu____13 = Eurydice_array_to_slice((size_t)193U, cbd_sample_buffer, uint8_t);
    uint32_t uu____14 = (uint32_t)n_eta1;
    poly_element_sample_cbd_from_bytes(uu____13,
      uu____14,
      Eurydice_slice_index(symcrust_key_t_mut_fd(pk_mlkem_key),
        (size_t)i,
        uint16_t [256U],
        uint16_t (*)[256U]));
  }
  vector_ntt(symcrust_key_s_mut_fd(pk_mlkem_key));
  vector_ntt(symcrust_key_t_mut_fd(pk_mlkem_key));
  Eurydice_slice
  pv_tmp =
    Eurydice_array_to_subslice2(p_comp_temps->ab_vector_buffer0,
      (size_t)0U,
      (size_t)n_rows,
      uint16_t [256U]);
  vector_mul_r(symcrust_key_s_mut_fd(pk_mlkem_key), pv_tmp);
  Eurydice_slice_uint16_t_256size_t__x3 uu____15 = symcrust_key_ats_mut_fd(pk_mlkem_key);
  Eurydice_slice a = uu____15.fst;
  Eurydice_slice t0 = uu____15.snd;
  uint32_t *pa_tmp = p_comp_temps->ab_poly_element_accumulator_buffer;
  Eurydice_slice uu____16 = a;
  matrix_vector_mont_mul_and_add(uu____16,
    Eurydice_array_to_subslice2(p_comp_temps->ab_vector_buffer0,
      (size_t)0U,
      (size_t)n_rows,
      uint16_t [256U]),
    t0,
    pa_tmp,
    n_rows);
  matrix_transpose(symcrust_key_atranspose_mut_fd(pk_mlkem_key), n_rows);
  tuple_48 uu____17 = symcrust_key_t_encoded_t_mut_fd(pk_mlkem_key);
  Eurydice_slice t = uu____17.fst;
  uint8_t *encoded_t = uu____17.snd;
  Eurydice_slice uu____18 = t;
  vector_compress_and_encode(uu____18,
    12U,
    Eurydice_array_to_subslice2(encoded_t, (size_t)0U, cb_encoded_vector, uint8_t));
  symcrust_mlkem_key_compute_encapsulation_key_hash(pk_mlkem_key, p_comp_temps);
  wipe_slice_90(Eurydice_array_to_slice((size_t)64U, private_seed_hash, uint8_t));
  wipe_slice_90(Eurydice_array_to_slice((size_t)193U, cbd_sample_buffer, uint8_t));
}

size_t symcrust_mlkem_sizeof_format_decapsulation_key(size_t _n_rows)
{
  return
    (size_t)2U * symcrust_mlkem_sizeof_encoded_uncompressed_vector(_n_rows) +
      (size_t)3U * (size_t)32U;
}

size_t symcrust_mlkem_sizeof_format_encapsulation_key(size_t _n_rows)
{
  return symcrust_mlkem_sizeof_encoded_uncompressed_vector(_n_rows) + (size_t)32U;
}

symcrust_common_Error
symcrust_mlkem_key_set_value(
  Eurydice_slice pb_src,
  symcrust_key_Format format,
  uint32_t flags,
  Eurydice_dst_8c pk_mlkem_key
)
{
  /* ERROR sc_error = NO_ERROR; */
  size_t pb_curr = (size_t)0U;
  /* PINTERNAL_COMPUTATION_TEMPORARIES p_comp_temps = NULL; */
  uint8_t n_rows = pk_mlkem_key.ptr->params.n_rows;
  size_t cb_encoded_vector = symcrust_mlkem_sizeof_encoded_uncompressed_vector((size_t)n_rows);
  uint32_t
  allowed_flags =
    /* Ensure only allowed flags are specified */ SYMCRUST_MLKEM_FLAG_KEY_NO_FIPS  |
      SYMCRUST_MLKEM_FLAG_KEY_MINIMAL_VALIDATION;
  symcrust_common_Error uu____0;
  if ((flags & ~allowed_flags) != 0U)
  {
    uu____0 = symcrust_common_Error_InvalidArgument;
  }
  else
  {
    if
    (
      (/* Check that minimal validation flag only specified with no fips */ flags  &
        SYMCRUST_MLKEM_FLAG_KEY_NO_FIPS)
      == 0U
    )
    {
      if ((flags & SYMCRUST_MLKEM_FLAG_KEY_MINIMAL_VALIDATION) != 0U)
      {
        uu____0 = symcrust_common_Error_InvalidArgument;
      }
    }
    if
    (
      (/* Note (Rust): ruled out by typing if( mlKemkeyFormat == crate::key::Format_NULL ) { return MLKEM_ERROR::INVALID_ARGUMENT; } */
        flags

      & SYMCRUST_MLKEM_FLAG_KEY_NO_FIPS)
      == 0U
    )
    {
      uint16_t uu____1[4U][256U];
      KRML_MAYBE_FOR4(i,
        (size_t)0U,
        (size_t)4U,
        (size_t)1U,
        memcpy(uu____1[i], symcrust_key_POLYELEMENT_ZERO, (size_t)256U * sizeof (uint16_t)););
      uint16_t uu____2[4U][256U];
      KRML_MAYBE_FOR4(i,
        (size_t)0U,
        (size_t)4U,
        (size_t)1U,
        memcpy(uu____2[i], symcrust_key_POLYELEMENT_ZERO, (size_t)256U * sizeof (uint16_t)););
      symcrust_ntt_InternalComputationTemporaries lit;
      memcpy(lit.ab_vector_buffer0, uu____1, (size_t)4U * sizeof (uint16_t [256U]));
      memcpy(lit.ab_vector_buffer1, uu____2, (size_t)4U * sizeof (uint16_t [256U]));
      memcpy(lit.ab_poly_element_buffer0,
        symcrust_key_POLYELEMENT_ZERO,
        (size_t)256U * sizeof (uint16_t));
      memcpy(lit.ab_poly_element_buffer1,
        symcrust_key_POLYELEMENT_ZERO,
        (size_t)256U * sizeof (uint16_t));
      uint32_t repeat_expression[256U] = { 0U };
      memcpy(lit.ab_poly_element_accumulator_buffer,
        repeat_expression,
        (size_t)256U * sizeof (uint32_t));
      lit.hash_state0 = symcrust_hash_UNINITIALIZED_HASH_STATE;
      lit.hash_state1 = symcrust_hash_UNINITIALIZED_HASH_STATE;
      core_result_Result_80
      p_comp_temps =
        alloc_boxed__alloc__boxed__Box_T___try_new(lit,
          symcrust_ntt_InternalComputationTemporaries,
          core_result_Result_80);
      if (p_comp_temps.tag == core_result_Ok)
      {
        symcrust_ntt_InternalComputationTemporaries *p_comp_temps0 = p_comp_temps.f0;
        symcrust_ntt_InternalComputationTemporaries *p_comp_temps1 = p_comp_temps0;
        bool uu____3;
        bool uu____4;
        size_t uu____5;
        size_t uu____6;
        Eurydice_slice uu____7;
        if (format == symcrust_key_Format_PrivateSeed)
        {
          if (!(Eurydice_slice_len(pb_src, uint8_t) != SYMCRUST_MLKEM_SIZEOF_FORMAT_PRIVATE_SEED))
          {
            pk_mlkem_key.ptr->has_private_seed = true;
            size_t
            l =
              Eurydice_slice_len(Eurydice_array_to_slice((size_t)32U,
                  pk_mlkem_key.ptr->private_seed,
                  uint8_t),
                uint8_t);
            Eurydice_slice_copy(Eurydice_array_to_slice((size_t)32U,
                pk_mlkem_key.ptr->private_seed,
                uint8_t),
              Eurydice_slice_subslice2(pb_src, (size_t)0U, l, uint8_t),
              uint8_t);
            pb_curr = pb_curr + l;
            pk_mlkem_key.ptr->has_private_key = true;
            size_t
            l0 =
              Eurydice_slice_len(Eurydice_array_to_slice((size_t)32U,
                  pk_mlkem_key.ptr->private_random,
                  uint8_t),
                uint8_t);
            Eurydice_slice_copy(Eurydice_array_to_slice((size_t)32U,
                pk_mlkem_key.ptr->private_random,
                uint8_t),
              Eurydice_slice_subslice2(pb_src, pb_curr, pb_curr + l0, uint8_t),
              uint8_t);
            pb_curr = pb_curr + l0;
            symcrust_mlkem_key_expand_from_private_seed(pk_mlkem_key, p_comp_temps1);
            uu____3 = true;
            if (uu____3)
            {
              /* Note (Rust): exhaustiveness else { sc_error = NOT_IMPLEMENTED; goto cleanup; } */
              uu____5 = pb_curr;
              uu____7 = pb_src;
              uu____6 = Eurydice_slice_len(uu____7, uint8_t);
              uu____4 = uu____5 == uu____6;
              EURYDICE_ASSERT(uu____4, "panic!");
            }
            return symcrust_common_Error_NoError;
          }
          uu____0 = symcrust_common_Error_WrongKeySize;
        }
        else if (format == symcrust_key_Format_DecapsulationKey)
        {
          size_t uu____8 = Eurydice_slice_len(pb_src, uint8_t);
          if (uu____8 != symcrust_mlkem_sizeof_format_decapsulation_key((size_t)n_rows))
          {
            uu____0 = symcrust_common_Error_WrongKeySize;
          }
          else
          {
            Eurydice_slice
            uu____9 =
              Eurydice_slice_subslice2(pb_src,
                pb_curr,
                pb_curr + cb_encoded_vector,
                uint8_t);
            symcrust_common_Error
            sc_error =
              vector_decode_and_decompress(uu____9,
                12U,
                symcrust_key_s_mut_fd(pk_mlkem_key));
            /* original Rust expression is not an lvalue in C */
            symcrust_common_Error lvalue0 = symcrust_common_Error_NoError;
            if
            (
              symcrust_common___core__cmp__PartialEq_symcrust__common__Error__for_symcrust__common__Error__1__ne(&sc_error,
                &lvalue0)
            )
            {
              uu____0 = sc_error;
            }
            else
            {
              pb_curr = pb_curr + cb_encoded_vector;
              Eurydice_slice
              uu____10 =
                Eurydice_array_to_subslice2(pk_mlkem_key.ptr->encoded_t,
                  (size_t)0U,
                  cb_encoded_vector,
                  uint8_t);
              Eurydice_slice_copy(uu____10,
                Eurydice_slice_subslice2(pb_src, pb_curr, pb_curr + cb_encoded_vector, uint8_t),
                uint8_t);
              pb_curr = pb_curr + cb_encoded_vector;
              tuple_48 uu____11 = symcrust_key_t_encoded_t_mut_fd(pk_mlkem_key);
              Eurydice_slice t = uu____11.fst;
              uint8_t *encoded_t = uu____11.snd;
              symcrust_common_Error
              sc_error0 =
                vector_decode_and_decompress(Eurydice_array_to_subslice2(encoded_t,
                    (size_t)0U,
                    cb_encoded_vector,
                    uint8_t),
                  12U,
                  t);
              /* original Rust expression is not an lvalue in C */
              symcrust_common_Error lvalue = symcrust_common_Error_NoError;
              if
              (
                !symcrust_common___core__cmp__PartialEq_symcrust__common__Error__for_symcrust__common__Error__1__ne(&sc_error0,
                  &lvalue)
              )
              {
                size_t
                l =
                  Eurydice_slice_len(Eurydice_array_to_slice((size_t)32U,
                      pk_mlkem_key.ptr->public_seed,
                      uint8_t),
                    uint8_t);
                Eurydice_slice_copy(Eurydice_array_to_slice((size_t)32U,
                    pk_mlkem_key.ptr->public_seed,
                    uint8_t),
                  Eurydice_slice_subslice2(pb_src, pb_curr, pb_curr + l, uint8_t),
                  uint8_t);
                pb_curr =
                  pb_curr +
                    Eurydice_slice_len(Eurydice_array_to_slice((size_t)32U,
                        pk_mlkem_key.ptr->public_seed,
                        uint8_t),
                      uint8_t);
                symcrust_mlkem_key_expand_public_matrix_from_public_seed(pk_mlkem_key,
                  p_comp_temps1);
                matrix_transpose(symcrust_key_atranspose_mut_fd(pk_mlkem_key), n_rows);
                size_t
                l0 =
                  Eurydice_slice_len(Eurydice_array_to_slice((size_t)32U,
                      pk_mlkem_key.ptr->encaps_key_hash,
                      uint8_t),
                    uint8_t);
                Eurydice_slice_copy(Eurydice_array_to_slice((size_t)32U,
                    pk_mlkem_key.ptr->encaps_key_hash,
                    uint8_t),
                  Eurydice_slice_subslice2(pb_src, pb_curr, pb_curr + l0, uint8_t),
                  uint8_t);
                pb_curr =
                  pb_curr +
                    Eurydice_slice_len(Eurydice_array_to_slice((size_t)32U,
                        pk_mlkem_key.ptr->encaps_key_hash,
                        uint8_t),
                      uint8_t);
                size_t
                l1 =
                  Eurydice_slice_len(Eurydice_array_to_slice((size_t)32U,
                      pk_mlkem_key.ptr->private_random,
                      uint8_t),
                    uint8_t);
                Eurydice_slice_copy(Eurydice_array_to_slice((size_t)32U,
                    pk_mlkem_key.ptr->private_random,
                    uint8_t),
                  Eurydice_slice_subslice2(pb_src, pb_curr, pb_curr + l1, uint8_t),
                  uint8_t);
                pb_curr =
                  pb_curr +
                    Eurydice_slice_len(Eurydice_array_to_slice((size_t)32U,
                        pk_mlkem_key.ptr->private_random,
                        uint8_t),
                      uint8_t);
                pk_mlkem_key.ptr->has_private_seed = false;
                pk_mlkem_key.ptr->has_private_key = true;
                uu____3 = true;
                if (uu____3)
                {
                  uu____5 = pb_curr;
                  uu____7 = pb_src;
                  uu____6 = Eurydice_slice_len(uu____7, uint8_t);
                  uu____4 = uu____5 == uu____6;
                  EURYDICE_ASSERT(uu____4, "panic!");
                }
                return symcrust_common_Error_NoError;
              }
              uu____0 = sc_error0;
            }
          }
        }
        else
        {
          size_t uu____12 = Eurydice_slice_len(pb_src, uint8_t);
          if (uu____12 != symcrust_mlkem_sizeof_format_encapsulation_key((size_t)n_rows))
          {
            uu____0 = symcrust_common_Error_WrongKeySize;
          }
          else
          {
            Eurydice_slice
            uu____13 =
              Eurydice_array_to_subslice2(pk_mlkem_key.ptr->encoded_t,
                (size_t)0U,
                cb_encoded_vector,
                uint8_t);
            Eurydice_slice_copy(uu____13,
              Eurydice_slice_subslice2(pb_src, pb_curr, pb_curr + cb_encoded_vector, uint8_t),
              uint8_t);
            pb_curr = pb_curr + cb_encoded_vector;
            tuple_48 uu____14 = symcrust_key_t_encoded_t_mut_fd(pk_mlkem_key);
            Eurydice_slice t = uu____14.fst;
            uint8_t *encoded_t = uu____14.snd;
            symcrust_common_Error
            sc_error =
              vector_decode_and_decompress(Eurydice_array_to_subslice2(encoded_t,
                  (size_t)0U,
                  cb_encoded_vector,
                  uint8_t),
                12U,
                t);
            /* original Rust expression is not an lvalue in C */
            symcrust_common_Error lvalue = symcrust_common_Error_NoError;
            if
            (
              !symcrust_common___core__cmp__PartialEq_symcrust__common__Error__for_symcrust__common__Error__1__ne(&sc_error,
                &lvalue)
            )
            {
              size_t
              l =
                Eurydice_slice_len(Eurydice_array_to_slice((size_t)32U,
                    pk_mlkem_key.ptr->public_seed,
                    uint8_t),
                  uint8_t);
              Eurydice_slice_copy(Eurydice_array_to_slice((size_t)32U,
                  pk_mlkem_key.ptr->public_seed,
                  uint8_t),
                Eurydice_slice_subslice2(pb_src, pb_curr, pb_curr + l, uint8_t),
                uint8_t);
              pb_curr =
                pb_curr +
                  Eurydice_slice_len(Eurydice_array_to_slice((size_t)32U,
                      pk_mlkem_key.ptr->public_seed,
                      uint8_t),
                    uint8_t);
              symcrust_mlkem_key_expand_public_matrix_from_public_seed(pk_mlkem_key, p_comp_temps1);
              matrix_transpose(symcrust_key_atranspose_mut_fd(pk_mlkem_key), n_rows);
              symcrust_mlkem_key_compute_encapsulation_key_hash(pk_mlkem_key, p_comp_temps1);
              pk_mlkem_key.ptr->has_private_seed = false;
              pk_mlkem_key.ptr->has_private_key = false;
              uu____3 = true;
              if (uu____3)
              {
                uu____5 = pb_curr;
                uu____7 = pb_src;
                uu____6 = Eurydice_slice_len(uu____7, uint8_t);
                uu____4 = uu____5 == uu____6;
                EURYDICE_ASSERT(uu____4, "panic!");
              }
              return symcrust_common_Error_NoError;
            }
            uu____0 = sc_error;
          }
        }
      }
      else
      {
        uu____0 = symcrust_common_Error_MemoryAllocationFailure;
      }
    }
    else
    {
      uint16_t uu____15[4U][256U];
      KRML_MAYBE_FOR4(i,
        (size_t)0U,
        (size_t)4U,
        (size_t)1U,
        memcpy(uu____15[i], symcrust_key_POLYELEMENT_ZERO, (size_t)256U * sizeof (uint16_t)););
      uint16_t uu____16[4U][256U];
      KRML_MAYBE_FOR4(i,
        (size_t)0U,
        (size_t)4U,
        (size_t)1U,
        memcpy(uu____16[i], symcrust_key_POLYELEMENT_ZERO, (size_t)256U * sizeof (uint16_t)););
      symcrust_ntt_InternalComputationTemporaries lit;
      memcpy(lit.ab_vector_buffer0, uu____15, (size_t)4U * sizeof (uint16_t [256U]));
      memcpy(lit.ab_vector_buffer1, uu____16, (size_t)4U * sizeof (uint16_t [256U]));
      memcpy(lit.ab_poly_element_buffer0,
        symcrust_key_POLYELEMENT_ZERO,
        (size_t)256U * sizeof (uint16_t));
      memcpy(lit.ab_poly_element_buffer1,
        symcrust_key_POLYELEMENT_ZERO,
        (size_t)256U * sizeof (uint16_t));
      uint32_t repeat_expression[256U] = { 0U };
      memcpy(lit.ab_poly_element_accumulator_buffer,
        repeat_expression,
        (size_t)256U * sizeof (uint32_t));
      lit.hash_state0 = symcrust_hash_UNINITIALIZED_HASH_STATE;
      lit.hash_state1 = symcrust_hash_UNINITIALIZED_HASH_STATE;
      core_result_Result_80
      p_comp_temps =
        alloc_boxed__alloc__boxed__Box_T___try_new(lit,
          symcrust_ntt_InternalComputationTemporaries,
          core_result_Result_80);
      if (p_comp_temps.tag == core_result_Ok)
      {
        symcrust_ntt_InternalComputationTemporaries *p_comp_temps0 = p_comp_temps.f0;
        symcrust_ntt_InternalComputationTemporaries *p_comp_temps1 = p_comp_temps0;
        bool uu____17;
        bool uu____18;
        size_t uu____19;
        size_t uu____20;
        Eurydice_slice uu____21;
        if (format == symcrust_key_Format_PrivateSeed)
        {
          if (!(Eurydice_slice_len(pb_src, uint8_t) != SYMCRUST_MLKEM_SIZEOF_FORMAT_PRIVATE_SEED))
          {
            pk_mlkem_key.ptr->has_private_seed = true;
            size_t
            l =
              Eurydice_slice_len(Eurydice_array_to_slice((size_t)32U,
                  pk_mlkem_key.ptr->private_seed,
                  uint8_t),
                uint8_t);
            Eurydice_slice_copy(Eurydice_array_to_slice((size_t)32U,
                pk_mlkem_key.ptr->private_seed,
                uint8_t),
              Eurydice_slice_subslice2(pb_src, (size_t)0U, l, uint8_t),
              uint8_t);
            pb_curr = pb_curr + l;
            pk_mlkem_key.ptr->has_private_key = true;
            size_t
            l0 =
              Eurydice_slice_len(Eurydice_array_to_slice((size_t)32U,
                  pk_mlkem_key.ptr->private_random,
                  uint8_t),
                uint8_t);
            Eurydice_slice_copy(Eurydice_array_to_slice((size_t)32U,
                pk_mlkem_key.ptr->private_random,
                uint8_t),
              Eurydice_slice_subslice2(pb_src, pb_curr, pb_curr + l0, uint8_t),
              uint8_t);
            pb_curr = pb_curr + l0;
            symcrust_mlkem_key_expand_from_private_seed(pk_mlkem_key, p_comp_temps1);
            uu____17 = true;
            if (uu____17)
            {
              uu____19 = pb_curr;
              uu____21 = pb_src;
              uu____20 = Eurydice_slice_len(uu____21, uint8_t);
              uu____18 = uu____19 == uu____20;
              EURYDICE_ASSERT(uu____18, "panic!");
            }
            return symcrust_common_Error_NoError;
          }
          uu____0 = symcrust_common_Error_WrongKeySize;
        }
        else if (format == symcrust_key_Format_DecapsulationKey)
        {
          size_t uu____22 = Eurydice_slice_len(pb_src, uint8_t);
          if (uu____22 != symcrust_mlkem_sizeof_format_decapsulation_key((size_t)n_rows))
          {
            uu____0 = symcrust_common_Error_WrongKeySize;
          }
          else
          {
            Eurydice_slice
            uu____23 =
              Eurydice_slice_subslice2(pb_src,
                pb_curr,
                pb_curr + cb_encoded_vector,
                uint8_t);
            symcrust_common_Error
            sc_error =
              vector_decode_and_decompress(uu____23,
                12U,
                symcrust_key_s_mut_fd(pk_mlkem_key));
            /* original Rust expression is not an lvalue in C */
            symcrust_common_Error lvalue0 = symcrust_common_Error_NoError;
            if
            (
              symcrust_common___core__cmp__PartialEq_symcrust__common__Error__for_symcrust__common__Error__1__ne(&sc_error,
                &lvalue0)
            )
            {
              uu____0 = sc_error;
            }
            else
            {
              pb_curr = pb_curr + cb_encoded_vector;
              Eurydice_slice
              uu____24 =
                Eurydice_array_to_subslice2(pk_mlkem_key.ptr->encoded_t,
                  (size_t)0U,
                  cb_encoded_vector,
                  uint8_t);
              Eurydice_slice_copy(uu____24,
                Eurydice_slice_subslice2(pb_src, pb_curr, pb_curr + cb_encoded_vector, uint8_t),
                uint8_t);
              pb_curr = pb_curr + cb_encoded_vector;
              tuple_48 uu____25 = symcrust_key_t_encoded_t_mut_fd(pk_mlkem_key);
              Eurydice_slice t = uu____25.fst;
              uint8_t *encoded_t = uu____25.snd;
              symcrust_common_Error
              sc_error0 =
                vector_decode_and_decompress(Eurydice_array_to_subslice2(encoded_t,
                    (size_t)0U,
                    cb_encoded_vector,
                    uint8_t),
                  12U,
                  t);
              /* original Rust expression is not an lvalue in C */
              symcrust_common_Error lvalue = symcrust_common_Error_NoError;
              if
              (
                !symcrust_common___core__cmp__PartialEq_symcrust__common__Error__for_symcrust__common__Error__1__ne(&sc_error0,
                  &lvalue)
              )
              {
                size_t
                l =
                  Eurydice_slice_len(Eurydice_array_to_slice((size_t)32U,
                      pk_mlkem_key.ptr->public_seed,
                      uint8_t),
                    uint8_t);
                Eurydice_slice_copy(Eurydice_array_to_slice((size_t)32U,
                    pk_mlkem_key.ptr->public_seed,
                    uint8_t),
                  Eurydice_slice_subslice2(pb_src, pb_curr, pb_curr + l, uint8_t),
                  uint8_t);
                pb_curr =
                  pb_curr +
                    Eurydice_slice_len(Eurydice_array_to_slice((size_t)32U,
                        pk_mlkem_key.ptr->public_seed,
                        uint8_t),
                      uint8_t);
                symcrust_mlkem_key_expand_public_matrix_from_public_seed(pk_mlkem_key,
                  p_comp_temps1);
                matrix_transpose(symcrust_key_atranspose_mut_fd(pk_mlkem_key), n_rows);
                size_t
                l0 =
                  Eurydice_slice_len(Eurydice_array_to_slice((size_t)32U,
                      pk_mlkem_key.ptr->encaps_key_hash,
                      uint8_t),
                    uint8_t);
                Eurydice_slice_copy(Eurydice_array_to_slice((size_t)32U,
                    pk_mlkem_key.ptr->encaps_key_hash,
                    uint8_t),
                  Eurydice_slice_subslice2(pb_src, pb_curr, pb_curr + l0, uint8_t),
                  uint8_t);
                pb_curr =
                  pb_curr +
                    Eurydice_slice_len(Eurydice_array_to_slice((size_t)32U,
                        pk_mlkem_key.ptr->encaps_key_hash,
                        uint8_t),
                      uint8_t);
                size_t
                l1 =
                  Eurydice_slice_len(Eurydice_array_to_slice((size_t)32U,
                      pk_mlkem_key.ptr->private_random,
                      uint8_t),
                    uint8_t);
                Eurydice_slice_copy(Eurydice_array_to_slice((size_t)32U,
                    pk_mlkem_key.ptr->private_random,
                    uint8_t),
                  Eurydice_slice_subslice2(pb_src, pb_curr, pb_curr + l1, uint8_t),
                  uint8_t);
                pb_curr =
                  pb_curr +
                    Eurydice_slice_len(Eurydice_array_to_slice((size_t)32U,
                        pk_mlkem_key.ptr->private_random,
                        uint8_t),
                      uint8_t);
                pk_mlkem_key.ptr->has_private_seed = false;
                pk_mlkem_key.ptr->has_private_key = true;
                uu____17 = true;
                if (uu____17)
                {
                  uu____19 = pb_curr;
                  uu____21 = pb_src;
                  uu____20 = Eurydice_slice_len(uu____21, uint8_t);
                  uu____18 = uu____19 == uu____20;
                  EURYDICE_ASSERT(uu____18, "panic!");
                }
                return symcrust_common_Error_NoError;
              }
              uu____0 = sc_error0;
            }
          }
        }
        else
        {
          size_t uu____26 = Eurydice_slice_len(pb_src, uint8_t);
          if (uu____26 != symcrust_mlkem_sizeof_format_encapsulation_key((size_t)n_rows))
          {
            uu____0 = symcrust_common_Error_WrongKeySize;
          }
          else
          {
            Eurydice_slice
            uu____27 =
              Eurydice_array_to_subslice2(pk_mlkem_key.ptr->encoded_t,
                (size_t)0U,
                cb_encoded_vector,
                uint8_t);
            Eurydice_slice_copy(uu____27,
              Eurydice_slice_subslice2(pb_src, pb_curr, pb_curr + cb_encoded_vector, uint8_t),
              uint8_t);
            pb_curr = pb_curr + cb_encoded_vector;
            tuple_48 uu____28 = symcrust_key_t_encoded_t_mut_fd(pk_mlkem_key);
            Eurydice_slice t = uu____28.fst;
            uint8_t *encoded_t = uu____28.snd;
            symcrust_common_Error
            sc_error =
              vector_decode_and_decompress(Eurydice_array_to_subslice2(encoded_t,
                  (size_t)0U,
                  cb_encoded_vector,
                  uint8_t),
                12U,
                t);
            /* original Rust expression is not an lvalue in C */
            symcrust_common_Error lvalue = symcrust_common_Error_NoError;
            if
            (
              !symcrust_common___core__cmp__PartialEq_symcrust__common__Error__for_symcrust__common__Error__1__ne(&sc_error,
                &lvalue)
            )
            {
              size_t
              l =
                Eurydice_slice_len(Eurydice_array_to_slice((size_t)32U,
                    pk_mlkem_key.ptr->public_seed,
                    uint8_t),
                  uint8_t);
              Eurydice_slice_copy(Eurydice_array_to_slice((size_t)32U,
                  pk_mlkem_key.ptr->public_seed,
                  uint8_t),
                Eurydice_slice_subslice2(pb_src, pb_curr, pb_curr + l, uint8_t),
                uint8_t);
              pb_curr =
                pb_curr +
                  Eurydice_slice_len(Eurydice_array_to_slice((size_t)32U,
                      pk_mlkem_key.ptr->public_seed,
                      uint8_t),
                    uint8_t);
              symcrust_mlkem_key_expand_public_matrix_from_public_seed(pk_mlkem_key, p_comp_temps1);
              matrix_transpose(symcrust_key_atranspose_mut_fd(pk_mlkem_key), n_rows);
              symcrust_mlkem_key_compute_encapsulation_key_hash(pk_mlkem_key, p_comp_temps1);
              pk_mlkem_key.ptr->has_private_seed = false;
              pk_mlkem_key.ptr->has_private_key = false;
              uu____17 = true;
              if (uu____17)
              {
                uu____19 = pb_curr;
                uu____21 = pb_src;
                uu____20 = Eurydice_slice_len(uu____21, uint8_t);
                uu____18 = uu____19 == uu____20;
                EURYDICE_ASSERT(uu____18, "panic!");
              }
              return symcrust_common_Error_NoError;
            }
            uu____0 = sc_error;
          }
        }
      }
      else
      {
        uu____0 = symcrust_common_Error_MemoryAllocationFailure;
      }
    }
  }
  return uu____0;
}

symcrust_common_Error symcrust_mlkem_key_generate(Eurydice_dst_8c pk_mlkem_key, uint32_t flags)
{
  /* ERROR sc_error = NO_ERROR; */
  uint8_t private_seed[64U] = { 0U };
  uint32_t
  allowed_flags = /* Ensure only allowed flags are specified */ SYMCRUST_MLKEM_FLAG_KEY_NO_FIPS ;
  symcrust_common_Error uu____0;
  if ((flags & ~allowed_flags) != 0U)
  {
    uu____0 = symcrust_common_Error_InvalidArgument;
  }
  else
  {
    symcrust_common_Error
    sc_error = symcrust_common_random(Eurydice_array_to_slice((size_t)64U, private_seed, uint8_t));
    /* original Rust expression is not an lvalue in C */
    symcrust_common_Error lvalue0 = symcrust_common_Error_NoError;
    if
    (
      symcrust_common___core__cmp__PartialEq_symcrust__common__Error__for_symcrust__common__Error__1__ne(&sc_error,
        &lvalue0)
    )
    {
      uu____0 = sc_error;
    }
    else
    {
      symcrust_common_Error
      sc_error0 =
        symcrust_mlkem_key_set_value(Eurydice_array_to_slice((size_t)64U, private_seed, uint8_t),
          symcrust_key_Format_PrivateSeed,
          flags,
          pk_mlkem_key);
      /* original Rust expression is not an lvalue in C */
      symcrust_common_Error lvalue = symcrust_common_Error_NoError;
      if
      (
        !symcrust_common___core__cmp__PartialEq_symcrust__common__Error__for_symcrust__common__Error__1__ne(&sc_error0,
          &lvalue)
      )
      {
        return symcrust_common_Error_NoError;
      }
      uu____0 = sc_error0;
    }
  }
  return uu____0;
}

symcrust_common_Error
symcrust_mlkem_key_get_value(
  Eurydice_dst_8c pk_mlkem_key,
  Eurydice_slice pb_dst,
  symcrust_key_Format format,
  uint32_t _flags
)
{
  /* SIZE_T cb_dst, ERROR sc_error = NO_ERROR; */
  size_t pb_curr = (size_t)0U;
  uint8_t n_rows = pk_mlkem_key.ptr->params.n_rows;
  size_t cb_encoded_vector = symcrust_mlkem_sizeof_encoded_uncompressed_vector((size_t)n_rows);
  symcrust_common_Error uu____0;
  bool uu____1;
  bool uu____2;
  size_t uu____3;
  size_t uu____4;
  Eurydice_slice uu____5;
  /* if( mlKemkeyFormat == crate::key::Format_NULL ) { sc_error = INVALID_ARGUMENT; goto cleanup; } */
  if (format == symcrust_key_Format_PrivateSeed)
  {
    if (Eurydice_slice_len(pb_dst, uint8_t) != SYMCRUST_MLKEM_SIZEOF_FORMAT_PRIVATE_SEED)
    {
      uu____0 = symcrust_common_Error_WrongKeySize;
    }
    else if (pk_mlkem_key.ptr->has_private_seed)
    {
      Eurydice_slice uu____6 = pb_dst;
      size_t uu____7 = pb_curr;
      size_t uu____8 = pb_curr;
      size_t
      uu____9 =
        Eurydice_slice_len(Eurydice_array_to_slice((size_t)32U,
            pk_mlkem_key.ptr->private_seed,
            uint8_t),
          uint8_t);
      Eurydice_slice_copy(Eurydice_slice_subslice2(uu____6, uu____7, uu____8 + uu____9, uint8_t),
        Eurydice_array_to_slice((size_t)32U, pk_mlkem_key.ptr->private_seed, uint8_t),
        uint8_t);
      pb_curr =
        pb_curr +
          Eurydice_slice_len(Eurydice_array_to_slice((size_t)32U,
              pk_mlkem_key.ptr->private_seed,
              uint8_t),
            uint8_t);
      Eurydice_slice uu____10 = pb_dst;
      size_t uu____11 = pb_curr;
      size_t uu____12 = pb_curr;
      size_t
      uu____13 =
        Eurydice_slice_len(Eurydice_array_to_slice((size_t)32U,
            pk_mlkem_key.ptr->private_random,
            uint8_t),
          uint8_t);
      Eurydice_slice_copy(Eurydice_slice_subslice2(uu____10, uu____11, uu____12 + uu____13, uint8_t),
        Eurydice_array_to_slice((size_t)32U, pk_mlkem_key.ptr->private_random, uint8_t),
        uint8_t);
      pb_curr =
        pb_curr +
          Eurydice_slice_len(Eurydice_array_to_slice((size_t)32U,
              pk_mlkem_key.ptr->private_random,
              uint8_t),
            uint8_t);
      uu____1 = true;
      if (uu____1)
      {
        uu____3 = pb_curr;
        uu____5 = pb_dst;
        uu____4 = Eurydice_slice_len(uu____5, uint8_t);
        uu____2 = uu____3 == uu____4;
        EURYDICE_ASSERT(uu____2, "panic!");
      }
      return symcrust_common_Error_NoError;
    }
    else
    {
      uu____0 = symcrust_common_Error_IncompatibleFormat;
    }
  }
  else if (format == symcrust_key_Format_DecapsulationKey)
  {
    size_t uu____14 = Eurydice_slice_len(pb_dst, uint8_t);
    if (uu____14 != symcrust_mlkem_sizeof_format_decapsulation_key((size_t)n_rows))
    {
      uu____0 = symcrust_common_Error_InvalidArgument;
    }
    else if (pk_mlkem_key.ptr->has_private_key)
    {
      Eurydice_slice uu____15 = symcrust_key_s_fd(pk_mlkem_key);
      vector_compress_and_encode(uu____15,
        12U,
        Eurydice_slice_subslice2(pb_dst, (size_t)0U, cb_encoded_vector, uint8_t));
      pb_curr = pb_curr + cb_encoded_vector;
      Eurydice_slice
      uu____16 = Eurydice_slice_subslice2(pb_dst, pb_curr, pb_curr + cb_encoded_vector, uint8_t);
      Eurydice_slice_copy(uu____16,
        Eurydice_array_to_subslice2(pk_mlkem_key.ptr->encoded_t,
          (size_t)0U,
          cb_encoded_vector,
          uint8_t),
        uint8_t);
      pb_curr = pb_curr + cb_encoded_vector;
      Eurydice_slice uu____17 = pb_dst;
      size_t uu____18 = pb_curr;
      size_t uu____19 = pb_curr;
      size_t
      uu____20 =
        Eurydice_slice_len(Eurydice_array_to_slice((size_t)32U,
            pk_mlkem_key.ptr->public_seed,
            uint8_t),
          uint8_t);
      Eurydice_slice_copy(Eurydice_slice_subslice2(uu____17, uu____18, uu____19 + uu____20, uint8_t),
        Eurydice_array_to_slice((size_t)32U, pk_mlkem_key.ptr->public_seed, uint8_t),
        uint8_t);
      pb_curr =
        pb_curr +
          Eurydice_slice_len(Eurydice_array_to_slice((size_t)32U,
              pk_mlkem_key.ptr->public_seed,
              uint8_t),
            uint8_t);
      Eurydice_slice uu____21 = pb_dst;
      size_t uu____22 = pb_curr;
      size_t uu____23 = pb_curr;
      size_t
      uu____24 =
        Eurydice_slice_len(Eurydice_array_to_slice((size_t)32U,
            pk_mlkem_key.ptr->encaps_key_hash,
            uint8_t),
          uint8_t);
      Eurydice_slice_copy(Eurydice_slice_subslice2(uu____21, uu____22, uu____23 + uu____24, uint8_t),
        Eurydice_array_to_slice((size_t)32U, pk_mlkem_key.ptr->encaps_key_hash, uint8_t),
        uint8_t);
      pb_curr =
        pb_curr +
          Eurydice_slice_len(Eurydice_array_to_slice((size_t)32U,
              pk_mlkem_key.ptr->encaps_key_hash,
              uint8_t),
            uint8_t);
      Eurydice_slice uu____25 = pb_dst;
      size_t uu____26 = pb_curr;
      size_t uu____27 = pb_curr;
      size_t
      uu____28 =
        Eurydice_slice_len(Eurydice_array_to_slice((size_t)32U,
            pk_mlkem_key.ptr->private_random,
            uint8_t),
          uint8_t);
      Eurydice_slice_copy(Eurydice_slice_subslice2(uu____25, uu____26, uu____27 + uu____28, uint8_t),
        Eurydice_array_to_slice((size_t)32U, pk_mlkem_key.ptr->private_random, uint8_t),
        uint8_t);
      pb_curr =
        pb_curr +
          Eurydice_slice_len(Eurydice_array_to_slice((size_t)32U,
              pk_mlkem_key.ptr->private_random,
              uint8_t),
            uint8_t);
      uu____1 = true;
      if (uu____1)
      {
        uu____3 = pb_curr;
        uu____5 = pb_dst;
        uu____4 = Eurydice_slice_len(uu____5, uint8_t);
        uu____2 = uu____3 == uu____4;
        EURYDICE_ASSERT(uu____2, "panic!");
      }
      return symcrust_common_Error_NoError;
    }
    else
    {
      uu____0 = symcrust_common_Error_InvalidArgument;
    }
  }
  else
  {
    size_t uu____29 = Eurydice_slice_len(pb_dst, uint8_t);
    if (!(uu____29 != symcrust_mlkem_sizeof_format_encapsulation_key((size_t)n_rows)))
    {
      Eurydice_slice
      uu____30 = Eurydice_slice_subslice2(pb_dst, pb_curr, pb_curr + cb_encoded_vector, uint8_t);
      Eurydice_slice_copy(uu____30,
        Eurydice_array_to_subslice2(pk_mlkem_key.ptr->encoded_t,
          (size_t)0U,
          cb_encoded_vector,
          uint8_t),
        uint8_t);
      pb_curr = pb_curr + cb_encoded_vector;
      Eurydice_slice uu____31 = pb_dst;
      size_t uu____32 = pb_curr;
      size_t uu____33 = pb_curr;
      size_t
      uu____34 =
        Eurydice_slice_len(Eurydice_array_to_slice((size_t)32U,
            pk_mlkem_key.ptr->public_seed,
            uint8_t),
          uint8_t);
      Eurydice_slice_copy(Eurydice_slice_subslice2(uu____31, uu____32, uu____33 + uu____34, uint8_t),
        Eurydice_array_to_slice((size_t)32U, pk_mlkem_key.ptr->public_seed, uint8_t),
        uint8_t);
      pb_curr =
        pb_curr +
          Eurydice_slice_len(Eurydice_array_to_slice((size_t)32U,
              pk_mlkem_key.ptr->public_seed,
              uint8_t),
            uint8_t);
      uu____1 = true;
      if (uu____1)
      {
        uu____3 = pb_curr;
        uu____5 = pb_dst;
        uu____4 = Eurydice_slice_len(uu____5, uint8_t);
        uu____2 = uu____3 == uu____4;
        EURYDICE_ASSERT(uu____2, "panic!");
      }
      return symcrust_common_Error_NoError;
    }
    uu____0 = symcrust_common_Error_InvalidArgument;
  }
  return uu____0;
}

size_t symcrust_mlkem_sizeof_ciphertext_from_params(symcrust_key_Params params)
{
  symcrust_key_InternalParams
  internal_params = symcrust_key_get_internal_params_from_params(params);
  size_t
  cb_u =
    (size_t)/* u vector encoded with n_bits_of_u * MLWE_POLYNOMIAL_COEFFICIENTS bits per polynomial */
      internal_params.n_rows

    * (size_t)internal_params.n_bits_of_u
    * (SYMCRUST_KEY_MLWE_POLYNOMIAL_COEFFICIENTS / (size_t)8U);
  size_t
  cb_v =
    (size_t)/* v polynomial encoded with n_bits_of_v * MLWE_POLYNOMIAL_COEFFICIENTS bits */
      internal_params.n_bits_of_v

    * (SYMCRUST_KEY_MLWE_POLYNOMIAL_COEFFICIENTS / (size_t)8U);
  /* original Rust expression is not an lvalue in C */
  symcrust_key_Params lvalue = symcrust_key_Params_MlKem512;
  if
  (
    !symcrust_key___core__cmp__PartialEq_symcrust__key__Params__for_symcrust__key__Params__2__ne(&internal_params.params,
      &lvalue)
  )
  {
    EURYDICE_ASSERT(cb_u + cb_v == SYMCRUST_MLKEM_CIPHERTEXT_SIZE_MLKEM512, "panic!");
  }
  /* original Rust expression is not an lvalue in C */
  symcrust_key_Params lvalue0 = symcrust_key_Params_MlKem768;
  if
  (
    !symcrust_key___core__cmp__PartialEq_symcrust__key__Params__for_symcrust__key__Params__2__ne(&internal_params.params,
      &lvalue0)
  )
  {
    EURYDICE_ASSERT(cb_u + cb_v == SYMCRUST_MLKEM_CIPHERTEXT_SIZE_MLKEM768, "panic!");
  }
  /* original Rust expression is not an lvalue in C */
  symcrust_key_Params lvalue1 = symcrust_key_Params_MlKem1024;
  if
  (
    !symcrust_key___core__cmp__PartialEq_symcrust__key__Params__for_symcrust__key__Params__2__ne(&internal_params.params,
      &lvalue1)
  )
  {
    EURYDICE_ASSERT(cb_u + cb_v == SYMCRUST_MLKEM_CIPHERTEXT_SIZE_MLKEM1024, "panic!");
  }
  return cb_u + cb_v;
}

size_t
symcrust_mlkem_sizeof_key_format_from_params(
  symcrust_key_Params params,
  symcrust_key_Format format
)
{
  symcrust_key_InternalParams
  internal_params = symcrust_key_get_internal_params_from_params(params);
  size_t uu____0;
  if (format == symcrust_key_Format_PrivateSeed)
  {
    uu____0 = SYMCRUST_MLKEM_SIZEOF_FORMAT_PRIVATE_SEED;
  }
  else if (format == symcrust_key_Format_DecapsulationKey)
  {
    uu____0 = symcrust_mlkem_sizeof_format_decapsulation_key((size_t)internal_params.n_rows);
  }
  else
  {
    uu____0 = symcrust_mlkem_sizeof_format_encapsulation_key((size_t)internal_params.n_rows);
  }
  return uu____0;
}

