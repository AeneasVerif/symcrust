/* 
  This file was generated by KaRaMeL <https://github.com/FStarLang/karamel>
  KaRaMeL invocation: /Users/jonathan/Code/eurydice/eurydice symcrust.llbc --output c/ -fcomments --config c.yaml
  F* version: <unknown>
  KaRaMeL version: 2e1ab5b9
 */

#include "internal/symcrust_ffi.h"

#include "symcrust_mlkem.h"
#include "symcrust_common.h"
#include "internal/symcrust_mlkem.h"
#include "internal/symcrust_common.h"

void symcrust_ffi_SctestModuleInit(void)
{
  symcrust_common_init();
}

void symcrust_ffi_SctestWipe(uint8_t *pb_data, size_t cb_data)
{
  symcrust_common_wipe(pb_data, cb_data);
}

symcrust_common_Error
symcrust_ffi_SymCryptMlKemDecapsulate(
  Eurydice_dst_8c *k,
  uint8_t *pb_ciphertext,
  size_t cb_ciphertext,
  uint8_t *pb_agreed_secret,
  size_t cb_agreed_secret
)
{
  Eurydice_dst_8c
  *k0 = alloc_boxed__alloc__boxed__Box_T___from_raw(k, Eurydice_dst_8c, Eurydice_dst_8c *);
  Eurydice_slice
  agreed_secret =
    core_slice_raw_from_raw_parts_mut(pb_agreed_secret,
      cb_agreed_secret,
      uint8_t,
      Eurydice_slice);
  Eurydice_slice
  ciphertext =
    core_slice_raw_from_raw_parts(pb_ciphertext,
      cb_ciphertext,
      uint8_t,
      Eurydice_slice);
  symcrust_common_Error r = symcrust_mlkem_decapsulate(k0[0U], ciphertext, agreed_secret);
  /* Note: we probably (check) need this to prevent Drop from being called. */
  alloc_boxed__alloc__boxed__Box_T___into_raw(k0, Eurydice_dst_8c, Eurydice_dst_8c *);
  return r;
}

symcrust_common_Error
symcrust_ffi_SymCryptMlKemEncapsulate(
  Eurydice_dst_8c *k,
  uint8_t *pb_agreed_secret,
  size_t cb_agreed_secret,
  uint8_t *pb_ciphertext,
  size_t cb_ciphertext
)
{
  Eurydice_dst_8c
  *k0 = alloc_boxed__alloc__boxed__Box_T___from_raw(k, Eurydice_dst_8c, Eurydice_dst_8c *);
  Eurydice_slice
  agreed_secret =
    core_slice_raw_from_raw_parts_mut(pb_agreed_secret,
      cb_agreed_secret,
      uint8_t,
      Eurydice_slice);
  Eurydice_slice
  ciphertext =
    core_slice_raw_from_raw_parts_mut(pb_ciphertext,
      cb_ciphertext,
      uint8_t,
      Eurydice_slice);
  symcrust_common_Error r = symcrust_mlkem_encapsulate(k0[0U], agreed_secret, ciphertext);
  /* Note: we probably (check) need this to prevent Drop from being called. */
  alloc_boxed__alloc__boxed__Box_T___into_raw(k0, Eurydice_dst_8c, Eurydice_dst_8c *);
  return r;
}

symcrust_common_Error
symcrust_ffi_SymCryptMlKemEncapsulateEx(
  Eurydice_dst_8c *k,
  uint8_t *pb_random,
  size_t cb_random,
  uint8_t *pb_agreed_secret,
  size_t cb_agreed_secret,
  uint8_t *pb_ciphertext,
  size_t cb_ciphertext
)
{
  Eurydice_dst_8c
  *k0 = alloc_boxed__alloc__boxed__Box_T___from_raw(k, Eurydice_dst_8c, Eurydice_dst_8c *);
  Eurydice_slice
  random = core_slice_raw_from_raw_parts_mut(pb_random, cb_random, uint8_t, Eurydice_slice);
  Eurydice_slice
  agreed_secret =
    core_slice_raw_from_raw_parts_mut(pb_agreed_secret,
      cb_agreed_secret,
      uint8_t,
      Eurydice_slice);
  Eurydice_slice
  ciphertext =
    core_slice_raw_from_raw_parts_mut(pb_ciphertext,
      cb_ciphertext,
      uint8_t,
      Eurydice_slice);
  symcrust_common_Error
  r = symcrust_mlkem_encapsulate_ex(k0[0U], random, agreed_secret, ciphertext);
  /* Note: we probably (check) need this to prevent Drop from being called. */
  alloc_boxed__alloc__boxed__Box_T___into_raw(k0, Eurydice_dst_8c, Eurydice_dst_8c *);
  return r;
}

/**
This function found in impl {core::fmt::Arguments<'a>}
*/
/**
A monomorphic instance of core.fmt.rt.new_const_21
with const generics
- N= 1
*/
inline core_fmt_Arguments core_fmt_rt_new_const_21_74(Eurydice_str *pieces)
{
  core_fmt_rt_ArgumentType uu____0[0U] = {  };
  return
    (
      KRML_CLITERAL(core_fmt_Arguments){
        .pieces = Eurydice_array_to_slice((size_t)1U, pieces, Eurydice_str),
        .fmt = { .tag = core_option_None },
        .args = Eurydice_array_to_slice((size_t)0U, uu____0, core_fmt_rt_ArgumentType)
      }
    );
}

void symcrust_ffi_SymCryptMlKemSelftest(void)
{
  Eurydice_str
  buf[1U] =
    { (KRML_CLITERAL(Eurydice_str){ .data = "SELF-TEST: DOING NOTHING\\n", .len = (size_t)25U }) };
  std_io_stdio__print(core_fmt_rt_new_const_21_74(buf));
}

/**
This function found in impl {core::convert::TryFrom<i32, symcrust::common::Error> for symcrust::key::Params}
*/
core_result_Result_fa symcrust_ffi_try_from_1e(int32_t params)
{
  switch (params)
  {
    case 0:
      {
        break;
      }
    case 1:
      {
        return
          (
            KRML_CLITERAL(core_result_Result_fa){
              .tag = core_result_Ok,
              .val = { .case_Ok = symcrust_key_Params_MlKem512 }
            }
          );
      }
    case 2:
      {
        return
          (
            KRML_CLITERAL(core_result_Result_fa){
              .tag = core_result_Ok,
              .val = { .case_Ok = symcrust_key_Params_MlKem768 }
            }
          );
      }
    case 3:
      {
        return
          (
            KRML_CLITERAL(core_result_Result_fa){
              .tag = core_result_Ok,
              .val = { .case_Ok = symcrust_key_Params_MlKem1024 }
            }
          );
      }
    default:
      {
        return
          (
            KRML_CLITERAL(core_result_Result_fa){
              .tag = core_result_Err,
              .val = { .case_Err = symcrust_common_Error_InvalidArgument }
            }
          );
      }
  }
  return
    (
      KRML_CLITERAL(core_result_Result_fa){
        .tag = core_result_Err,
        .val = { .case_Err = symcrust_common_Error_IncompatibleFormat }
      }
    );
}

#define Continue 0
#define Break 1

typedef uint8_t ControlFlow_b8_tags;

/**
A monomorphic instance of core.ops.control_flow.ControlFlow
with types core_result_Result core_convert_Infallible symcrust_common_Error, symcrust_key_Params

*/
typedef struct ControlFlow_b8_s
{
  ControlFlow_b8_tags tag;
  union {
    symcrust_key_Params case_Continue;
    core_result_Result_b5 case_Break;
  }
  val;
}
ControlFlow_b8;

/**
This function found in impl {core::ops::try_trait::Try<T, core::result::Result<core::convert::Infallible, E>> for core::result::Result<T, E>}
*/
/**
A monomorphic instance of core.result.branch_01
with types symcrust_key_Params, symcrust_common_Error

*/
static inline ControlFlow_b8 branch_01_a1(core_result_Result_fa self)
{
  if (!(self.tag == core_result_Ok))
  {
    symcrust_common_Error e = self.val.case_Err;
    return
      (
        KRML_CLITERAL(ControlFlow_b8){
          .tag = Break,
          .val = { .case_Break = { .tag = core_result_Err, .val = { .case_Err = e } } }
        }
      );
  }
  symcrust_key_Params v = self.val.case_Ok;
  return (KRML_CLITERAL(ControlFlow_b8){ .tag = Continue, .val = { .case_Continue = v } });
}

symcrust_common_Error
symcrust_ffi_SymCryptMlKemSizeofCiphertextFromParams(int32_t params, size_t *sz)
{
  ControlFlow_b8 uu____0 = branch_01_a1(core_convert_try_into_32_0a(params));
  if (!(uu____0.tag == Continue))
  {
    core_result_Result_b5 residual = uu____0.val.case_Break;
    return symcrust_error_from_residual_54(residual);
  }
  symcrust_key_Params val = uu____0.val.case_Continue;
  sz[0U] = symcrust_mlkem_sizeof_ciphertext_from_params(val);
  return symcrust_common_Error_NoError;
}

/**
This function found in impl {core::convert::TryFrom<i32, symcrust::common::Error> for symcrust::key::Format}
*/
core_result_Result_e8 symcrust_ffi_try_from_2a(int32_t format)
{
  switch (format)
  {
    case 0:
      {
        break;
      }
    case 1:
      {
        return
          (
            KRML_CLITERAL(core_result_Result_e8){
              .tag = core_result_Ok,
              .val = { .case_Ok = symcrust_key_Format_PrivateSeed }
            }
          );
      }
    case 2:
      {
        return
          (
            KRML_CLITERAL(core_result_Result_e8){
              .tag = core_result_Ok,
              .val = { .case_Ok = symcrust_key_Format_DecapsulationKey }
            }
          );
      }
    case 3:
      {
        return
          (
            KRML_CLITERAL(core_result_Result_e8){
              .tag = core_result_Ok,
              .val = { .case_Ok = symcrust_key_Format_EncapsulationKey }
            }
          );
      }
    default:
      {
        return
          (
            KRML_CLITERAL(core_result_Result_e8){
              .tag = core_result_Err,
              .val = { .case_Err = symcrust_common_Error_InvalidArgument }
            }
          );
      }
  }
  return
    (
      KRML_CLITERAL(core_result_Result_e8){
        .tag = core_result_Err,
        .val = { .case_Err = symcrust_common_Error_IncompatibleFormat }
      }
    );
}

/**
A monomorphic instance of core.ops.control_flow.ControlFlow
with types core_result_Result core_convert_Infallible symcrust_common_Error, symcrust_key_Format

*/
typedef struct ControlFlow_a9_s
{
  ControlFlow_b8_tags tag;
  union {
    symcrust_key_Format case_Continue;
    core_result_Result_b5 case_Break;
  }
  val;
}
ControlFlow_a9;

/**
This function found in impl {core::ops::try_trait::Try<T, core::result::Result<core::convert::Infallible, E>> for core::result::Result<T, E>}
*/
/**
A monomorphic instance of core.result.branch_01
with types symcrust_key_Format, symcrust_common_Error

*/
static inline ControlFlow_a9 branch_01_a6(core_result_Result_e8 self)
{
  if (!(self.tag == core_result_Ok))
  {
    symcrust_common_Error e = self.val.case_Err;
    return
      (
        KRML_CLITERAL(ControlFlow_a9){
          .tag = Break,
          .val = { .case_Break = { .tag = core_result_Err, .val = { .case_Err = e } } }
        }
      );
  }
  symcrust_key_Format v = self.val.case_Ok;
  return (KRML_CLITERAL(ControlFlow_a9){ .tag = Continue, .val = { .case_Continue = v } });
}

symcrust_common_Error
symcrust_ffi_SymCryptMlKemSizeofKeyFormatFromParams(int32_t params, int32_t format, size_t *sz)
{
  ControlFlow_b8 uu____0 = branch_01_a1(core_convert_try_into_32_0a(params));
  symcrust_common_Error uu____1;
  if (uu____0.tag == Continue)
  {
    symcrust_key_Params val = uu____0.val.case_Continue;
    symcrust_key_Params uu____2 = val;
    ControlFlow_a9 uu____3 = branch_01_a6(core_convert_try_into_32_5e(format));
    if (uu____3.tag == Continue)
    {
      symcrust_key_Format val0 = uu____3.val.case_Continue;
      sz[0U] = symcrust_mlkem_sizeof_key_format_from_params(uu____2, val0);
      return symcrust_common_Error_NoError;
    }
    else
    {
      core_result_Result_b5 residual = uu____3.val.case_Break;
      uu____1 = symcrust_error_from_residual_54(residual);
    }
  }
  else
  {
    core_result_Result_b5 residual = uu____0.val.case_Break;
    uu____1 = symcrust_error_from_residual_54(residual);
  }
  return uu____1;
}

/**
A monomorphic instance of core.ptr.null_mut
with types Eurydice_dst symcrust_key_PreKey2 Eurydice_derefed_slice uint16_t[256size_t]

*/
static Eurydice_dst_8c *null_mut_98(void)
{
  return NULL;
}

Eurydice_dst_8c *symcrust_ffi_SymCryptMlKemkeyAllocate(int32_t params)
{
  core_result_Result_fa uu____0 = symcrust_ffi_try_from_1e(params);
  Eurydice_dst_8c *uu____1;
  if (uu____0.tag == core_result_Ok)
  {
    symcrust_key_Params params0 = uu____0.val.case_Ok;
    core_result_Result_67 uu____2 = symcrust_key_key_allocate(params0);
    if (uu____2.tag == core_result_Ok)
    {
      Eurydice_dst_8c k = uu____2.val.case_Ok;
      uu____1 =
        alloc_boxed__alloc__boxed__Box_T___into_raw(Eurydice_box_new(k,
            Eurydice_dst_8c,
            Eurydice_dst_8c *),
          Eurydice_dst_8c,
          Eurydice_dst_8c *);
    }
    else
    {
      uu____1 = null_mut_98();
    }
  }
  else
  {
    uu____1 = null_mut_98();
  }
  return uu____1;
}

void symcrust_ffi_SymCryptMlKemkeyFree(Eurydice_dst_8c *k)
{
  alloc_boxed__alloc__boxed__Box_T___from_raw(k, Eurydice_dst_8c, Eurydice_dst_8c *);
}

symcrust_common_Error symcrust_ffi_SymCryptMlKemkeyGenerate(Eurydice_dst_8c *k, uint32_t flags)
{
  Eurydice_dst_8c
  *k0 = alloc_boxed__alloc__boxed__Box_T___from_raw(k, Eurydice_dst_8c, Eurydice_dst_8c *);
  /* Note: the * can be inserted by Rust automatically */
  symcrust_common_Error r = symcrust_mlkem_key_generate(k0[0U], flags);
  /* Note: we probably (check) need this to prevent Drop from being called. */
  alloc_boxed__alloc__boxed__Box_T___into_raw(k0, Eurydice_dst_8c, Eurydice_dst_8c *);
  return r;
}

symcrust_common_Error
symcrust_ffi_SymCryptMlKemkeyGetValue(
  Eurydice_dst_8c *k,
  uint8_t *pb_dst,
  size_t cb_dst,
  int32_t format,
  uint32_t flags
)
{
  Eurydice_dst_8c
  *k0 = alloc_boxed__alloc__boxed__Box_T___from_raw(k, Eurydice_dst_8c, Eurydice_dst_8c *);
  Eurydice_slice
  dst = core_slice_raw_from_raw_parts_mut(pb_dst, cb_dst, uint8_t, Eurydice_slice);
  Eurydice_dst_8c uu____0 = k0[0U];
  Eurydice_slice uu____1 = dst;
  ControlFlow_a9 uu____2 = branch_01_a6(core_convert_try_into_32_5e(format));
  if (!(uu____2.tag == Continue))
  {
    core_result_Result_b5 residual = uu____2.val.case_Break;
    return symcrust_error_from_residual_54(residual);
  }
  symcrust_key_Format val = uu____2.val.case_Continue;
  symcrust_common_Error r = symcrust_mlkem_key_get_value(uu____0, uu____1, val, flags);
  alloc_boxed__alloc__boxed__Box_T___into_raw(k0, Eurydice_dst_8c, Eurydice_dst_8c *);
  return r;
}

symcrust_common_Error
symcrust_ffi_SymCryptMlKemkeySetValue(
  uint8_t *pb_src,
  size_t cb_src,
  int32_t format,
  uint32_t flags,
  Eurydice_dst_8c *k
)
{
  Eurydice_dst_8c
  *k0 = alloc_boxed__alloc__boxed__Box_T___from_raw(k, Eurydice_dst_8c, Eurydice_dst_8c *);
  Eurydice_slice src = core_slice_raw_from_raw_parts(pb_src, cb_src, uint8_t, Eurydice_slice);
  Eurydice_slice uu____0 = src;
  ControlFlow_a9 uu____1 = branch_01_a6(core_convert_try_into_32_5e(format));
  if (!(uu____1.tag == Continue))
  {
    core_result_Result_b5 residual = uu____1.val.case_Break;
    return symcrust_error_from_residual_54(residual);
  }
  symcrust_key_Format val = uu____1.val.case_Continue;
  symcrust_common_Error r = symcrust_mlkem_key_set_value(uu____0, val, flags, k0[0U]);
  alloc_boxed__alloc__boxed__Box_T___into_raw(k0, Eurydice_dst_8c, Eurydice_dst_8c *);
  return r;
}

