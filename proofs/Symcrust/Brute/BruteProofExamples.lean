import Symcrust.Brute.BruteLemmas

/- This file contains examples of the proof terms that `brute` is meant to generate. Nothing is intended to depend on this file,
   it is only meant to serve as documentation for the proof terms that `brute` is meant to generate. Only examples with two or more
   Nat-like quantifiers appear in this file because goal states with only a single Nat-like quantifier are handled with a single call
   to `ofMkFold1SomeLt`, `ofMkFold1SomeLe`, or `ofMkFold1None`. `sorry`s in this file are used to indiate goals whose targets
   contain no quantifiers and no free variables (and therefore can be proved via brute force computation).

   The proof terms that appear in the second half of this file were generated by cleaning up the suggestion by using `by?` on the
   tactic-style proof scripts in the first half of this file.

   The general structure of a proof for a goal with `n` universally quantified Nat-like variables is as follows:
    - The first `n-1` variables are introduced (along with any hypotheses giving upper bounds on those variables). In term proofs, this
      corresponds with establishing a function that takes in `n-1` arguments of the appropriate Nat-like types (along with arguments for
      proofs that those variables are upper bounded in the appropriate ways).

    - Based on the nature of the last Nat-like variable's upper bound (which can be `<`, `≤`, or no upper-bound), the appropriate
      lemma of `ofMkFold1None`, `ofMkFold1SomeLt`, and `ofMkFold1SomeLe` is applied.

      In this application, the arguments `f` and `f'` differ, with the former being `fun z => f [n-1 initial arguments] z` and the latter
      being `mkFold1 [something] (fun z => f [n-1 initial arguments] z) true` where `[something]` depends on the nature of the last
      quantifier's upper bound.

      This application generates two subgoals. In term proofs, these two subgoals correspond to the last two arguments passed to the lemma.

    - The first subgoal essentially boils down to a reapplication of the same lemma (`ofMkFold1None`, `ofMkFold1SomeLt`, or
      `ofMkFold1SomeLe`), but this time, both `f` and `f'` arguments are instantiated as `fun z => f [n-1 initial arguments] z`.

    - The second subgoal is addressed with an application of the lemma among `ofMkFold1None`, `ofMkFold1SomeLt`, and `ofMkFold1SomeLe`
      which coincides with the second to last Nat-like variable's upper bound. The argument `f` can be inferred from the goal,
      but is generally speaking the composition of two `mkFold1` calls with types and upper bounds corresponding to the original
      goal's last two Nat-like variables, and the argument `f'` is a single `mkFold1` call with types and upper bounds corresponding
      to the original goal's last Nat-like variable.

      This lemma application generates two subgoals. In term proofs, these two subgoals correspond to the last two arguments passed to
      the lemma.

    - The first subgoal of the previous bullet's lemma application is proven via application of `ofMkFold1Triv`.

    - The second/final subogal of the previous lemma application is proven in one of two ways:
      1.  If the subgoal already contains no free variables, then the subgoal corresponds to a computation of a composition of
          `ofMkFold1` calls. In this file, these goals are closed via `sorry`, and in the proofs `brute` generates, these goals
          are closed by application of `Lean.ofReduceBool`.
      2.  If the subgoal still has free variables (or unintroduced universally quantified Nat-like variables) then the appropriate lemma
          among `ofMkFold1None`, `ofMkFold1SomeLt`, and `ofMkFold1SomeLe` is applied. In this application, both `f` and `f'` are
          instantiated to the same value. This value is essentially the composition of `x` `mkFold1` calls where `x` is the number
          of Nat-like variables that have been processed. The second to last argument passed to this application is either
          `fun _ _ h => h` (if the currently processed binder has an upper bound of `<` or `≤`) or `fun _ h => h` (if the currently
          processed binder has no upper bound). The final argument passed to this application (or equivalently, the final subgoal
          generated by this application) is analogous to the subgoal that this lemma application was intended to prove. So the
          remainder of the proof is a sequence of `n - x - 1` applications as described in this paragraph, followed ultimately
          by the goal with no free variables that is closed via `sorry` or `Lean.ofReduceBool`. -/

open Brute

theorem bruteTacticProof2NoneNone {t1 t2 : Type} [IsNatLike t1] [IsNatLike t2] (f : t1 → t2 → Bool) :
  ∀ x : t1, ∀ y : t2, f x y := by
  intro x
  apply ofMkFold1None (f x) (fun _ => (mkFold1 none (f x) true))
  . intro y h
    apply ofMkFold1None (f x) (f x)
    . exact fun y h => h
    . exact h
  . revert x
    apply ofMkFold1None
      (fun x => mkFold1 none (fun _ => mkFold1 none (f x) true) true)
      (fun x' => (mkFold1 none (f x') true))
    . intro x
      exact ofMkFold1Triv f x none
    . sorry

theorem bruteTacticProof2LtLt {t1 t2 : Type} [IsNatLike t1] [IsNatLike t2] (b1 : t1) (b2 : t1 → t2)
  (f : t1 → t2 → Bool) :
  ∀ x < b1, ∀ y < b2 x, f x y := by
  intro x hx
  apply ofMkFold1SomeLt (b2 x) (f x) (fun _ => (mkFold1 (some (b2 x)) (f x) true))
  . intro y hy h
    apply ofMkFold1SomeLt (b2 x) (f x) (f x)
    . exact fun y hy h => h
    . exact h
    . exact hy
  . revert x hx
    apply ofMkFold1SomeLt b1 _ (fun x' => (mkFold1 (some (b2 x')) (f x') true))
    . intro x hx
      exact ofMkFold1Triv f x (some (b2 x))
    . sorry

theorem bruteTacticProof2LtLe {t1 t2 : Type} [IsNatLike t1] [IsNatLike t2] (b1 : t1) (b2 : t1 → t2)
  (f : t1 → t2 → Bool) :
  ∀ x < b1, ∀ y ≤ b2 x, f x y := by
  intro x hx
  apply ofMkFold1SomeLe (b2 x) (f x) (fun _ => (mkFold1 (natLikeSucc (b2 x)) (f x) true))
  . intro y hy h
    apply ofMkFold1SomeLe (b2 x) (f x) (f x)
    . exact fun y hy h => h
    . exact h
    . exact hy
  . revert x hx
    apply ofMkFold1SomeLt b1 _ (fun x' => (mkFold1 (natLikeSucc (b2 x')) (f x') true))
    . intro x hx
      exact ofMkFold1Triv f x (natLikeSucc (b2 x))
    . sorry

theorem bruteTacticProof2LeLt {t1 t2 : Type} [IsNatLike t1] [IsNatLike t2] (b1 : t1) (b2 : t1 → t2)
  (f : t1 → t2 → Bool) :
  ∀ x ≤ b1, ∀ y < b2 x, f x y := by
  intro x hx
  apply ofMkFold1SomeLt (b2 x) (f x) (fun _ => (mkFold1 (some (b2 x)) (f x) true))
  . intro y hy h
    apply ofMkFold1SomeLt (b2 x) (f x) (f x)
    . exact fun y hy h => h
    . exact h
    . exact hy
  . revert x hx
    apply ofMkFold1SomeLe b1 _ (fun x' => (mkFold1 (some (b2 x')) (f x') true))
    . intro x hx
      exact ofMkFold1Triv f x (some (b2 x))
    . sorry

theorem bruteTacticProof2LeLe {t1 t2 : Type} [IsNatLike t1] [IsNatLike t2] (b1 : t1) (b2 : t1 → t2)
  (f : t1 → t2 → Bool) :
  ∀ x ≤ b1, ∀ y ≤ b2 x, f x y := by
  intro x hx
  apply ofMkFold1SomeLe (b2 x) (f x) (fun _ => (mkFold1 (natLikeSucc (b2 x)) (f x) true))
  . intro y hy h
    apply ofMkFold1SomeLe (b2 x) (f x) (f x)
    . exact fun y hy h => h
    . exact h
    . exact hy
  . revert x hx
    apply ofMkFold1SomeLe b1 _ (fun x' => (mkFold1 (natLikeSucc (b2 x')) (f x') true))
    . intro x hx
      exact ofMkFold1Triv f x (natLikeSucc (b2 x))
    . sorry

theorem bruteTacticProof2LtNone {t1 t2 : Type} [IsNatLike t1] [IsNatLike t2] (b1 : t1) (f : t1 → t2 → Bool) :
  ∀ x < b1, ∀ y : t2, f x y := by
  intro x hx
  apply ofMkFold1None (f x) (fun _ => (mkFold1 none (f x) true))
  . intro y h
    apply ofMkFold1None (f x) (f x)
    . exact fun y h => h
    . exact h
  . revert x hx
    apply ofMkFold1SomeLt b1 _ (fun x' => (mkFold1 none (f x') true))
    . intro x hx
      exact ofMkFold1Triv f x none
    . sorry

theorem bruteTacticProof2NoneLt {t1 t2 : Type} [IsNatLike t1] [IsNatLike t2] (b2 : t1 → t2) (f : t1 → t2 → Bool) :
  ∀ x : t1, ∀ y < b2 x, f x y := by
  intro x
  apply ofMkFold1SomeLt (b2 x) (f x) (fun _ => (mkFold1 (b2 x) (f x) true))
  . intro y hy h
    apply ofMkFold1SomeLt (b2 x) (f x) (f x)
    . exact fun y hy h => h
    . exact h
    . exact hy
  . revert x
    apply ofMkFold1None _ (fun x' => (mkFold1 (some (b2 x')) (f x') true))
    . intro x
      exact ofMkFold1Triv f x (some (b2 x))
    . sorry

theorem bruteTacticProof3NoneNoneNone {t1 t2 t3 : Type} [IsNatLike t1] [IsNatLike t2] [IsNatLike t3] (f : t1 → t2 → t3 → Bool) :
  ∀ x : t1, ∀ y : t2, ∀ z : t3, f x y z := by
  intro x y
  apply ofMkFold1None (f x y) (fun _ => (mkFold1 none (f x y) true))
  . intro z h
    apply ofMkFold1None (f x y) (f x y)
    . exact fun y h => h
    . exact h
  . revert y
    apply ofMkFold1None
      (fun y' => mkFold1 none (fun _ => mkFold1 none (f x y') true) true)
      (fun y' => mkFold1 none (f x y') true)
    . intro y
      exact ofMkFold1Triv (f x) y none
    . revert x
      apply ofMkFold1None _ (fun x' => mkFold1 none (fun y' => mkFold1 none (f x' y') true) true)
      . intro x h
        exact h
      . sorry

theorem bruteTacticProof3LtLtLt {t1 t2 t3 : Type} [IsNatLike t1] [IsNatLike t2] [IsNatLike t3] (b1 : t1)
  (b2 : t1 → t2) (b3 : t1 → t2 → t3) (f : t1 → t2 → t3 → Bool) :
  ∀ x < b1, ∀ y < (b2 x), ∀ z < (b3 x y), f x y z := by
  intro x hx y hy
  apply ofMkFold1SomeLt (b3 x y) (f x y) (fun _ => (mkFold1 (some (b3 x y)) (f x y) true))
  . intro z hz h
    apply ofMkFold1SomeLt (b3 x y) (f x y) (f x y)
    . exact fun y hy h => h
    . exact h
    . exact hz
  . revert y
    apply ofMkFold1SomeLt
      (b2 x)
      _
      (fun y' => mkFold1 (some (b3 x y')) (f x y') true)
    . intro y hy
      exact ofMkFold1Triv (f x) y (some (b3 x y))
    . revert x
      apply ofMkFold1SomeLt _ _ (fun x' => mkFold1 (some (b2 x')) (fun y' => mkFold1 (some (b3 x' y')) (f x' y') true) true)
      . intro x hx h
        exact h
      . sorry

theorem bruteTacticProof4NoneNoneNoneNone {t1 t2 t3 t4 : Type} [IsNatLike t1] [IsNatLike t2] [IsNatLike t3] [IsNatLike t4]
  (f : t1 → t2 → t3 → t4 → Bool) :
  ∀ x : t1, ∀ y : t2, ∀ z : t3, ∀ a : t4, f x y z a := by
  intro x y z
  apply ofMkFold1None (f x y z) (fun _ => (mkFold1 none (f x y _) true))
  . intro a h
    apply ofMkFold1None (f x y z) (f x y z)
    . exact fun a h => h
    . exact h
  . revert z
    apply ofMkFold1None _ (fun z' => mkFold1 none (f x y z') true)
    . intro z
      exact ofMkFold1Triv (f x y) z none
    . revert y
      apply ofMkFold1None _ (fun y' => mkFold1 none (fun z' => mkFold1 none (f x y' z') true) true)
      . intro y
        exact fun h => h
      . revert x
        apply ofMkFold1None _
          (fun x' => mkFold1 none (fun y' => mkFold1 none (fun z' => mkFold1 none (f x' y' z') true) true) true)
        . intro x
          exact fun h => h
        . sorry

theorem bruteTacticProof5NoneNoneNoneNoneNone {t1 t2 t3 t4 t5 : Type}
  [IsNatLike t1] [IsNatLike t2] [IsNatLike t3] [IsNatLike t4] [IsNatLike t5]
  (f : t1 → t2 → t3 → t4 → t5 → Bool) :
  ∀ x : t1, ∀ y : t2, ∀ z : t3, ∀ a : t4, ∀ b : t5, f x y z a b := by
  intro x y z a
  apply ofMkFold1None (f x y z a) (fun _ => (mkFold1 none (f x y z _) true))
  . intro b h
    apply ofMkFold1None (f x y z a) (f x y z a)
    . exact fun b h => h
    . exact h
  . revert a
    apply ofMkFold1None _ (fun a' => mkFold1 none (f x y z a') true)
    . intro a
      exact ofMkFold1Triv (f x y z) a none
    . revert z
      apply ofMkFold1None _ (fun z' => mkFold1 none (fun a' => mkFold1 none (f x y z' a') true) true)
      . intro z h
        rw [h]
      . revert y
        apply ofMkFold1None _
          (fun y' => mkFold1 none (fun z' => mkFold1 none (fun a' => mkFold1 none (f x y' z' a') true) true) true)
        . intro y h
          rw [h]
        . revert x
          apply ofMkFold1None _
            (fun x' => mkFold1 none
              (fun y' =>
                mkFold1 none (fun z' => mkFold1 none (fun a' => mkFold1 none (f x' y' z' a') true) true) true) true)
          . intro x h
            rw [h]
          . sorry

theorem bruteTermProof2LtNone {t1 t2 : Type} [IsNatLike t1] [IsNatLike t2] (b1 : t1) (f : t1 → t2 → Bool) :
  ∀ x < b1, ∀ y : t2, f x y :=
  fun x hx =>
    ofMkFold1None
      (f x)
      (fun x_1 => mkFold1 none (f x) true)
      (fun y h => ofMkFold1None (f x) (f x) (fun y' hf => hf) h y)
      (ofMkFold1SomeLt
        b1
        (fun x' => mkFold1 none (fun x_1 => mkFold1 none (f x') true) true)
        (fun x' => mkFold1 none (f x') true)
        (fun x' hx' => ofMkFold1Triv f x' none)
        sorry
        x hx
      )

theorem bruteTermProof2NoneLt {t1 t2 : Type} [IsNatLike t1] [IsNatLike t2] (b2 : t1 → t2) (f : t1 → t2 → Bool) :
  ∀ x : t1, ∀ y < b2 x, f x y :=
  fun x =>
    ofMkFold1SomeLt
      (b2 x)
      (f x)
      (fun x_1 => mkFold1 (some (b2 x)) (f x) true)
      (fun y hy h => ofMkFold1SomeLt (b2 x) (f x) (f x) (fun y' _ hf => hf) h y hy)
      (ofMkFold1None
        (fun x' => mkFold1 (some (b2 x')) (fun x_1 => mkFold1 (some (b2 x')) (f x') true) true)
        (fun x' => mkFold1 (some (b2 x')) (f x') true)
        (fun x' => ofMkFold1Triv f x' (some (b2 x')))
        sorry
        x
      )

theorem bruteTermProof2LtLt {t1 t2 : Type} [IsNatLike t1] [IsNatLike t2] (b1 : t1) (b2 : t1 → t2)
  (f : t1 → t2 → Bool) :
  ∀ x < b1, ∀ y < b2 x, f x y :=
  fun x hx =>
    ofMkFold1SomeLt
      (b2 x)
      (f x)
      (fun x_1 => mkFold1 (some (b2 x)) (f x) true)
      (fun y hy h => ofMkFold1SomeLt (b2 x) (f x) (f x) (fun y' _ hf => hf) h y hy)
      (ofMkFold1SomeLt
        b1
        (fun x' => mkFold1 (some (b2 x')) (fun x_1 => mkFold1 (some (b2 x')) (f x') true) true)
        (fun x' => mkFold1 (some (b2 x')) (f x') true)
        (fun x' hx' => ofMkFold1Triv f x' (some (b2 x')))
        sorry
        x hx
      )

theorem bruteTermProof2LtLe {t1 t2 : Type} [IsNatLike t1] [IsNatLike t2] (b1 : t1) (b2 : t1 → t2)
  (f : t1 → t2 → Bool) :
  ∀ x < b1, ∀ y ≤ b2 x, f x y :=
  fun x hx =>
    ofMkFold1SomeLe
      (b2 x)
      (f x)
      (fun _ => mkFold1 (natLikeSucc (b2 x)) (f x) true)
      (fun y hy h => ofMkFold1SomeLe (b2 x) (f x) (f x) (fun y' _ hf => hf) h y hy)
      (ofMkFold1SomeLt
        b1
        (fun x' =>
          mkFold1 (natLikeSucc (b2 x')) (fun _ => mkFold1 (natLikeSucc (b2 x')) (f x') true) true)
        (fun x' => mkFold1 (natLikeSucc (b2 x')) (f x') true)
        (fun x' hx' => ofMkFold1Triv f x' (natLikeSucc (b2 x')))
        sorry
        x hx
      )

theorem bruteTermProof2LeLt {t1 t2 : Type} [IsNatLike t1] [IsNatLike t2] (b1 : t1) (b2 : t1 → t2)
  (f : t1 → t2 → Bool) :
  ∀ x ≤ b1, ∀ y < b2 x, f x y :=
  fun x hx =>
    ofMkFold1SomeLt
      (b2 x)
      (f x)
      (fun _ => mkFold1 (some (b2 x)) (f x) true)
      (fun y hy h => ofMkFold1SomeLt (b2 x) (f x) (f x) (fun y hy h => h) h y hy)
      (ofMkFold1SomeLe
        b1
        (fun x' => mkFold1 (some (b2 x')) (fun _ => mkFold1 (some (b2 x')) (f x') true) true)
        (fun x' => mkFold1 (some (b2 x')) (f x') true)
        (fun x' hx => ofMkFold1Triv f x' (some (b2 x')))
        sorry
        x hx
      )

theorem bruteTermProof2LeLe {t1 t2 : Type} [IsNatLike t1] [IsNatLike t2] (b1 : t1) (b2 : t1 → t2)
  (f : t1 → t2 → Bool) :
  ∀ x ≤ b1, ∀ y ≤ b2 x, f x y :=
  fun x hx =>
    ofMkFold1SomeLe
      (b2 x)
      (f x)
      (fun x_1 => mkFold1 (natLikeSucc (b2 x)) (f x) true)
      (fun y hy h => ofMkFold1SomeLe (b2 x) (f x) (f x) (fun y hy h => h) h y hy)
      (ofMkFold1SomeLe
        b1
        (fun x =>
          mkFold1 (natLikeSucc (b2 x)) (fun x_1 => mkFold1 (natLikeSucc (b2 x)) (f x) true) true)
        (fun x' => mkFold1 (natLikeSucc (b2 x')) (f x') true)
        (fun x' hx' => ofMkFold1Triv f x' (natLikeSucc (b2 x')))
        sorry
        x hx
      )

theorem bruteTermProof2NoneNone {t1 t2 : Type} [IsNatLike t1] [IsNatLike t2] (f : t1 → t2 → Bool) :
  ∀ x : t1, ∀ y : t2, f x y :=
  fun x =>
    ofMkFold1None
      (f x)
      (fun x_1 => mkFold1 none (f x) true)
      (fun y h => ofMkFold1None (f x) (f x) (fun y' hf => hf) h y)
      (ofMkFold1None
        (fun x' => mkFold1 (none : Option t2) (fun x_1 => mkFold1 (none : Option t2) (f x') true) true)
        (fun x' => mkFold1 (none : Option t2) (f x') true)
        (fun x' => ofMkFold1Triv f x' none)
        sorry
        x
      )

theorem bruteTermProof3NoneNoneNone {t1 t2 t3 : Type} [IsNatLike t1] [IsNatLike t2] [IsNatLike t3]
  (f : t1 → t2 → t3 → Bool) :
  ∀ x : t1, ∀ y : t2, ∀ z : t3, f x y z :=
  fun x y =>
    ofMkFold1None
      (f x y)
      (fun x_1 => mkFold1 none (f x y) true)
      (fun z h => ofMkFold1None (f x y) (f x y) (fun z' h => h) h z)
      (ofMkFold1None
        (fun y' => mkFold1 none (fun x_1 => mkFold1 none (f x y') true) true)
        (fun y' => mkFold1 none (f x y') true)
        (fun y' => ofMkFold1Triv (f x) y' none)
        (ofMkFold1None
          (fun x' => mkFold1 none (fun y' => mkFold1 none (f x' y') true) true)
          (fun x' => mkFold1 none (fun y' => mkFold1 none (f x' y') true) true)
          (fun _ h => h)
          sorry
          x
        )
        y
      )

theorem bruteTermProof3LtLtLt {t1 t2 t3 : Type} [IsNatLike t1] [IsNatLike t2] [IsNatLike t3] (b1 : t1)
  (b2 : t1 → t2) (b3 : t1 → t2 → t3) (f : t1 → t2 → t3 → Bool) :
  ∀ x < b1, ∀ y < (b2 x), ∀ z < (b3 x y), f x y z :=
  fun x hx y hy =>
    ofMkFold1SomeLt
      (b3 x y)
      (f x y)
      (fun x_1 => mkFold1 (some (b3 x y)) (f x y) true)
      (fun z hz h => ofMkFold1SomeLt (b3 x y) (f x y) (f x y) (fun y_1 hy h => h) h z hz)
      (ofMkFold1SomeLt (b2 x)
        (fun x_1 =>
          mkFold1 (some (b3 x x_1)) (fun x_2 => mkFold1 (some (b3 x x_1)) (f x x_1) true) true)
        (fun y' => mkFold1 (some (b3 x y')) (f x y') true)
        (fun y hy => ofMkFold1Triv (f x) y (some (b3 x y)))
        (ofMkFold1SomeLt
          b1
          (fun x' => mkFold1 (some (b2 x')) (fun y' => mkFold1 (some (b3 x' y')) (f x' y') true) true)
          (fun x' =>
            mkFold1 (some (b2 x')) (fun y' => mkFold1 (some (b3 x' y')) (f x' y') true) true)
          (fun x hx h => h)
          sorry
          x hx
        )
        y hy
      )

theorem bruteTermProof4NoneNoneNoneNone {t1 t2 t3 t4 : Type} [IsNatLike t1] [IsNatLike t2] [IsNatLike t3] [IsNatLike t4]
  (f : t1 → t2 → t3 → t4 → Bool) : ∀ x : t1, ∀ y : t2, ∀ z : t3, ∀ a : t4, f x y z a :=
  fun x y z =>
    ofMkFold1None
      (f x y z)
      (fun x_1 => mkFold1 none (f x y z) true)
      (fun a h => ofMkFold1None (f x y z) (f x y z) (fun a h => h) h a)
      (ofMkFold1None
        (fun z' => mkFold1 none (fun _ => mkFold1 none (f x y z') true) true)
        (fun z' => mkFold1 none (f x y z') true)
        (fun z' => ofMkFold1Triv (f x y) z' none)
        (ofMkFold1None
          (fun y' => mkFold1 (none : Option t3) (fun z' => mkFold1 (none : Option t4) (f x y' z') true) true)
          (fun y' => mkFold1 (none : Option t3) (fun z' => mkFold1 (none : Option t4) (f x y' z') true) true)
          (fun y' h => h)
          (ofMkFold1None
            (fun x' =>
              mkFold1 none (fun y' => mkFold1 none (fun z' => mkFold1 (none : Option t4) (f x' y' z') true) true) true)
            (fun x' =>
              mkFold1 none (fun y' => mkFold1 none (fun z' => mkFold1 (none : Option t4) (f x' y' z') true) true) true)
            (fun x' h => h)
            sorry
            x
          )
          y
        )
        z
      )

theorem bruteTermProof5NoneNoneNoneNoneNone {t1 t2 t3 t4 t5 : Type}
  [IsNatLike t1] [IsNatLike t2] [IsNatLike t3] [IsNatLike t4] [IsNatLike t5]
  (f : t1 → t2 → t3 → t4 → t5 → Bool) :
  ∀ x : t1, ∀ y : t2, ∀ z : t3, ∀ a : t4, ∀ b : t5, f x y z a b :=
  fun x y z a =>
    ofMkFold1None
      (f x y z a)
      (fun x_1 => mkFold1 none (f x y z a) true)
      (fun b h => ofMkFold1None (f x y z a) (f x y z a) (fun b h => h) h b)
      (ofMkFold1None
        (fun a' => mkFold1 none (fun x_2 => mkFold1 none (f x y z a') true) true)
        (fun a' => mkFold1 none (f x y z a') true)
        (fun a' => ofMkFold1Triv (f x y z) a' none)
        (ofMkFold1None
          (fun z' => mkFold1 none (fun a' => mkFold1 none (f x y z' a') true) true)
          (fun z' => mkFold1 none (fun a' => mkFold1 none (f x y z' a') true) true)
          (fun z h => h)
          (ofMkFold1None
            (fun y' =>
              mkFold1 none
                (fun z' => mkFold1 none (fun a' => mkFold1 none (f x y' z' a') true) true) true)
            (fun y' =>
              mkFold1 none
                (fun z' => mkFold1 none (fun a' => mkFold1 none (f x y' z' a') true) true) true)
            (fun y h => h)
            (ofMkFold1None
              (fun x' =>
                mkFold1 none
                  (fun y' =>
                    mkFold1 none
                      (fun z' => mkFold1 none (fun a' => mkFold1 none (f x' y' z' a') true) true)
                      true)
                  true)
              (fun x' =>
                mkFold1 none
                  (fun y' =>
                    mkFold1 none
                      (fun z' => mkFold1 none (fun a' => mkFold1 none (f x' y' z' a') true) true)
                      true)
                  true)
              (fun x h => h)
              sorry
              x
            )
            y
          )
          z
        )
        a
      )
