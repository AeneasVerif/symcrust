-- THIS FILE WAS AUTOMATICALLY GENERATED BY AENEAS
-- [symcrust]: function definitions
import Aeneas
import Symcrust.Code.Types
import Symcrust.Code.FunsExternal
open Aeneas.Std Result Error
set_option linter.dupNamespace false
set_option linter.hashCommand false
set_option linter.unusedVariables false

namespace Symcrust

/- [symcrust::ntt::MLWE_POLYNOMIAL_COEFFICIENTS]
   Source: 'src/ntt.rs', lines 52:0-52:48 -/
@[global_simps]
def ntt.MLWE_POLYNOMIAL_COEFFICIENTS_body : Result Usize := ok 256#usize
@[global_simps, irreducible]
def ntt.MLWE_POLYNOMIAL_COEFFICIENTS : Usize :=
  eval_global ntt.MLWE_POLYNOMIAL_COEFFICIENTS_body

/- [symcrust::ntt::MATRIX_MAX_NROWS]
   Source: 'src/ntt.rs', lines 64:0-64:34 -/
@[global_simps] def ntt.MATRIX_MAX_NROWS_body : Result Usize := ok 4#usize
@[global_simps, irreducible]
def ntt.MATRIX_MAX_NROWS : Usize := eval_global ntt.MATRIX_MAX_NROWS_body

/- [symcrust::ntt::KEY_MAX_SIZEOF_ENCODED_T]
   Source: 'src/ntt.rs', lines 91:0-91:45 -/
@[global_simps]
def ntt.KEY_MAX_SIZEOF_ENCODED_T_body : Result Usize := ok 1536#usize
@[global_simps, irreducible]
def ntt.KEY_MAX_SIZEOF_ENCODED_T : Usize :=
  eval_global ntt.KEY_MAX_SIZEOF_ENCODED_T_body

/- [symcrust::ntt::Q]
   Source: 'src/ntt.rs', lines 147:0-147:20 -/
@[global_simps] def ntt.Q_body : Result U32 := ok 3329#u32
@[global_simps, irreducible] def ntt.Q : U32 := eval_global ntt.Q_body

/- [symcrust::ntt::SIZEOF_MAX_CIPHERTEXT]
   Source: 'src/ntt.rs', lines 156:0-156:42 -/
@[global_simps]
def ntt.SIZEOF_MAX_CIPHERTEXT_body : Result Usize := ok 1568#usize
@[global_simps, irreducible]
def ntt.SIZEOF_MAX_CIPHERTEXT : Usize :=
  eval_global ntt.SIZEOF_MAX_CIPHERTEXT_body

/- [symcrust::ntt::SIZEOF_AGREED_SECRET]
   Source: 'src/ntt.rs', lines 157:0-157:39 -/
@[global_simps] def ntt.SIZEOF_AGREED_SECRET_body : Result Usize := ok 32#usize
@[global_simps, irreducible]
def ntt.SIZEOF_AGREED_SECRET : Usize :=
  eval_global ntt.SIZEOF_AGREED_SECRET_body

/- [symcrust::ntt::SIZEOF_ENCAPS_RANDOM]
   Source: 'src/ntt.rs', lines 158:0-158:39 -/
@[global_simps] def ntt.SIZEOF_ENCAPS_RANDOM_body : Result Usize := ok 32#usize
@[global_simps, irreducible]
def ntt.SIZEOF_ENCAPS_RANDOM : Usize :=
  eval_global ntt.SIZEOF_ENCAPS_RANDOM_body

/- [symcrust::ntt::Rlog2]
   Source: 'src/ntt.rs', lines 216:0-216:22 -/
@[global_simps] def ntt.Rlog2_body : Result U32 := ok 16#u32
@[global_simps, irreducible] def ntt.Rlog2 : U32 := eval_global ntt.Rlog2_body

/- [symcrust::ntt::Rmask]
   Source: 'src/ntt.rs', lines 217:0-217:26 -/
@[global_simps] def ntt.Rmask_body : Result U32 := ok 65535#u32
@[global_simps, irreducible] def ntt.Rmask : U32 := eval_global ntt.Rmask_body

/- [symcrust::ntt::NegQInvModR]
   Source: 'src/ntt.rs', lines 220:0-220:30 -/
@[global_simps] def ntt.NegQInvModR_body : Result U32 := ok 3327#u32
@[global_simps, irreducible]
def ntt.NegQInvModR : U32 := eval_global ntt.NegQInvModR_body

/- [symcrust::ntt::Rsqr]
   Source: 'src/ntt.rs', lines 223:0-223:23 -/
@[global_simps] def ntt.Rsqr_body : Result U32 := ok 1353#u32
@[global_simps, irreducible] def ntt.Rsqr : U32 := eval_global ntt.Rsqr_body

/- [symcrust::ntt::RsqrTimesNegQInvModR]
   Source: 'src/ntt.rs', lines 225:0-225:40 -/
@[global_simps] def ntt.RsqrTimesNegQInvModR_body : Result U32 := ok 44983#u32
@[global_simps, irreducible]
def ntt.RsqrTimesNegQInvModR : U32 := eval_global ntt.RsqrTimesNegQInvModR_body

/- [symcrust::ntt::MlKemZetaBitRevTimesR]
   Source: 'src/ntt.rs', lines 240:0-257:2 -/
@[global_simps]
def ntt.MlKemZetaBitRevTimesR_body : Result (Array U16 128#usize) :=
  ok
  (Array.make 128#usize [
    2285#u16, 2571#u16, 2970#u16, 1812#u16, 1493#u16, 1422#u16, 287#u16,
    202#u16, 3158#u16, 622#u16, 1577#u16, 182#u16, 962#u16, 2127#u16, 1855#u16,
    1468#u16, 573#u16, 2004#u16, 264#u16, 383#u16, 2500#u16, 1458#u16,
    1727#u16, 3199#u16, 2648#u16, 1017#u16, 732#u16, 608#u16, 1787#u16,
    411#u16, 3124#u16, 1758#u16, 1223#u16, 652#u16, 2777#u16, 1015#u16,
    2036#u16, 1491#u16, 3047#u16, 1785#u16, 516#u16, 3321#u16, 3009#u16,
    2663#u16, 1711#u16, 2167#u16, 126#u16, 1469#u16, 2476#u16, 3239#u16,
    3058#u16, 830#u16, 107#u16, 1908#u16, 3082#u16, 2378#u16, 2931#u16,
    961#u16, 1821#u16, 2604#u16, 448#u16, 2264#u16, 677#u16, 2054#u16,
    2226#u16, 430#u16, 555#u16, 843#u16, 2078#u16, 871#u16, 1550#u16, 105#u16,
    422#u16, 587#u16, 177#u16, 3094#u16, 3038#u16, 2869#u16, 1574#u16,
    1653#u16, 3083#u16, 778#u16, 1159#u16, 3182#u16, 2552#u16, 1483#u16,
    2727#u16, 1119#u16, 1739#u16, 644#u16, 2457#u16, 349#u16, 418#u16, 329#u16,
    3173#u16, 3254#u16, 817#u16, 1097#u16, 603#u16, 610#u16, 1322#u16,
    2044#u16, 1864#u16, 384#u16, 2114#u16, 3193#u16, 1218#u16, 1994#u16,
    2455#u16, 220#u16, 2142#u16, 1670#u16, 2144#u16, 1799#u16, 2051#u16,
    794#u16, 1819#u16, 2475#u16, 2459#u16, 478#u16, 3221#u16, 3021#u16,
    996#u16, 991#u16, 958#u16, 1869#u16, 1522#u16, 1628#u16
    ])
@[global_simps, irreducible]
def ntt.MlKemZetaBitRevTimesR : Array U16 128#usize :=
  eval_global ntt.MlKemZetaBitRevTimesR_body

/- [symcrust::ntt::MlKemZetaBitRevTimesRTimesNegQInvModR]
   Source: 'src/ntt.rs', lines 263:0-280:2 -/
@[global_simps]
def ntt.MlKemZetaBitRevTimesRTimesNegQInvModR_body
  : Result (Array U16 128#usize) :=
  ok
  (Array.make 128#usize [
    19#u16, 34037#u16, 50790#u16, 64748#u16, 52011#u16, 12402#u16, 37345#u16,
    16694#u16, 20906#u16, 37778#u16, 3799#u16, 15690#u16, 54846#u16, 64177#u16,
    11201#u16, 34372#u16, 5827#u16, 48172#u16, 26360#u16, 29057#u16, 59964#u16,
    1102#u16, 44097#u16, 26241#u16, 28072#u16, 41223#u16, 10532#u16, 56736#u16,
    47109#u16, 56677#u16, 38860#u16, 16162#u16, 5689#u16, 6516#u16, 64039#u16,
    34569#u16, 23564#u16, 45357#u16, 44825#u16, 40455#u16, 12796#u16,
    38919#u16, 49471#u16, 12441#u16, 56401#u16, 649#u16, 25986#u16, 37699#u16,
    45652#u16, 28249#u16, 15886#u16, 8898#u16, 28309#u16, 56460#u16, 30198#u16,
    47286#u16, 52109#u16, 51519#u16, 29155#u16, 12756#u16, 48704#u16,
    61224#u16, 24155#u16, 17914#u16, 334#u16, 54354#u16, 11477#u16, 52149#u16,
    32226#u16, 14233#u16, 45042#u16, 21655#u16, 27738#u16, 52405#u16,
    64591#u16, 4586#u16, 14882#u16, 42443#u16, 59354#u16, 60043#u16, 33525#u16,
    32502#u16, 54905#u16, 35218#u16, 36360#u16, 18741#u16, 28761#u16,
    52897#u16, 18485#u16, 45436#u16, 47975#u16, 47011#u16, 14430#u16,
    46007#u16, 5275#u16, 12618#u16, 31183#u16, 45239#u16, 40101#u16, 63390#u16,
    7382#u16, 50180#u16, 41144#u16, 32384#u16, 20926#u16, 6279#u16, 54590#u16,
    14902#u16, 41321#u16, 11044#u16, 48546#u16, 51066#u16, 55200#u16,
    21497#u16, 7933#u16, 20198#u16, 22501#u16, 42325#u16, 54629#u16, 17442#u16,
    33899#u16, 23859#u16, 36892#u16, 20257#u16, 41538#u16, 57779#u16,
    17422#u16, 42404#u16
    ])
@[global_simps, irreducible]
def ntt.MlKemZetaBitRevTimesRTimesNegQInvModR : Array U16 128#usize :=
  eval_global ntt.MlKemZetaBitRevTimesRTimesNegQInvModR_body

/- [symcrust::ntt::zetaTwoTimesBitRevPlus1TimesR]
   Source: 'src/ntt.rs', lines 286:0-303:2 -/
@[global_simps]
def ntt.zetaTwoTimesBitRevPlus1TimesR_body : Result (Array U16 128#usize) :=
  ok
  (Array.make 128#usize [
    2226#u16, 1103#u16, 430#u16, 2899#u16, 555#u16, 2774#u16, 843#u16,
    2486#u16, 2078#u16, 1251#u16, 871#u16, 2458#u16, 1550#u16, 1779#u16,
    105#u16, 3224#u16, 422#u16, 2907#u16, 587#u16, 2742#u16, 177#u16, 3152#u16,
    3094#u16, 235#u16, 3038#u16, 291#u16, 2869#u16, 460#u16, 1574#u16,
    1755#u16, 1653#u16, 1676#u16, 3083#u16, 246#u16, 778#u16, 2551#u16,
    1159#u16, 2170#u16, 3182#u16, 147#u16, 2552#u16, 777#u16, 1483#u16,
    1846#u16, 2727#u16, 602#u16, 1119#u16, 2210#u16, 1739#u16, 1590#u16,
    644#u16, 2685#u16, 2457#u16, 872#u16, 349#u16, 2980#u16, 418#u16, 2911#u16,
    329#u16, 3000#u16, 3173#u16, 156#u16, 3254#u16, 75#u16, 817#u16, 2512#u16,
    1097#u16, 2232#u16, 603#u16, 2726#u16, 610#u16, 2719#u16, 1322#u16,
    2007#u16, 2044#u16, 1285#u16, 1864#u16, 1465#u16, 384#u16, 2945#u16,
    2114#u16, 1215#u16, 3193#u16, 136#u16, 1218#u16, 2111#u16, 1994#u16,
    1335#u16, 2455#u16, 874#u16, 220#u16, 3109#u16, 2142#u16, 1187#u16,
    1670#u16, 1659#u16, 2144#u16, 1185#u16, 1799#u16, 1530#u16, 2051#u16,
    1278#u16, 794#u16, 2535#u16, 1819#u16, 1510#u16, 2475#u16, 854#u16,
    2459#u16, 870#u16, 478#u16, 2851#u16, 3221#u16, 108#u16, 3021#u16, 308#u16,
    996#u16, 2333#u16, 991#u16, 2338#u16, 958#u16, 2371#u16, 1869#u16,
    1460#u16, 1522#u16, 1807#u16, 1628#u16, 1701#u16
    ])
@[global_simps, irreducible]
def ntt.zetaTwoTimesBitRevPlus1TimesR : Array U16 128#usize :=
  eval_global ntt.zetaTwoTimesBitRevPlus1TimesR_body

/- [symcrust::ntt::SymCryptMlKemModAdd]:
   Source: 'src/ntt.rs', lines 306:0-320:1 -/
def ntt.SymCryptMlKemModAdd (a : U32) (b : U32) : Result U32 :=
  do
  massert (a < ntt.Q)
  massert (b < ntt.Q)
  let i ← a + b
  let res ← (↑(core.num.U32.wrapping_sub i ntt.Q) : Result _)
  let i1 ← res >>> 16#i32
  if i1 = 0#u32
  then
    do
    let i2 ← (↑(ntt.Q &&& i1) : Result _)
    let res1 ← (↑(core.num.U32.wrapping_add res i2) : Result _)
    massert (res1 < ntt.Q)
    ok res1
  else
    do
    massert (i1 = 65535#u32)
    let i2 ← (↑(ntt.Q &&& i1) : Result _)
    let res1 ← (↑(core.num.U32.wrapping_add res i2) : Result _)
    massert (res1 < ntt.Q)
    ok res1

/- [symcrust::ntt::SymCryptMlKemModSub]:
   Source: 'src/ntt.rs', lines 322:0-344:1 -/
def ntt.SymCryptMlKemModSub (a : U32) (b : U32) : Result U32 :=
  do
  let i ← 2#u32 * ntt.Q
  massert (a < i)
  massert (b <= ntt.Q)
  let res ← (↑(core.num.U32.wrapping_sub a b) : Result _)
  let i1 ← res >>> 16#i32
  if i1 = 0#u32
  then
    do
    let i2 ← (↑(ntt.Q &&& i1) : Result _)
    let res1 ← (↑(core.num.U32.wrapping_add res i2) : Result _)
    massert (res1 < ntt.Q)
    ok res1
  else
    do
    massert (i1 = 65535#u32)
    let i2 ← (↑(ntt.Q &&& i1) : Result _)
    let res1 ← (↑(core.num.U32.wrapping_add res i2) : Result _)
    massert (res1 < ntt.Q)
    ok res1

/- [symcrust::ntt::SymCryptMlKemMontMul]:
   Source: 'src/ntt.rs', lines 353:0-367:1 -/
def ntt.SymCryptMlKemMontMul (a : U32) (b : U32) (bMont : U32) : Result U32 :=
  do
  massert (a < ntt.Q)
  massert (b < ntt.Q)
  massert (bMont <= ntt.Rmask)
  let i ← b * ntt.NegQInvModR
  let i1 ← (↑(i &&& ntt.Rmask) : Result _)
  massert (bMont = i1)
  let res ← a * b
  let i2 ← a * bMont
  let inv ← (↑(i2 &&& ntt.Rmask) : Result _)
  let i3 ← inv * ntt.Q
  let res1 ← res + i3
  let i4 ← (↑(res1 &&& ntt.Rmask) : Result _)
  massert (i4 = 0#u32)
  let res2 ← res1 >>> ntt.Rlog2
  ntt.SymCryptMlKemModSub res2 ntt.Q

/- [symcrust::ntt::SymCryptMlKemPolyElementNTTLayerC::inner_loop]: loop 0:
   Source: 'src/ntt.rs', lines 44:8-402:13 -/
divergent def ntt.SymCryptMlKemPolyElementNTTLayerC.inner_loop_loop
  (peSrc : Array U16 256#usize) (len : Usize) (start : Usize)
  (twiddleFactor : U32) (twiddleFactorMont : U32) (j : Usize) :
  Result (Array U16 256#usize)
  :=
  if j < len
  then
    do
    let i ← start + j
    let i1 ← Array.index_usize peSrc i
    let c0 ← core.convert.IntoFrom.into core.convert.FromU32U16 i1
    massert (c0 < ntt.Q)
    let i2 ← i + len
    let i3 ← Array.index_usize peSrc i2
    let c1 ← core.convert.IntoFrom.into core.convert.FromU32U16 i3
    massert (c1 < ntt.Q)
    let c1TimesTwiddle ←
      ntt.SymCryptMlKemMontMul c1 twiddleFactor twiddleFactorMont
    let c11 ← ntt.SymCryptMlKemModSub c0 c1TimesTwiddle
    let c01 ← ntt.SymCryptMlKemModAdd c0 c1TimesTwiddle
    let i4 ← (↑(UScalar.cast .U16 c01) : Result _)
    let peSrc1 ← Array.update peSrc i i4
    let i5 ← i + len
    let i6 ← (↑(UScalar.cast .U16 c11) : Result _)
    let peSrc2 ← Array.update peSrc1 i5 i6
    let j1 ← j + 1#usize
    ntt.SymCryptMlKemPolyElementNTTLayerC.inner_loop_loop peSrc2 len start
      twiddleFactor twiddleFactorMont j1
  else ok peSrc

/- [symcrust::ntt::SymCryptMlKemPolyElementNTTLayerC::inner_loop]:
   Source: 'src/ntt.rs', lines 380:8-403:9 -/
@[reducible]
def ntt.SymCryptMlKemPolyElementNTTLayerC.inner_loop
  (peSrc : Array U16 256#usize) (len : Usize) (start : Usize)
  (twiddleFactor : U32) (twiddleFactorMont : U32) :
  Result (Array U16 256#usize)
  :=
  ntt.SymCryptMlKemPolyElementNTTLayerC.inner_loop_loop peSrc len start
    twiddleFactor twiddleFactorMont 0#usize

/- [symcrust::ntt::SymCryptMlKemPolyElementNTTLayerC]: loop 0:
   Source: 'src/ntt.rs', lines 44:8-405:5 -/
divergent def ntt.SymCryptMlKemPolyElementNTTLayerC_loop
  (peSrc : Array U16 256#usize) (k : Usize) (len : Usize) (start : Usize) :
  Result (Array U16 256#usize)
  :=
  if start < 256#usize
  then
    do
    let i ← Array.index_usize ntt.MlKemZetaBitRevTimesR k
    let twiddleFactor ← core.convert.IntoFrom.into core.convert.FromU32U16 i
    let i1 ← Array.index_usize ntt.MlKemZetaBitRevTimesRTimesNegQInvModR k
    let twiddleFactorMont ←
      core.convert.IntoFrom.into core.convert.FromU32U16 i1
    let k1 ← k + 1#usize
    let peSrc1 ←
      ntt.SymCryptMlKemPolyElementNTTLayerC.inner_loop peSrc len start
        twiddleFactor twiddleFactorMont
    let i2 ← 2#usize * len
    let start1 ← start + i2
    ntt.SymCryptMlKemPolyElementNTTLayerC_loop peSrc1 k1 len start1
  else ok peSrc

/- [symcrust::ntt::SymCryptMlKemPolyElementNTTLayerC]:
   Source: 'src/ntt.rs', lines 369:0-406:1 -/
@[reducible]
def ntt.SymCryptMlKemPolyElementNTTLayerC
  (peSrc : Array U16 256#usize) (k : Usize) (len : Usize) :
  Result (Array U16 256#usize)
  :=
  ntt.SymCryptMlKemPolyElementNTTLayerC_loop peSrc k len 0#usize

/- [symcrust::ntt::SymCryptMlKemPolyElementINTTLayerC::inner_loop]: loop 0:
   Source: 'src/ntt.rs', lines 44:8-434:13 -/
divergent def ntt.SymCryptMlKemPolyElementINTTLayerC.inner_loop_loop
  (peSrc : Array U16 256#usize) (len : Usize) (start : Usize)
  (twiddleFactor : U32) (twiddleFactorMont : U32) (j : Usize) :
  Result (Array U16 256#usize)
  :=
  if j < len
  then
    do
    let i ← start + j
    let i1 ← Array.index_usize peSrc i
    let c0 ← core.convert.IntoFrom.into core.convert.FromU32U16 i1
    massert (c0 < ntt.Q)
    let i2 ← i + len
    let i3 ← Array.index_usize peSrc i2
    let c1 ← core.convert.IntoFrom.into core.convert.FromU32U16 i3
    massert (c1 < ntt.Q)
    let tmp ← ntt.SymCryptMlKemModAdd c0 c1
    let c11 ← ntt.SymCryptMlKemModSub c1 c0
    let c12 ← ntt.SymCryptMlKemMontMul c11 twiddleFactor twiddleFactorMont
    let i4 ← (↑(UScalar.cast .U16 tmp) : Result _)
    let peSrc1 ← Array.update peSrc i i4
    let i5 ← i + len
    let i6 ← (↑(UScalar.cast .U16 c12) : Result _)
    let peSrc2 ← Array.update peSrc1 i5 i6
    let j1 ← j + 1#usize
    ntt.SymCryptMlKemPolyElementINTTLayerC.inner_loop_loop peSrc2 len start
      twiddleFactor twiddleFactorMont j1
  else ok peSrc

/- [symcrust::ntt::SymCryptMlKemPolyElementINTTLayerC::inner_loop]:
   Source: 'src/ntt.rs', lines 420:8-435:9 -/
@[reducible]
def ntt.SymCryptMlKemPolyElementINTTLayerC.inner_loop
  (peSrc : Array U16 256#usize) (len : Usize) (start : Usize)
  (twiddleFactor : U32) (twiddleFactorMont : U32) :
  Result (Array U16 256#usize)
  :=
  ntt.SymCryptMlKemPolyElementINTTLayerC.inner_loop_loop peSrc len start
    twiddleFactor twiddleFactorMont 0#usize

/- [symcrust::ntt::SymCryptMlKemPolyElementINTTLayerC]: loop 0:
   Source: 'src/ntt.rs', lines 44:8-436:5 -/
divergent def ntt.SymCryptMlKemPolyElementINTTLayerC_loop
  (peSrc : Array U16 256#usize) (k : Usize) (len : Usize) (start : Usize) :
  Result (Array U16 256#usize)
  :=
  if start < 256#usize
  then
    do
    let i ← Array.index_usize ntt.MlKemZetaBitRevTimesR k
    let twiddleFactor ← core.convert.IntoFrom.into core.convert.FromU32U16 i
    let i1 ← Array.index_usize ntt.MlKemZetaBitRevTimesRTimesNegQInvModR k
    let twiddleFactorMont ←
      core.convert.IntoFrom.into core.convert.FromU32U16 i1
    let k1 ← k - 1#usize
    let peSrc1 ←
      ntt.SymCryptMlKemPolyElementINTTLayerC.inner_loop peSrc len start
        twiddleFactor twiddleFactorMont
    let i2 ← 2#usize * len
    let start1 ← start + i2
    ntt.SymCryptMlKemPolyElementINTTLayerC_loop peSrc1 k1 len start1
  else ok peSrc

/- [symcrust::ntt::SymCryptMlKemPolyElementINTTLayerC]:
   Source: 'src/ntt.rs', lines 408:0-437:1 -/
@[reducible]
def ntt.SymCryptMlKemPolyElementINTTLayerC
  (peSrc : Array U16 256#usize) (k : Usize) (len : Usize) :
  Result (Array U16 256#usize)
  :=
  ntt.SymCryptMlKemPolyElementINTTLayerC_loop peSrc k len 0#usize

/- [symcrust::ntt::SymCryptMlKemPolyElementNTTLayer]:
   Source: 'src/ntt.rs', lines 439:0-441:1 -/
def ntt.SymCryptMlKemPolyElementNTTLayer
  (peSrc : Array U16 256#usize) (k : Usize) (len : Usize) :
  Result (Array U16 256#usize)
  :=
  ntt.SymCryptMlKemPolyElementNTTLayerC peSrc k len

/- [symcrust::ntt::SymCryptMlKemPolyElementINTTLayer]:
   Source: 'src/ntt.rs', lines 443:0-445:1 -/
def ntt.SymCryptMlKemPolyElementINTTLayer
  (peSrc : Array U16 256#usize) (k : Usize) (len : Usize) :
  Result (Array U16 256#usize)
  :=
  ntt.SymCryptMlKemPolyElementINTTLayerC peSrc k len

/- [symcrust::ntt::SymCryptMlKemPolyElementMulAndAccumulate]: loop 0:
   Source: 'src/ntt.rs', lines 44:8-511:5 -/
divergent def ntt.SymCryptMlKemPolyElementMulAndAccumulate_loop
  (peSrc1 : Array U16 256#usize) (peSrc2 : Array U16 256#usize)
  (paDst : Array U32 256#usize) (i : Usize) :
  Result (Array U32 256#usize)
  :=
  do
  let i1 ← ntt.MLWE_POLYNOMIAL_COEFFICIENTS / 2#usize
  if i < i1
  then
    do
    let i2 ← 2#usize * i
    let i3 ← Array.index_usize peSrc1 i2
    let a0 ← core.convert.IntoFrom.into core.convert.FromU32U16 i3
    massert (a0 < ntt.Q)
    let i4 ← i2 + 1#usize
    let i5 ← Array.index_usize peSrc1 i4
    let a1 ← core.convert.IntoFrom.into core.convert.FromU32U16 i5
    massert (a1 < ntt.Q)
    let i6 ← Array.index_usize peSrc2 i2
    let b0 ← core.convert.IntoFrom.into core.convert.FromU32U16 i6
    massert (b0 < ntt.Q)
    let i7 ← i2 + 1#usize
    let i8 ← Array.index_usize peSrc2 i7
    let b1 ← core.convert.IntoFrom.into core.convert.FromU32U16 i8
    massert (b1 < ntt.Q)
    let i9 ← Array.index_usize paDst i2
    let c0 ← core.convert.IntoFrom.into (core.convert.FromSame U32) i9
    let i10 ← 3328#u32 * 3328#u32
    let i11 ← 3494#u32 * 3312#u32
    let i12 ← i10 + i11
    let i13 ← 3#u32 * i12
    massert (c0 <= i13)
    let i14 ← i2 + 1#usize
    let i15 ← Array.index_usize paDst i14
    let c1 ← core.convert.IntoFrom.into (core.convert.FromSame U32) i15
    let i16 ← i10 + i11
    let i17 ← 3#u32 * i16
    massert (c1 <= i17)
    let a0b0 ← a0 * b0
    let a1b1 ← a1 * b1
    let a0b1 ← a0 * b1
    let a1b0 ← a1 * b0
    let i18 ← a1b1 * ntt.NegQInvModR
    let inv ← (↑(i18 &&& ntt.Rmask) : Result _)
    let i19 ← inv * ntt.Q
    let i20 ← a1b1 + i19
    let a1b11 ← i20 >>> ntt.Rlog2
    massert (a1b11 <= 3494#u32)
    let i21 ← Array.index_usize ntt.zetaTwoTimesBitRevPlus1TimesR i
    let i22 ← (↑(UScalar.cast .U32 i21) : Result _)
    let a1b1zetapow ← a1b11 * i22
    let a0b01 ← a0b0 + a1b1zetapow
    let i23 ← i10 + i11
    massert (a0b01 <= i23)
    let a0b11 ← a0b1 + a1b0
    let i24 ← 2#u32 * 3328#u32
    let i25 ← i24 * 3328#u32
    massert (a0b11 <= i25)
    massert (ntt.MATRIX_MAX_NROWS <= 4#usize)
    let c01 ← c0 + a0b01
    let i26 ← 4#u32 * 3328#u32
    let i27 ← i26 * 3328#u32
    let i28 ← 4#u32 * 3494#u32
    let i29 ← i28 * 3312#u32
    let i30 ← i27 + i29
    massert (c01 < i30)
    let c11 ← c1 + a0b11
    let i31 ← 5#u32 * 3328#u32
    let i32 ← i31 * 3328#u32
    let i33 ← 3#u32 * 3494#u32
    let i34 ← i33 * 3312#u32
    let i35 ← i32 + i34
    massert (c11 < i35)
    let paDst1 ← Array.update paDst i2 c01
    let i36 ← i2 + 1#usize
    let paDst2 ← Array.update paDst1 i36 c11
    let i37 ← i + 1#usize
    ntt.SymCryptMlKemPolyElementMulAndAccumulate_loop peSrc1 peSrc2 paDst2 i37
  else ok paDst

/- [symcrust::ntt::SymCryptMlKemPolyElementMulAndAccumulate]:
   Source: 'src/ntt.rs', lines 447:0-512:1 -/
@[reducible]
def ntt.SymCryptMlKemPolyElementMulAndAccumulate
  (peSrc1 : Array U16 256#usize) (peSrc2 : Array U16 256#usize)
  (paDst : Array U32 256#usize) :
  Result (Array U32 256#usize)
  :=
  ntt.SymCryptMlKemPolyElementMulAndAccumulate_loop peSrc1 peSrc2 paDst 0#usize

/- [symcrust::ntt::SymCryptMlKemMontgomeryReduceAndAddPolyElementAccumulatorToPolyElement]: loop 0:
   Source: 'src/ntt.rs', lines 44:8-546:5 -/
divergent def
  ntt.SymCryptMlKemMontgomeryReduceAndAddPolyElementAccumulatorToPolyElement_loop
  (paSrc : Array U32 256#usize) (peDst : Array U16 256#usize) (i : Usize) :
  Result ((Array U32 256#usize) × (Array U16 256#usize))
  :=
  if i < ntt.MLWE_POLYNOMIAL_COEFFICIENTS
  then
    do
    let a ← Array.index_usize paSrc i
    let i1 ← 3328#u32 * 3328#u32
    let i2 ← 3494#u32 * 3312#u32
    let i3 ← i1 + i2
    let i4 ← 4#u32 * i3
    massert (a <= i4)
    let i5 ← Array.index_usize peDst i
    let c ← core.convert.IntoFrom.into core.convert.FromU32U16 i5
    massert (c < ntt.Q)
    let i6 ← a * ntt.NegQInvModR
    let inv ← (↑(i6 &&& ntt.Rmask) : Result _)
    let i7 ← inv * ntt.Q
    let i8 ← a + i7
    let a1 ← i8 >>> ntt.Rlog2
    massert (a1 <= 4711#u32)
    let c1 ← c + a1
    massert (c1 <= 8039#u32)
    let i9 ← 2#u32 * ntt.Q
    let c2 ← c1 - i9
    let i10 ← (↑(UScalar.hcast .I32 ntt.Q) : Result _)
    let i11 ← (-2)#i32 * i10
    let i12 ← (↑(IScalar.hcast .U32 i11) : Result _)
    if c2 >= i12
    then
      do
      let i13 ← c2 >>> 16#i32
      let i14 ← (↑(ntt.Q &&& i13) : Result _)
      let c3 ← c2 + i14
      let i15 ← (↑(UScalar.hcast .I32 ntt.Q) : Result _)
      let i16 ← -. i15
      let i17 ← (↑(IScalar.hcast .U32 i16) : Result _)
      if c3 >= i17
      then
        do
        let i18 ← c3 >>> 16#i32
        let i19 ← (↑(ntt.Q &&& i18) : Result _)
        let c4 ← c3 + i19
        massert (c4 < ntt.Q)
        let i20 ← (↑(UScalar.cast .U16 c4) : Result _)
        let peDst1 ← Array.update peDst i i20
        let i21 ← i + 1#usize
        let paSrc1 ← Array.update paSrc i 0#u32
        ntt.SymCryptMlKemMontgomeryReduceAndAddPolyElementAccumulatorToPolyElement_loop
          paSrc1 peDst1 i21
      else
        do
        massert (c3 < ntt.Q)
        let i18 ← c3 >>> 16#i32
        let i19 ← (↑(ntt.Q &&& i18) : Result _)
        let c4 ← c3 + i19
        massert (c4 < ntt.Q)
        let i20 ← (↑(UScalar.cast .U16 c4) : Result _)
        let peDst1 ← Array.update peDst i i20
        let i21 ← i + 1#usize
        let paSrc1 ← Array.update paSrc i 0#u32
        ntt.SymCryptMlKemMontgomeryReduceAndAddPolyElementAccumulatorToPolyElement_loop
          paSrc1 peDst1 i21
    else
      do
      massert (c2 < 1381#u32)
      let i13 ← c2 >>> 16#i32
      let i14 ← (↑(ntt.Q &&& i13) : Result _)
      let c3 ← c2 + i14
      let i15 ← (↑(UScalar.hcast .I32 ntt.Q) : Result _)
      let i16 ← -. i15
      let i17 ← (↑(IScalar.hcast .U32 i16) : Result _)
      if c3 >= i17
      then
        do
        let i18 ← c3 >>> 16#i32
        let i19 ← (↑(ntt.Q &&& i18) : Result _)
        let c4 ← c3 + i19
        massert (c4 < ntt.Q)
        let i20 ← (↑(UScalar.cast .U16 c4) : Result _)
        let peDst1 ← Array.update peDst i i20
        let i21 ← i + 1#usize
        let paSrc1 ← Array.update paSrc i 0#u32
        ntt.SymCryptMlKemMontgomeryReduceAndAddPolyElementAccumulatorToPolyElement_loop
          paSrc1 peDst1 i21
      else
        do
        massert (c3 < ntt.Q)
        let i18 ← c3 >>> 16#i32
        let i19 ← (↑(ntt.Q &&& i18) : Result _)
        let c4 ← c3 + i19
        massert (c4 < ntt.Q)
        let i20 ← (↑(UScalar.cast .U16 c4) : Result _)
        let peDst1 ← Array.update peDst i i20
        let i21 ← i + 1#usize
        let paSrc1 ← Array.update paSrc i 0#u32
        ntt.SymCryptMlKemMontgomeryReduceAndAddPolyElementAccumulatorToPolyElement_loop
          paSrc1 peDst1 i21
  else ok (paSrc, peDst)

/- [symcrust::ntt::SymCryptMlKemMontgomeryReduceAndAddPolyElementAccumulatorToPolyElement]:
   Source: 'src/ntt.rs', lines 514:0-547:1 -/
@[reducible]
def ntt.SymCryptMlKemMontgomeryReduceAndAddPolyElementAccumulatorToPolyElement
  (paSrc : Array U32 256#usize) (peDst : Array U16 256#usize) :
  Result ((Array U32 256#usize) × (Array U16 256#usize))
  :=
  ntt.SymCryptMlKemMontgomeryReduceAndAddPolyElementAccumulatorToPolyElement_loop
    paSrc peDst 0#usize

/- [symcrust::ntt::SymCryptMlKemPolyElementMulR]: loop 0:
   Source: 'src/ntt.rs', lines 44:8-558:5 -/
divergent def ntt.SymCryptMlKemPolyElementMulR_loop
  (peSrc : Array U16 256#usize) (peDst : Array U16 256#usize) (i : Usize) :
  Result (Array U16 256#usize)
  :=
  if i < ntt.MLWE_POLYNOMIAL_COEFFICIENTS
  then
    do
    let i1 ← Array.index_usize peSrc i
    let i2 ← core.convert.IntoFrom.into core.convert.FromU32U16 i1
    let i3 ← ntt.SymCryptMlKemMontMul i2 ntt.Rsqr ntt.RsqrTimesNegQInvModR
    let i4 ← (↑(UScalar.cast .U16 i3) : Result _)
    let peDst1 ← Array.update peDst i i4
    let i5 ← i + 1#usize
    ntt.SymCryptMlKemPolyElementMulR_loop peSrc peDst1 i5
  else ok peDst

/- [symcrust::ntt::SymCryptMlKemPolyElementMulR]:
   Source: 'src/ntt.rs', lines 549:0-559:1 -/
@[reducible]
def ntt.SymCryptMlKemPolyElementMulR
  (peSrc : Array U16 256#usize) (peDst : Array U16 256#usize) :
  Result (Array U16 256#usize)
  :=
  ntt.SymCryptMlKemPolyElementMulR_loop peSrc peDst 0#usize

/- [symcrust::ntt::SymCryptMlKemPolyElementAdd]: loop 0:
   Source: 'src/ntt.rs', lines 44:8-570:5 -/
divergent def ntt.SymCryptMlKemPolyElementAdd_loop
  (peSrc1 : Array U16 256#usize) (peSrc2 : Array U16 256#usize)
  (peDst : Array U16 256#usize) (i : Usize) :
  Result (Array U16 256#usize)
  :=
  if i < ntt.MLWE_POLYNOMIAL_COEFFICIENTS
  then
    do
    let i1 ← Array.index_usize peSrc1 i
    let i2 ← core.convert.IntoFrom.into core.convert.FromU32U16 i1
    let i3 ← Array.index_usize peSrc2 i
    let i4 ← core.convert.IntoFrom.into core.convert.FromU32U16 i3
    let i5 ← ntt.SymCryptMlKemModAdd i2 i4
    let i6 ← (↑(UScalar.cast .U16 i5) : Result _)
    let peDst1 ← Array.update peDst i i6
    let i7 ← i + 1#usize
    ntt.SymCryptMlKemPolyElementAdd_loop peSrc1 peSrc2 peDst1 i7
  else ok peDst

/- [symcrust::ntt::SymCryptMlKemPolyElementAdd]:
   Source: 'src/ntt.rs', lines 561:0-571:1 -/
@[reducible]
def ntt.SymCryptMlKemPolyElementAdd
  (peSrc1 : Array U16 256#usize) (peSrc2 : Array U16 256#usize)
  (peDst : Array U16 256#usize) :
  Result (Array U16 256#usize)
  :=
  ntt.SymCryptMlKemPolyElementAdd_loop peSrc1 peSrc2 peDst 0#usize

/- [symcrust::ntt::SymCryptMlKemPolyElementSub]: loop 0:
   Source: 'src/ntt.rs', lines 44:8-581:5 -/
divergent def ntt.SymCryptMlKemPolyElementSub_loop
  (peSrc1 : Array U16 256#usize) (peSrc2 : Array U16 256#usize)
  (peDst : Array U16 256#usize) (i : Usize) :
  Result (Array U16 256#usize)
  :=
  if i < ntt.MLWE_POLYNOMIAL_COEFFICIENTS
  then
    do
    let i1 ← Array.index_usize peSrc1 i
    let i2 ← core.convert.IntoFrom.into core.convert.FromU32U16 i1
    let i3 ← Array.index_usize peSrc2 i
    let i4 ← core.convert.IntoFrom.into core.convert.FromU32U16 i3
    let i5 ← ntt.SymCryptMlKemModSub i2 i4
    let i6 ← (↑(UScalar.cast .U16 i5) : Result _)
    let peDst1 ← Array.update peDst i i6
    let i7 ← i + 1#usize
    ntt.SymCryptMlKemPolyElementSub_loop peSrc1 peSrc2 peDst1 i7
  else ok peDst

/- [symcrust::ntt::SymCryptMlKemPolyElementSub]:
   Source: 'src/ntt.rs', lines 573:0-582:1 -/
@[reducible]
def ntt.SymCryptMlKemPolyElementSub
  (peSrc1 : Array U16 256#usize) (peSrc2 : Array U16 256#usize)
  (peDst : Array U16 256#usize) :
  Result (Array U16 256#usize)
  :=
  ntt.SymCryptMlKemPolyElementSub_loop peSrc1 peSrc2 peDst 0#usize

/- [symcrust::ntt::SymCryptMlKemPolyElementNTT]:
   Source: 'src/ntt.rs', lines 584:0-594:1 -/
def ntt.SymCryptMlKemPolyElementNTT
  (peSrc : Array U16 256#usize) : Result (Array U16 256#usize) :=
  do
  let peSrc1 ← ntt.SymCryptMlKemPolyElementNTTLayer peSrc 1#usize 128#usize
  let peSrc2 ← ntt.SymCryptMlKemPolyElementNTTLayer peSrc1 2#usize 64#usize
  let peSrc3 ← ntt.SymCryptMlKemPolyElementNTTLayer peSrc2 4#usize 32#usize
  let peSrc4 ← ntt.SymCryptMlKemPolyElementNTTLayer peSrc3 8#usize 16#usize
  let peSrc5 ← ntt.SymCryptMlKemPolyElementNTTLayer peSrc4 16#usize 8#usize
  let peSrc6 ← ntt.SymCryptMlKemPolyElementNTTLayer peSrc5 32#usize 4#usize
  ntt.SymCryptMlKemPolyElementNTTLayer peSrc6 64#usize 2#usize

/- [symcrust::ntt::INTTFixupTimesRsqr]
   Source: 'src/ntt.rs', lines 599:0-599:37 -/
@[global_simps] def ntt.INTTFixupTimesRsqr_body : Result U32 := ok 1441#u32
@[global_simps, irreducible]
def ntt.INTTFixupTimesRsqr : U32 := eval_global ntt.INTTFixupTimesRsqr_body

/- [symcrust::ntt::INTTFixupTimesRsqrTimesNegQInvModR]
   Source: 'src/ntt.rs', lines 600:0-600:54 -/
@[global_simps]
def ntt.INTTFixupTimesRsqrTimesNegQInvModR_body : Result U32 := ok 10079#u32
@[global_simps, irreducible]
def ntt.INTTFixupTimesRsqrTimesNegQInvModR : U32 :=
  eval_global ntt.INTTFixupTimesRsqrTimesNegQInvModR_body

/- [symcrust::ntt::SymCryptMlKemPolyElementINTTAndMulR]: loop 0:
   Source: 'src/ntt.rs', lines 44:8-617:5 -/
divergent def ntt.SymCryptMlKemPolyElementINTTAndMulR_loop
  (peSrc : Array U16 256#usize) (i : Usize) : Result (Array U16 256#usize) :=
  if i < ntt.MLWE_POLYNOMIAL_COEFFICIENTS
  then
    do
    let i1 ← Array.index_usize peSrc i
    let i2 ← core.convert.IntoFrom.into core.convert.FromU32U16 i1
    let i3 ←
      ntt.SymCryptMlKemMontMul i2 ntt.INTTFixupTimesRsqr
        ntt.INTTFixupTimesRsqrTimesNegQInvModR
    let i4 ← (↑(UScalar.cast .U16 i3) : Result _)
    let peSrc1 ← Array.update peSrc i i4
    let i5 ← i + 1#usize
    ntt.SymCryptMlKemPolyElementINTTAndMulR_loop peSrc1 i5
  else ok peSrc

/- [symcrust::ntt::SymCryptMlKemPolyElementINTTAndMulR]:
   Source: 'src/ntt.rs', lines 602:0-618:1 -/
def ntt.SymCryptMlKemPolyElementINTTAndMulR
  (peSrc : Array U16 256#usize) : Result (Array U16 256#usize) :=
  do
  let peSrc1 ← ntt.SymCryptMlKemPolyElementINTTLayer peSrc 127#usize 2#usize
  let peSrc2 ← ntt.SymCryptMlKemPolyElementINTTLayer peSrc1 63#usize 4#usize
  let peSrc3 ← ntt.SymCryptMlKemPolyElementINTTLayer peSrc2 31#usize 8#usize
  let peSrc4 ← ntt.SymCryptMlKemPolyElementINTTLayer peSrc3 15#usize 16#usize
  let peSrc5 ← ntt.SymCryptMlKemPolyElementINTTLayer peSrc4 7#usize 32#usize
  let peSrc6 ← ntt.SymCryptMlKemPolyElementINTTLayer peSrc5 3#usize 64#usize
  let peSrc7 ← ntt.SymCryptMlKemPolyElementINTTLayer peSrc6 1#usize 128#usize
  ntt.SymCryptMlKemPolyElementINTTAndMulR_loop peSrc7 0#usize

/- [symcrust::ntt::COMPRESS_MULCONSTANT]
   Source: 'src/ntt.rs', lines 626:0-626:43 -/
@[global_simps]
def ntt.COMPRESS_MULCONSTANT_body : Result U32 := ok 10321339#u32
@[global_simps, irreducible]
def ntt.COMPRESS_MULCONSTANT : U32 := eval_global ntt.COMPRESS_MULCONSTANT_body

/- [symcrust::ntt::COMPRESS_SHIFTCONSTANT]
   Source: 'src/ntt.rs', lines 627:0-627:39 -/
@[global_simps] def ntt.COMPRESS_SHIFTCONSTANT_body : Result U32 := ok 35#u32
@[global_simps, irreducible]
def ntt.COMPRESS_SHIFTCONSTANT : U32 :=
  eval_global ntt.COMPRESS_SHIFTCONSTANT_body

/- [symcrust::ntt::min]:
   Source: 'src/ntt.rs', lines 631:0-631:60 -/
def ntt.min (x : U32) (y : U32) : Result U32 :=
  if x <= y
  then ok x
  else ok y

/- [symcrust::ntt::SymCryptMlKemPolyElementCompressAndEncode::inner_loop]: loop 0:
   Source: 'src/ntt.rs', lines 679:12-696:16 -/
divergent def ntt.SymCryptMlKemPolyElementCompressAndEncode.inner_loop_loop
  (pbDst : Slice U8) (cbDstWritten : Usize) (accumulator : U32)
  (nBitsInAccumulator : U32) (nBitsInCoefficient : U32) (coefficient : U32) :
  Result ((Slice U8) × Usize × U32 × U32 × U32 × U32)
  :=
  do
  let i ← 32#u32 - nBitsInAccumulator
  let nBitsToEncode ← ntt.min nBitsInCoefficient i
  let i1 ← 1#u32 <<< nBitsToEncode
  let i2 ← i1 - 1#u32
  let bitsToEncode ← (↑(coefficient &&& i2) : Result _)
  let coefficient1 ← coefficient >>> nBitsToEncode
  let nBitsInCoefficient1 ← nBitsInCoefficient - nBitsToEncode
  let i3 ← bitsToEncode <<< nBitsInAccumulator
  let accumulator1 ← (↑(accumulator ||| i3) : Result _)
  let nBitsInAccumulator1 ← nBitsInAccumulator + nBitsToEncode
  if nBitsInAccumulator1 = 32#u32
  then
    do
    let i4 ← cbDstWritten + 4#usize
    let (s, index_mut_back) ←
      core.slice.index.Slice.index_mut
        (core.slice.index.SliceIndexRangeUsizeSliceInst U8) pbDst
        { start := cbDstWritten, end_ := i4 }
    let a ← (↑(core.num.U32.to_le_bytes accumulator1) : Result _)
    let s1 ← (↑(Array.to_slice a) : Result _)
    let s2 ← core.slice.Slice.copy_from_slice core.marker.CopyU8 s s1
    if nBitsInCoefficient1 > 0#u32
    then
      let pbDst1 := index_mut_back s2
      ntt.SymCryptMlKemPolyElementCompressAndEncode.inner_loop_loop pbDst1 i4
        0#u32 0#u32 nBitsInCoefficient1 coefficient1
    else
      let pbDst1 := index_mut_back s2
      ok (pbDst1, i4, 0#u32, 0#u32, nBitsInCoefficient1, coefficient1)
  else
    if nBitsInCoefficient1 > 0#u32
    then
      ntt.SymCryptMlKemPolyElementCompressAndEncode.inner_loop_loop pbDst
        cbDstWritten accumulator1 nBitsInAccumulator1 nBitsInCoefficient1
        coefficient1
    else
      ok (pbDst, cbDstWritten, accumulator1, nBitsInAccumulator1,
        nBitsInCoefficient1, coefficient1)

/- [symcrust::ntt::SymCryptMlKemPolyElementCompressAndEncode::inner_loop]:
   Source: 'src/ntt.rs', lines 676:8-697:9 -/
@[reducible]
def ntt.SymCryptMlKemPolyElementCompressAndEncode.inner_loop
  (pbDst : Slice U8) (cbDstWritten : Usize) (accumulator : U32)
  (nBitsInAccumulator : U32) (nBitsInCoefficient : U32) (coefficient : U32) :
  Result ((Slice U8) × Usize × U32 × U32 × U32 × U32)
  :=
  ntt.SymCryptMlKemPolyElementCompressAndEncode.inner_loop_loop pbDst
    cbDstWritten accumulator nBitsInAccumulator nBitsInCoefficient coefficient

/- [symcrust::ntt::SymCryptMlKemPolyElementCompressAndEncode]: loop 0:
   Source: 'src/ntt.rs', lines 44:8-699:5 -/
divergent def ntt.SymCryptMlKemPolyElementCompressAndEncode_loop
  (peSrc : Array U16 256#usize) (nBitsPerCoefficient : U32) (pbDst : Slice U8)
  (cbDstWritten : Usize) (accumulator : U32) (nBitsInAccumulator : U32)
  (i : Usize) :
  Result (Slice U8)
  :=
  if i < ntt.MLWE_POLYNOMIAL_COEFFICIENTS
  then
    do
    let i1 ← Array.index_usize peSrc i
    let coefficient ← core.convert.IntoFrom.into core.convert.FromU32U16 i1
    massert (coefficient < ntt.Q)
    if nBitsPerCoefficient < 12#u32
    then
      do
      let i2 ← (↑(UScalar.cast .U64 coefficient) : Result _)
      let i3 ← (↑(UScalar.cast .U64 ntt.COMPRESS_MULCONSTANT) : Result _)
      let multiplication ← i2 * i3
      let i4 ← nBitsPerCoefficient + 1#u32
      let i5 ← ntt.COMPRESS_SHIFTCONSTANT - i4
      let i6 ← multiplication >>> i5
      let coefficient1 ← (↑(UScalar.cast .U32 i6) : Result _)
      let coefficient2 ← coefficient1 + 1#u32
      let coefficient3 ← coefficient2 >>> 1#i32
      let i7 ← 1#u32 <<< nBitsPerCoefficient
      massert (coefficient3 <= i7)
      let i8 ← i7 - 1#u32
      let coefficient4 ← (↑(coefficient3 &&& i8) : Result _)
      massert (coefficient4 < i7)
      let (pbDst1, cbDstWritten1, accumulator1, nBitsInAccumulator1, _, _) ←
        ntt.SymCryptMlKemPolyElementCompressAndEncode.inner_loop pbDst
          cbDstWritten accumulator nBitsInAccumulator nBitsPerCoefficient
          coefficient4
      let i9 ← i + 1#usize
      ntt.SymCryptMlKemPolyElementCompressAndEncode_loop peSrc
        nBitsPerCoefficient pbDst1 cbDstWritten1 accumulator1
        nBitsInAccumulator1 i9
    else
      do
      let (pbDst1, cbDstWritten1, accumulator1, nBitsInAccumulator1, _, _) ←
        ntt.SymCryptMlKemPolyElementCompressAndEncode.inner_loop pbDst
          cbDstWritten accumulator nBitsInAccumulator nBitsPerCoefficient
          coefficient
      let i2 ← i + 1#usize
      ntt.SymCryptMlKemPolyElementCompressAndEncode_loop peSrc
        nBitsPerCoefficient pbDst1 cbDstWritten1 accumulator1
        nBitsInAccumulator1 i2
  else
    do
    massert (nBitsInAccumulator = 0#u32)
    let i1 ←
      (↑(UScalar.cast .U32 ntt.MLWE_POLYNOMIAL_COEFFICIENTS) : Result _)
    let i2 ← i1 / 8#u32
    let i3 ← nBitsPerCoefficient * i2
    let i4 ← (↑(UScalar.cast .Usize i3) : Result _)
    massert (cbDstWritten = i4)
    ok pbDst

/- [symcrust::ntt::SymCryptMlKemPolyElementCompressAndEncode]:
   Source: 'src/ntt.rs', lines 633:0-703:1 -/
def ntt.SymCryptMlKemPolyElementCompressAndEncode
  (peSrc : Array U16 256#usize) (nBitsPerCoefficient : U32) (pbDst : Slice U8)
  :
  Result (Slice U8)
  :=
  do
  massert (nBitsPerCoefficient > 0#u32)
  massert (nBitsPerCoefficient <= 12#u32)
  ntt.SymCryptMlKemPolyElementCompressAndEncode_loop peSrc nBitsPerCoefficient
    pbDst 0#usize 0#u32 0#u32 0#usize

/- [symcrust::ntt::SymCryptMlKemPolyElementDecodeAndDecompress::inner_loop]: loop 0:
   Source: 'src/ntt.rs', lines 741:12-763:9 -/
divergent def ntt.SymCryptMlKemPolyElementDecodeAndDecompress.inner_loop_loop
  (pbSrc : Slice U8) (nBitsPerCoefficient : U32) (cbSrcRead : Usize)
  (accumulator : U32) (nBitsInAccumulator : U32) (coefficient : U32)
  (nBitsInCoefficient : U32) :
  Result (Usize × U32 × U32 × U32 × U32)
  :=
  if nBitsInAccumulator = 0#u32
  then
    do
    let a ← ntt.slice_to_sub_array 4#usize pbSrc cbSrcRead
    let accumulator1 ← (↑(core.num.U32.from_le_bytes a) : Result _)
    let cbSrcRead1 ← cbSrcRead + 4#usize
    let i ← nBitsPerCoefficient - nBitsInCoefficient
    let nBitsToDecode ← ntt.min i 32#u32
    massert (nBitsToDecode <= 32#u32)
    let i1 ← 1#u32 <<< nBitsToDecode
    let i2 ← i1 - 1#u32
    let bitsToDecode ← (↑(accumulator1 &&& i2) : Result _)
    let accumulator2 ← accumulator1 >>> nBitsToDecode
    let nBitsInAccumulator1 ← 32#u32 - nBitsToDecode
    let i3 ← bitsToDecode <<< nBitsInCoefficient
    let coefficient1 ← (↑(coefficient ||| i3) : Result _)
    let nBitsInCoefficient1 ← nBitsInCoefficient + nBitsToDecode
    if nBitsPerCoefficient > nBitsInCoefficient1
    then
      ntt.SymCryptMlKemPolyElementDecodeAndDecompress.inner_loop_loop pbSrc
        nBitsPerCoefficient cbSrcRead1 accumulator2 nBitsInAccumulator1
        coefficient1 nBitsInCoefficient1
    else
      ok (cbSrcRead1, accumulator2, nBitsInAccumulator1, coefficient1,
        nBitsInCoefficient1)
  else
    do
    let i ← nBitsPerCoefficient - nBitsInCoefficient
    let nBitsToDecode ← ntt.min i nBitsInAccumulator
    massert (nBitsToDecode <= nBitsInAccumulator)
    let i1 ← 1#u32 <<< nBitsToDecode
    let i2 ← i1 - 1#u32
    let bitsToDecode ← (↑(accumulator &&& i2) : Result _)
    let accumulator1 ← accumulator >>> nBitsToDecode
    let nBitsInAccumulator1 ← nBitsInAccumulator - nBitsToDecode
    let i3 ← bitsToDecode <<< nBitsInCoefficient
    let coefficient1 ← (↑(coefficient ||| i3) : Result _)
    let nBitsInCoefficient1 ← nBitsInCoefficient + nBitsToDecode
    if nBitsPerCoefficient > nBitsInCoefficient1
    then
      ntt.SymCryptMlKemPolyElementDecodeAndDecompress.inner_loop_loop pbSrc
        nBitsPerCoefficient cbSrcRead accumulator1 nBitsInAccumulator1
        coefficient1 nBitsInCoefficient1
    else
      ok (cbSrcRead, accumulator1, nBitsInAccumulator1, coefficient1,
        nBitsInCoefficient1)

/- [symcrust::ntt::SymCryptMlKemPolyElementDecodeAndDecompress::inner_loop]:
   Source: 'src/ntt.rs', lines 737:8-763:9 -/
@[reducible]
def ntt.SymCryptMlKemPolyElementDecodeAndDecompress.inner_loop
  (pbSrc : Slice U8) (nBitsPerCoefficient : U32) (cbSrcRead : Usize)
  (accumulator : U32) (nBitsInAccumulator : U32) (coefficient : U32)
  (nBitsInCoefficient : U32) :
  Result (Usize × U32 × U32 × U32 × U32)
  :=
  ntt.SymCryptMlKemPolyElementDecodeAndDecompress.inner_loop_loop pbSrc
    nBitsPerCoefficient cbSrcRead accumulator nBitsInAccumulator coefficient
    nBitsInCoefficient

/- [symcrust::ntt::SymCryptMlKemPolyElementDecodeAndDecompress]: loop 0:
   Source: 'src/ntt.rs', lines 44:8-802:1 -/
divergent def ntt.SymCryptMlKemPolyElementDecodeAndDecompress_loop
  (pbSrc : Slice U8) (nBitsPerCoefficient : U32) (peDst : Array U16 256#usize)
  (cbSrcRead : Usize) (accumulator : U32) (nBitsInAccumulator : U32)
  (i : Usize) :
  Result (ntt.MLKEM_ERROR × (Array U16 256#usize))
  :=
  if i < ntt.MLWE_POLYNOMIAL_COEFFICIENTS
  then
    do
    let (cbSrcRead1, accumulator1, nBitsInAccumulator1, coefficient,
      nBitsInCoefficient) ←
      ntt.SymCryptMlKemPolyElementDecodeAndDecompress.inner_loop pbSrc
        nBitsPerCoefficient cbSrcRead accumulator nBitsInAccumulator 0#u32
        0#u32
    massert (nBitsInCoefficient = nBitsPerCoefficient)
    if nBitsPerCoefficient < 12#u32
    then
      do
      let coefficient1 ← coefficient * ntt.Q
      let i1 ← nBitsPerCoefficient - 1#u32
      let coefficient2 ← coefficient1 >>> i1
      let coefficient3 ← coefficient2 + 1#u32
      let coefficient4 ← coefficient3 >>> 1#i32
      let coefficient5 ← ntt.SymCryptMlKemModSub coefficient4 ntt.Q
      massert (coefficient5 < ntt.Q)
      let i2 ← (↑(UScalar.cast .U16 coefficient5) : Result _)
      let peDst1 ← Array.update peDst i i2
      let i3 ← i + 1#usize
      ntt.SymCryptMlKemPolyElementDecodeAndDecompress_loop pbSrc
        nBitsPerCoefficient peDst1 cbSrcRead1 accumulator1 nBitsInAccumulator1
        i3
    else
      if coefficient > ntt.Q
      then ok (ntt.MLKEM_ERROR.INVALID_BLOB, peDst)
      else
        do
        let i1 ← (↑(UScalar.cast .U16 coefficient) : Result _)
        let peDst1 ← Array.update peDst i i1
        let i2 ← i + 1#usize
        ntt.SymCryptMlKemPolyElementDecodeAndDecompress_loop pbSrc
          nBitsPerCoefficient peDst1 cbSrcRead1 accumulator1
          nBitsInAccumulator1 i2
  else
    do
    massert (nBitsInAccumulator = 0#u32)
    let i1 ←
      (↑(UScalar.cast .U32 ntt.MLWE_POLYNOMIAL_COEFFICIENTS) : Result _)
    let i2 ← i1 / 8#u32
    let i3 ← nBitsPerCoefficient * i2
    let i4 ← (↑(UScalar.cast .Usize i3) : Result _)
    massert (cbSrcRead = i4)
    ok (ntt.MLKEM_ERROR.NO_ERROR, peDst)

/- [symcrust::ntt::SymCryptMlKemPolyElementDecodeAndDecompress]:
   Source: 'src/ntt.rs', lines 715:0-802:1 -/
def ntt.SymCryptMlKemPolyElementDecodeAndDecompress
  (pbSrc : Slice U8) (nBitsPerCoefficient : U32) (peDst : Array U16 256#usize)
  :
  Result (ntt.MLKEM_ERROR × (Array U16 256#usize))
  :=
  do
  massert (nBitsPerCoefficient > 0#u32)
  massert (nBitsPerCoefficient <= 12#u32)
  ntt.SymCryptMlKemPolyElementDecodeAndDecompress_loop pbSrc
    nBitsPerCoefficient peDst 0#usize 0#u32 0#u32 0#usize

/- [symcrust::ntt::SymCryptMlKemPolyElementSampleNTTFromShake128]: loop 0:
   Source: 'src/ntt.rs', lines 822:4-845:5 -/
divergent def ntt.SymCryptMlKemPolyElementSampleNTTFromShake128_loop
  (pState : Array U8 0#usize) (peDst : Array U16 256#usize) (i : Usize)
  (shakeOutputBuf : Array U8 24#usize) (currBufIndex : Usize) :
  Result ((Array U8 0#usize) × (Array U16 256#usize))
  :=
  if i < ntt.MLWE_POLYNOMIAL_COEFFICIENTS
  then
    do
    let s ← (↑(Array.to_slice shakeOutputBuf) : Result _)
    let i1 := Slice.len s
    massert (currBufIndex <= i1)
    let s1 ← (↑(Array.to_slice shakeOutputBuf) : Result _)
    let i2 := Slice.len s1
    if currBufIndex = i2
    then
      do
      let (s2, to_slice_mut_back) ←
        (↑(Array.to_slice_mut shakeOutputBuf) : Result _)
      let (pState1, s3) ← ntt.SymCryptShake128Extract pState s2 false
      let shakeOutputBuf1 := to_slice_mut_back s3
      let s4 ← (↑(Array.to_slice shakeOutputBuf1) : Result _)
      let a ← ntt.slice_to_sub_array 2#usize s4 0#usize
      let i3 ← (↑(core.num.U16.from_le_bytes a) : Result _)
      let sample0 ← (↑(i3 &&& 4095#u16) : Result _)
      let s5 ← (↑(Array.to_slice shakeOutputBuf1) : Result _)
      let i4 ← 0#usize + 1#usize
      let a1 ← ntt.slice_to_sub_array 2#usize s5 i4
      let i5 ← (↑(core.num.U16.from_le_bytes a1) : Result _)
      let sample1 ← i5 >>> 4#i32
      let currBufIndex1 ← 0#usize + 3#usize
      let i6 ← (↑(UScalar.cast .U32 sample0) : Result _)
      let i7 ← (↑(UScalar.cast_fromBool .Usize (i6 < ntt.Q)) : Result _)
      let i8 ← i + i7
      if i8 < ntt.MLWE_POLYNOMIAL_COEFFICIENTS
      then
        do
        let peDst1 ← Array.update peDst i sample0
        let peDst2 ← Array.update peDst1 i8 sample1
        let i9 ← (↑(UScalar.cast .U32 sample1) : Result _)
        let i10 ← (↑(UScalar.cast_fromBool .Usize (i9 < ntt.Q)) : Result _)
        let i11 ← i8 + i10
        ntt.SymCryptMlKemPolyElementSampleNTTFromShake128_loop pState1 peDst2
          i11 shakeOutputBuf1 currBufIndex1
      else
        do
        let peDst1 ← Array.update peDst i sample0
        ntt.SymCryptMlKemPolyElementSampleNTTFromShake128_loop pState1 peDst1
          i8 shakeOutputBuf1 currBufIndex1
    else
      do
      let s2 ← (↑(Array.to_slice shakeOutputBuf) : Result _)
      let a ← ntt.slice_to_sub_array 2#usize s2 currBufIndex
      let i3 ← (↑(core.num.U16.from_le_bytes a) : Result _)
      let sample0 ← (↑(i3 &&& 4095#u16) : Result _)
      let s3 ← (↑(Array.to_slice shakeOutputBuf) : Result _)
      let i4 ← currBufIndex + 1#usize
      let a1 ← ntt.slice_to_sub_array 2#usize s3 i4
      let i5 ← (↑(core.num.U16.from_le_bytes a1) : Result _)
      let sample1 ← i5 >>> 4#i32
      let currBufIndex1 ← currBufIndex + 3#usize
      let i6 ← (↑(UScalar.cast .U32 sample0) : Result _)
      let i7 ← (↑(UScalar.cast_fromBool .Usize (i6 < ntt.Q)) : Result _)
      let i8 ← i + i7
      if i8 < ntt.MLWE_POLYNOMIAL_COEFFICIENTS
      then
        do
        let peDst1 ← Array.update peDst i sample0
        let peDst2 ← Array.update peDst1 i8 sample1
        let i9 ← (↑(UScalar.cast .U32 sample1) : Result _)
        let i10 ← (↑(UScalar.cast_fromBool .Usize (i9 < ntt.Q)) : Result _)
        let i11 ← i8 + i10
        ntt.SymCryptMlKemPolyElementSampleNTTFromShake128_loop pState peDst2
          i11 shakeOutputBuf currBufIndex1
      else
        do
        let peDst1 ← Array.update peDst i sample0
        ntt.SymCryptMlKemPolyElementSampleNTTFromShake128_loop pState peDst1 i8
          shakeOutputBuf currBufIndex1
  else ok (pState, peDst)

/- [symcrust::ntt::SymCryptMlKemPolyElementSampleNTTFromShake128]:
   Source: 'src/ntt.rs', lines 814:0-846:1 -/
def ntt.SymCryptMlKemPolyElementSampleNTTFromShake128
  (pState : Array U8 0#usize) (peDst : Array U16 256#usize) :
  Result ((Array U8 0#usize) × (Array U16 256#usize))
  :=
  do
  let shakeOutputBuf := Array.repeat 24#usize 0#u8
  let s ← (↑(Array.to_slice shakeOutputBuf) : Result _)
  let currBufIndex := Slice.len s
  ntt.SymCryptMlKemPolyElementSampleNTTFromShake128_loop pState peDst 0#usize
    shakeOutputBuf currBufIndex

/- [symcrust::ntt::SymCryptMlKemPolyElementSampleCBDFromBytes::else_inner_loop]: loop 0:
   Source: 'src/ntt.rs', lines 44:8-915:24 -/
divergent def
  ntt.SymCryptMlKemPolyElementSampleCBDFromBytes.else_inner_loop_loop
  (peDst : Array U16 256#usize) (i : Usize) (sampleBits : U32) (j : Usize) :
  Result ((Array U16 256#usize) × U32)
  :=
  if j < 8#usize
  then
    do
    let coefficient ← (↑(sampleBits &&& 15#u32) : Result _)
    let sampleBits1 ← sampleBits >>> 4#i32
    let i1 ← (↑(coefficient &&& 3#u32) : Result _)
    let i2 ← coefficient >>> 2#i32
    let coefficient1 ← i1 - i2
    let i3 ← (↑(IScalar.hcast .U32 (-2)#i32) : Result _)
    if coefficient1 >= i3
    then
      do
      let i4 ← coefficient1 >>> 16#i32
      let i5 ← (↑(ntt.Q &&& i4) : Result _)
      let coefficient2 ← coefficient1 + i5
      massert (coefficient2 < ntt.Q)
      let i6 ← i + j
      let i7 ← (↑(UScalar.cast .U16 coefficient2) : Result _)
      let peDst1 ← Array.update peDst i6 i7
      let j1 ← j + 1#usize
      ntt.SymCryptMlKemPolyElementSampleCBDFromBytes.else_inner_loop_loop
        peDst1 i sampleBits1 j1
    else
      do
      massert (coefficient1 <= 2#u32)
      let i4 ← coefficient1 >>> 16#i32
      let i5 ← (↑(ntt.Q &&& i4) : Result _)
      let coefficient2 ← coefficient1 + i5
      massert (coefficient2 < ntt.Q)
      let i6 ← i + j
      let i7 ← (↑(UScalar.cast .U16 coefficient2) : Result _)
      let peDst1 ← Array.update peDst i6 i7
      let j1 ← j + 1#usize
      ntt.SymCryptMlKemPolyElementSampleCBDFromBytes.else_inner_loop_loop
        peDst1 i sampleBits1 j1
  else ok (peDst, sampleBits)

/- [symcrust::ntt::SymCryptMlKemPolyElementSampleCBDFromBytes::else_inner_loop]:
   Source: 'src/ntt.rs', lines 901:12-916:13 -/
@[reducible]
def ntt.SymCryptMlKemPolyElementSampleCBDFromBytes.else_inner_loop
  (peDst : Array U16 256#usize) (i : Usize) (sampleBits : U32) :
  Result ((Array U16 256#usize) × U32)
  :=
  ntt.SymCryptMlKemPolyElementSampleCBDFromBytes.else_inner_loop_loop peDst i
    sampleBits 0#usize

/- [symcrust::ntt::SymCryptMlKemPolyElementSampleCBDFromBytes::then_inner_loop]: loop 0:
   Source: 'src/ntt.rs', lines 44:8-884:24 -/
divergent def
  ntt.SymCryptMlKemPolyElementSampleCBDFromBytes.then_inner_loop_loop
  (peDst : Array U16 256#usize) (i : Usize) (sampleBits : U32) (j : Usize) :
  Result ((Array U16 256#usize) × U32)
  :=
  if j < 4#usize
  then
    do
    let coefficient ← (↑(sampleBits &&& 63#u32) : Result _)
    let sampleBits1 ← sampleBits >>> 6#i32
    let i1 ← (↑(coefficient &&& 3#u32) : Result _)
    let i2 ← coefficient >>> 3#i32
    let coefficient1 ← i1 - i2
    let i3 ← (↑(IScalar.hcast .U32 (-3)#i32) : Result _)
    if coefficient1 >= i3
    then
      do
      let i4 ← coefficient1 >>> 16#i32
      let i5 ← (↑(ntt.Q &&& i4) : Result _)
      let coefficient2 ← coefficient1 + i5
      massert (coefficient2 < ntt.Q)
      let i6 ← i + j
      let i7 ← (↑(UScalar.cast .U16 coefficient2) : Result _)
      let peDst1 ← Array.update peDst i6 i7
      let j1 ← j + 1#usize
      ntt.SymCryptMlKemPolyElementSampleCBDFromBytes.then_inner_loop_loop
        peDst1 i sampleBits1 j1
    else
      do
      massert (coefficient1 <= 3#u32)
      let i4 ← coefficient1 >>> 16#i32
      let i5 ← (↑(ntt.Q &&& i4) : Result _)
      let coefficient2 ← coefficient1 + i5
      massert (coefficient2 < ntt.Q)
      let i6 ← i + j
      let i7 ← (↑(UScalar.cast .U16 coefficient2) : Result _)
      let peDst1 ← Array.update peDst i6 i7
      let j1 ← j + 1#usize
      ntt.SymCryptMlKemPolyElementSampleCBDFromBytes.then_inner_loop_loop
        peDst1 i sampleBits1 j1
  else ok (peDst, sampleBits)

/- [symcrust::ntt::SymCryptMlKemPolyElementSampleCBDFromBytes::then_inner_loop]:
   Source: 'src/ntt.rs', lines 870:12-885:13 -/
@[reducible]
def ntt.SymCryptMlKemPolyElementSampleCBDFromBytes.then_inner_loop
  (peDst : Array U16 256#usize) (i : Usize) (sampleBits : U32) :
  Result ((Array U16 256#usize) × U32)
  :=
  ntt.SymCryptMlKemPolyElementSampleCBDFromBytes.then_inner_loop_loop peDst i
    sampleBits 0#usize

/- [symcrust::ntt::SymCryptMlKemPolyElementSampleCBDFromBytes]: loop 0:
   Source: 'src/ntt.rs', lines 44:8-887:9 -/
divergent def ntt.SymCryptMlKemPolyElementSampleCBDFromBytes_loop0
  (pbSrc : Slice U8) (peDst : Array U16 256#usize) (src_i : Usize) (i : Usize)
  :
  Result (Array U16 256#usize)
  :=
  if i < ntt.MLWE_POLYNOMIAL_COEFFICIENTS
  then
    do
    let a ← ntt.slice_to_sub_array 4#usize pbSrc src_i
    let sampleBits ← (↑(core.num.U32.from_le_bytes a) : Result _)
    let src_i1 ← src_i + 3#usize
    let i1 ← (↑(sampleBits &&& 2396745#u32) : Result _)
    let i2 ← sampleBits >>> 1#i32
    let i3 ← (↑(i2 &&& 2396745#u32) : Result _)
    let i4 ← i1 + i3
    let i5 ← sampleBits >>> 2#i32
    let i6 ← (↑(i5 &&& 2396745#u32) : Result _)
    let sampleBits1 ← i4 + i6
    let (peDst1, _) ←
      ntt.SymCryptMlKemPolyElementSampleCBDFromBytes.then_inner_loop peDst i
        sampleBits1
    let i7 ← i + 1#usize
    ntt.SymCryptMlKemPolyElementSampleCBDFromBytes_loop0 pbSrc peDst1 src_i1 i7
  else ok peDst

/- [symcrust::ntt::SymCryptMlKemPolyElementSampleCBDFromBytes]: loop 1:
   Source: 'src/ntt.rs', lines 44:8-918:9 -/
divergent def ntt.SymCryptMlKemPolyElementSampleCBDFromBytes_loop1
  (pbSrc : Slice U8) (peDst : Array U16 256#usize) (src_i : Usize) (i : Usize)
  :
  Result (Array U16 256#usize)
  :=
  if i < ntt.MLWE_POLYNOMIAL_COEFFICIENTS
  then
    do
    let a ← ntt.slice_to_sub_array 4#usize pbSrc src_i
    let sampleBits ← (↑(core.num.U32.from_le_bytes a) : Result _)
    let src_i1 ← src_i + 4#usize
    let i1 ← (↑(sampleBits &&& 1431655765#u32) : Result _)
    let i2 ← sampleBits >>> 1#i32
    let i3 ← (↑(i2 &&& 1431655765#u32) : Result _)
    let sampleBits1 ← i1 + i3
    let (peDst1, _) ←
      ntt.SymCryptMlKemPolyElementSampleCBDFromBytes.else_inner_loop peDst i
        sampleBits1
    let i4 ← i + 1#usize
    ntt.SymCryptMlKemPolyElementSampleCBDFromBytes_loop1 pbSrc peDst1 src_i1 i4
  else ok peDst

/- [symcrust::ntt::SymCryptMlKemPolyElementSampleCBDFromBytes]: loop 2:
   Source: 'src/ntt.rs', lines 44:8-887:9 -/
divergent def ntt.SymCryptMlKemPolyElementSampleCBDFromBytes_loop2
  (pbSrc : Slice U8) (peDst : Array U16 256#usize) (src_i : Usize) (i : Usize)
  :
  Result (Array U16 256#usize)
  :=
  if i < ntt.MLWE_POLYNOMIAL_COEFFICIENTS
  then
    do
    let a ← ntt.slice_to_sub_array 4#usize pbSrc src_i
    let sampleBits ← (↑(core.num.U32.from_le_bytes a) : Result _)
    let src_i1 ← src_i + 3#usize
    let i1 ← (↑(sampleBits &&& 2396745#u32) : Result _)
    let i2 ← sampleBits >>> 1#i32
    let i3 ← (↑(i2 &&& 2396745#u32) : Result _)
    let i4 ← i1 + i3
    let i5 ← sampleBits >>> 2#i32
    let i6 ← (↑(i5 &&& 2396745#u32) : Result _)
    let sampleBits1 ← i4 + i6
    let (peDst1, _) ←
      ntt.SymCryptMlKemPolyElementSampleCBDFromBytes.then_inner_loop peDst i
        sampleBits1
    let i7 ← i + 1#usize
    ntt.SymCryptMlKemPolyElementSampleCBDFromBytes_loop2 pbSrc peDst1 src_i1 i7
  else ok peDst

/- [symcrust::ntt::SymCryptMlKemPolyElementSampleCBDFromBytes]: loop 3:
   Source: 'src/ntt.rs', lines 44:8-918:9 -/
divergent def ntt.SymCryptMlKemPolyElementSampleCBDFromBytes_loop3
  (pbSrc : Slice U8) (peDst : Array U16 256#usize) (src_i : Usize) (i : Usize)
  :
  Result (Array U16 256#usize)
  :=
  if i < ntt.MLWE_POLYNOMIAL_COEFFICIENTS
  then
    do
    let a ← ntt.slice_to_sub_array 4#usize pbSrc src_i
    let sampleBits ← (↑(core.num.U32.from_le_bytes a) : Result _)
    let src_i1 ← src_i + 4#usize
    let i1 ← (↑(sampleBits &&& 1431655765#u32) : Result _)
    let i2 ← sampleBits >>> 1#i32
    let i3 ← (↑(i2 &&& 1431655765#u32) : Result _)
    let sampleBits1 ← i1 + i3
    let (peDst1, _) ←
      ntt.SymCryptMlKemPolyElementSampleCBDFromBytes.else_inner_loop peDst i
        sampleBits1
    let i4 ← i + 1#usize
    ntt.SymCryptMlKemPolyElementSampleCBDFromBytes_loop3 pbSrc peDst1 src_i1 i4
  else ok peDst

/- [symcrust::ntt::SymCryptMlKemPolyElementSampleCBDFromBytes]:
   Source: 'src/ntt.rs', lines 848:0-920:1 -/
def ntt.SymCryptMlKemPolyElementSampleCBDFromBytes
  (pbSrc : Slice U8) (eta : U32) (peDst : Array U16 256#usize) :
  Result (Array U16 256#usize)
  :=
  if eta = 2#u32
  then
    if eta = 3#u32
    then
      ntt.SymCryptMlKemPolyElementSampleCBDFromBytes_loop0 pbSrc peDst 0#usize
        0#usize
    else
      ntt.SymCryptMlKemPolyElementSampleCBDFromBytes_loop1 pbSrc peDst 0#usize
        0#usize
  else
    do
    massert (eta = 3#u32)
    if eta = 3#u32
    then
      ntt.SymCryptMlKemPolyElementSampleCBDFromBytes_loop2 pbSrc peDst 0#usize
        0#usize
    else
      ntt.SymCryptMlKemPolyElementSampleCBDFromBytes_loop3 pbSrc peDst 0#usize
        0#usize

/- [symcrust::ntt::SymCryptMlKemMatrixTranspose::inner_loop]: loop 0:
   Source: 'src/ntt.rs', lines 44:8-952:13 -/
divergent def ntt.SymCryptMlKemMatrixTranspose.inner_loop_loop
  (i : Usize) (a : Array (Array U16 256#usize) 16#usize) (nRows : Usize)
  (i1 : Usize) (j : Usize) :
  Result (ntt.MATRIX × (ntt.MATRIX → Array (Array U16 256#usize) 16#usize))
  :=
  if j < nRows
  then
    do
    let i2 ← i1 * nRows
    let i3 ← i2 + j
    let i4 ← j * nRows
    let i5 ← i4 + i1
    let (m, swap_back) ←
      ntt.MATRIX.swap { nRows := i, apPolyElements := a } i3 i5
    let j1 ← j + 1#usize
    let (m1, back) ←
      ntt.SymCryptMlKemMatrixTranspose.inner_loop_loop m.nRows m.apPolyElements
        nRows i1 j1
    let back1 :=
      fun ret =>
        let a1 := back ret
        (swap_back { m with apPolyElements := a1 }).apPolyElements
    ok (m1, back1)
  else
    let back := fun ret => ret.apPolyElements
    ok ({ nRows := i, apPolyElements := a }, back)

/- [symcrust::ntt::SymCryptMlKemMatrixTranspose::inner_loop]:
   Source: 'src/ntt.rs', lines 948:8-954:9 -/
def ntt.SymCryptMlKemMatrixTranspose.inner_loop
  (pmSrc : ntt.MATRIX) (nRows : Usize) (i : Usize) :
  Result (ntt.MATRIX × (ntt.MATRIX → ntt.MATRIX))
  :=
  do
  let j ← i + 1#usize
  let (m, back) ←
    ntt.SymCryptMlKemMatrixTranspose.inner_loop_loop pmSrc.nRows
      pmSrc.apPolyElements nRows i j
  let back1 := fun ret => let a := back ret
                          { pmSrc with apPolyElements := a }
  ok (m, back1)

/- [symcrust::ntt::SymCryptMlKemMatrixTranspose]: loop 0:
   Source: 'src/ntt.rs', lines 44:8-956:5 -/
divergent def ntt.SymCryptMlKemMatrixTranspose_loop
  (nRows : Usize) (a : Array (Array U16 256#usize) 16#usize) (nRows1 : Usize)
  (i : Usize) :
  Result (ntt.MATRIX × (ntt.MATRIX → Array (Array U16 256#usize) 16#usize))
  :=
  if i < nRows1
  then
    do
    let (m, inner_loop_back) ←
      ntt.SymCryptMlKemMatrixTranspose.inner_loop
        { nRows, apPolyElements := a } nRows1 i
    let i1 ← i + 1#usize
    let (m1, back) ←
      ntt.SymCryptMlKemMatrixTranspose_loop m.nRows m.apPolyElements nRows1 i1
    let back1 :=
      fun ret =>
        let a1 := back ret
        (inner_loop_back { m with apPolyElements := a1 }).apPolyElements
    ok (m1, back1)
  else
    let back := fun ret => ret.apPolyElements
    ok ({ nRows, apPolyElements := a }, back)

/- [symcrust::ntt::SymCryptMlKemMatrixTranspose]:
   Source: 'src/ntt.rs', lines 936:0-958:1 -/
def ntt.SymCryptMlKemMatrixTranspose
  (pmSrc : ntt.MATRIX) : Result (ntt.MATRIX × (ntt.MATRIX → ntt.MATRIX)) :=
  do
  massert (pmSrc.nRows > 0#usize)
  massert (pmSrc.nRows <= ntt.MATRIX_MAX_NROWS)
  let (m, back) ←
    ntt.SymCryptMlKemMatrixTranspose_loop pmSrc.nRows pmSrc.apPolyElements
      pmSrc.nRows 0#usize
  let back1 := fun ret => let a := back ret
                          { pmSrc with apPolyElements := a }
  ok (m, back1)

/- [symcrust::ntt::SymCryptMlKemMatrixVectorMontMulAndAdd::inner_loop]: loop 0:
   Source: 'src/ntt.rs', lines 44:8-1008:13 -/
divergent def ntt.SymCryptMlKemMatrixVectorMontMulAndAdd.inner_loop_loop
  (i : Usize) (a : Array (Array U16 256#usize) 16#usize)
  (pvSrc2 : Slice (Array U16 256#usize)) (paTmp : Array U32 256#usize)
  (nRows : Usize) (i1 : Usize) (j : Usize) :
  Result (ntt.MATRIX × (ntt.MATRIX → Array (Array U16 256#usize) 16#usize)
    × (Array U32 256#usize))
  :=
  if j < nRows
  then
    do
    let a1 ← Slice.index_usize pvSrc2 i1
    let (m, SymCryptMlKemPolyElementMulAndAccumulate_aux_back, paTmp1) ←
      ntt.SymCryptMlKemPolyElementMulAndAccumulate_aux
        { nRows := i, apPolyElements := a } nRows i1 j a1 paTmp
    let j1 ← j + 1#usize
    let (m1, back'a, paTmp2) ←
      ntt.SymCryptMlKemMatrixVectorMontMulAndAdd.inner_loop_loop m.nRows
        m.apPolyElements pvSrc2 paTmp1 nRows i1 j1
    let back'a1 :=
      fun ret =>
        let a2 := back'a ret
        (SymCryptMlKemPolyElementMulAndAccumulate_aux_back
           { m with apPolyElements := a2 }).apPolyElements
    ok (m1, back'a1, paTmp2)
  else
    let back'a := fun ret => ret.apPolyElements
    ok ({ nRows := i, apPolyElements := a }, back'a, paTmp)

/- [symcrust::ntt::SymCryptMlKemMatrixVectorMontMulAndAdd::inner_loop]:
   Source: 'src/ntt.rs', lines 999:8-1010:9 -/
def ntt.SymCryptMlKemMatrixVectorMontMulAndAdd.inner_loop
  (pmSrc1 : ntt.MATRIX) (pvSrc2 : Slice (Array U16 256#usize))
  (paTmp : Array U32 256#usize) (nRows : Usize) (i : Usize) :
  Result (ntt.MATRIX × (ntt.MATRIX → ntt.MATRIX) × (Array U32 256#usize))
  :=
  do
  let (m, back'a, paTmp1) ←
    ntt.SymCryptMlKemMatrixVectorMontMulAndAdd.inner_loop_loop pmSrc1.nRows
      pmSrc1.apPolyElements pvSrc2 paTmp nRows i 0#usize
  let back'a1 :=
    fun ret => let a := back'a ret
               { pmSrc1 with apPolyElements := a }
  ok (m, back'a1, paTmp1)

/- [symcrust::ntt::SymCryptMlKemMatrixVectorMontMulAndAdd]: loop 0:
   Source: 'src/ntt.rs', lines 44:8-1015:5 -/
divergent def ntt.SymCryptMlKemMatrixVectorMontMulAndAdd_loop
  (nRows : Usize) (a : Array (Array U16 256#usize) 16#usize)
  (pvSrc2 : Slice (Array U16 256#usize)) (pvDst : Slice (Array U16 256#usize))
  (paTmp : Array U32 256#usize) (nRows1 : Usize) (i : Usize) :
  Result (ntt.MATRIX × (ntt.MATRIX → Array (Array U16 256#usize) 16#usize)
    × (Slice (Array U16 256#usize)) × (Array U32 256#usize))
  :=
  if i < nRows1
  then
    do
    let (m, inner_loop_back, paTmp1) ←
      ntt.SymCryptMlKemMatrixVectorMontMulAndAdd.inner_loop
        { nRows, apPolyElements := a } pvSrc2 paTmp nRows1 i
    let (a1, index_mut_back) ← Slice.index_mut_usize pvDst i
    let (paTmp2, a2) ←
      ntt.SymCryptMlKemMontgomeryReduceAndAddPolyElementAccumulatorToPolyElement
        paTmp1 a1
    let i1 ← i + 1#usize
    let pvDst1 := index_mut_back a2
    let (m1, back'a, pvDst2, paTmp3) ←
      ntt.SymCryptMlKemMatrixVectorMontMulAndAdd_loop m.nRows m.apPolyElements
        pvSrc2 pvDst1 paTmp2 nRows1 i1
    let back'a1 :=
      fun ret =>
        let a3 := back'a ret
        (inner_loop_back { m with apPolyElements := a3 }).apPolyElements
    ok (m1, back'a1, pvDst2, paTmp3)
  else
    let back'a := fun ret => ret.apPolyElements
    ok ({ nRows, apPolyElements := a }, back'a, pvDst, paTmp)

/- [symcrust::ntt::SymCryptMlKemMatrixVectorMontMulAndAdd]:
   Source: 'src/ntt.rs', lines 977:0-1017:1 -/
def ntt.SymCryptMlKemMatrixVectorMontMulAndAdd
  (pmSrc1 : ntt.MATRIX) (pvSrc2 : Slice (Array U16 256#usize))
  (pvDst : Slice (Array U16 256#usize)) (paTmp : Array U32 256#usize) :
  Result (ntt.MATRIX × (ntt.MATRIX → ntt.MATRIX) × (Slice (Array U16
    256#usize)) × (Array U32 256#usize))
  :=
  do
  massert (pmSrc1.nRows > 0#usize)
  massert (pmSrc1.nRows <= ntt.MATRIX_MAX_NROWS)
  let i := Slice.len pvSrc2
  massert (i = pmSrc1.nRows)
  let i1 := Slice.len pvDst
  massert (i1 = pmSrc1.nRows)
  let (m, back'a, pvDst1, paTmp1) ←
    ntt.SymCryptMlKemMatrixVectorMontMulAndAdd_loop pmSrc1.nRows
      pmSrc1.apPolyElements pvSrc2 pvDst paTmp pmSrc1.nRows 0#usize
  let back'a1 :=
    fun ret => let a := back'a ret
               { pmSrc1 with apPolyElements := a }
  ok (m, back'a1, pvDst1, paTmp1)

/- [symcrust::ntt::SymCryptMlKemVectorMontDotProduct]: loop 0:
   Source: 'src/ntt.rs', lines 44:8-1041:5 -/
divergent def ntt.SymCryptMlKemVectorMontDotProduct_loop
  (pvSrc1 : Slice (Array U16 256#usize)) (pvSrc2 : Slice (Array U16 256#usize))
  (peDst : Array U16 256#usize) (paTmp : Array U32 256#usize) (nRows : Usize)
  (i : Usize) :
  Result (Array U32 256#usize)
  :=
  if i < nRows
  then
    do
    let a ← Slice.index_usize pvSrc1 i
    let a1 ← Slice.index_usize pvSrc2 i
    let paTmp1 ← ntt.SymCryptMlKemPolyElementMulAndAccumulate a a1 paTmp
    let i1 ← i + 1#usize
    ntt.SymCryptMlKemVectorMontDotProduct_loop pvSrc1 pvSrc2 peDst paTmp1 nRows
      i1
  else
    do
    let (paTmp1, _) ←
      ntt.SymCryptMlKemMontgomeryReduceAndAddPolyElementAccumulatorToPolyElement
        paTmp peDst
    ok paTmp1

/- [symcrust::ntt::SymCryptMlKemVectorMontDotProduct]:
   Source: 'src/ntt.rs', lines 1020:0-1045:1 -/
def ntt.SymCryptMlKemVectorMontDotProduct
  (pvSrc1 : Slice (Array U16 256#usize)) (pvSrc2 : Slice (Array U16 256#usize))
  (peDst : Array U16 256#usize) (paTmp : Array U32 256#usize) :
  Result ((Slice (Array U16 256#usize)) × (Slice (Array U16 256#usize)) ×
    (Array U16 256#usize) × (Array U32 256#usize))
  :=
  do
  let nRows := Slice.len pvSrc1
  massert (nRows > 0#usize)
  massert (nRows <= ntt.MATRIX_MAX_NROWS)
  let i := Slice.len pvSrc2
  massert (i = nRows)
  let paTmp1 ←
    ntt.SymCryptMlKemVectorMontDotProduct_loop pvSrc1 pvSrc2 peDst paTmp nRows
      0#usize
  ok (pvSrc1, pvSrc2, peDst, paTmp1)

/- [symcrust::ntt::SymCryptMlKemVectorSetZero]:
   Source: 'src/ntt.rs', lines 1047:0-1059:1 -/
def ntt.SymCryptMlKemVectorSetZero
  (pvSrc : Slice (Array U16 256#usize)) :
  Result (Slice (Array U16 256#usize))
  :=
  do
  let nRows := Slice.len pvSrc
  massert (nRows > 0#usize)
  massert (nRows <= ntt.MATRIX_MAX_NROWS)
  ok pvSrc

/- [symcrust::ntt::SymCryptMlKemVectorMulR]: loop 0:
   Source: 'src/ntt.rs', lines 44:8-1075:5 -/
divergent def ntt.SymCryptMlKemVectorMulR_loop
  (pvSrc : Slice (Array U16 256#usize)) (pvDst : Slice (Array U16 256#usize))
  (nRows : Usize) (i : Usize) :
  Result (Slice (Array U16 256#usize))
  :=
  if i < nRows
  then
    do
    let a ← Slice.index_usize pvSrc i
    let (a1, index_mut_back) ← Slice.index_mut_usize pvDst i
    let a2 ← ntt.SymCryptMlKemPolyElementMulR a a1
    let i1 ← i + 1#usize
    let pvDst1 := index_mut_back a2
    ntt.SymCryptMlKemVectorMulR_loop pvSrc pvDst1 nRows i1
  else ok pvDst

/- [symcrust::ntt::SymCryptMlKemVectorMulR]:
   Source: 'src/ntt.rs', lines 1061:0-1076:1 -/
def ntt.SymCryptMlKemVectorMulR
  (pvSrc : Slice (Array U16 256#usize)) (pvDst : Slice (Array U16 256#usize)) :
  Result (Slice (Array U16 256#usize))
  :=
  do
  let nRows := Slice.len pvSrc
  massert (nRows > 0#usize)
  massert (nRows <= ntt.MATRIX_MAX_NROWS)
  let i := Slice.len pvDst
  massert (i = nRows)
  ntt.SymCryptMlKemVectorMulR_loop pvSrc pvDst nRows 0#usize

/- [symcrust::ntt::SymCryptMlKemVectorAdd]: loop 0:
   Source: 'src/ntt.rs', lines 44:8-1094:5 -/
divergent def ntt.SymCryptMlKemVectorAdd_loop
  (pvSrc1 : Slice (Array U16 256#usize)) (pvSrc2 : Slice (Array U16 256#usize))
  (pvDst : Slice (Array U16 256#usize)) (nRows : Usize) (i : Usize) :
  Result (Slice (Array U16 256#usize))
  :=
  if i < nRows
  then
    do
    let a ← Slice.index_usize pvSrc1 i
    let a1 ← Slice.index_usize pvSrc2 i
    let (a2, index_mut_back) ← Slice.index_mut_usize pvDst i
    let a3 ← ntt.SymCryptMlKemPolyElementAdd a a1 a2
    let i1 ← i + 1#usize
    let pvDst1 := index_mut_back a3
    ntt.SymCryptMlKemVectorAdd_loop pvSrc1 pvSrc2 pvDst1 nRows i1
  else ok pvDst

/- [symcrust::ntt::SymCryptMlKemVectorAdd]:
   Source: 'src/ntt.rs', lines 1078:0-1095:1 -/
def ntt.SymCryptMlKemVectorAdd
  (pvSrc1 : Slice (Array U16 256#usize)) (pvSrc2 : Slice (Array U16 256#usize))
  (pvDst : Slice (Array U16 256#usize)) :
  Result (Slice (Array U16 256#usize))
  :=
  do
  let nRows := Slice.len pvSrc1
  massert (nRows > 0#usize)
  massert (nRows <= ntt.MATRIX_MAX_NROWS)
  let i := Slice.len pvSrc2
  massert (i = nRows)
  let i1 := Slice.len pvDst
  massert (i1 = nRows)
  ntt.SymCryptMlKemVectorAdd_loop pvSrc1 pvSrc2 pvDst nRows 0#usize

/- [symcrust::ntt::SymCryptMlKemVectorSub]: loop 0:
   Source: 'src/ntt.rs', lines 44:8-1113:5 -/
divergent def ntt.SymCryptMlKemVectorSub_loop
  (pvSrc1 : Slice (Array U16 256#usize)) (pvSrc2 : Slice (Array U16 256#usize))
  (pvDst : Slice (Array U16 256#usize)) (nRows : Usize) (i : Usize) :
  Result (Slice (Array U16 256#usize))
  :=
  if i < nRows
  then
    do
    let a ← Slice.index_usize pvSrc1 i
    let a1 ← Slice.index_usize pvSrc2 i
    let (a2, index_mut_back) ← Slice.index_mut_usize pvDst i
    let a3 ← ntt.SymCryptMlKemPolyElementSub a a1 a2
    let i1 ← i + 1#usize
    let pvDst1 := index_mut_back a3
    ntt.SymCryptMlKemVectorSub_loop pvSrc1 pvSrc2 pvDst1 nRows i1
  else ok pvDst

/- [symcrust::ntt::SymCryptMlKemVectorSub]:
   Source: 'src/ntt.rs', lines 1097:0-1114:1 -/
def ntt.SymCryptMlKemVectorSub
  (pvSrc1 : Slice (Array U16 256#usize)) (pvSrc2 : Slice (Array U16 256#usize))
  (pvDst : Slice (Array U16 256#usize)) :
  Result (Slice (Array U16 256#usize))
  :=
  do
  let nRows := Slice.len pvSrc1
  massert (nRows > 0#usize)
  massert (nRows <= ntt.MATRIX_MAX_NROWS)
  let i := Slice.len pvSrc2
  massert (i = nRows)
  let i1 := Slice.len pvDst
  massert (i1 = nRows)
  ntt.SymCryptMlKemVectorSub_loop pvSrc1 pvSrc2 pvDst nRows 0#usize

/- [symcrust::ntt::SymCryptMlKemVectorNTT]: loop 0:
   Source: 'src/ntt.rs', lines 44:8-1128:5 -/
divergent def ntt.SymCryptMlKemVectorNTT_loop
  (pvSrc : Slice (Array U16 256#usize)) (nRows : Usize) (i : Usize) :
  Result (Slice (Array U16 256#usize))
  :=
  if i < nRows
  then
    do
    let (a, index_mut_back) ← Slice.index_mut_usize pvSrc i
    let a1 ← ntt.SymCryptMlKemPolyElementNTT a
    let i1 ← i + 1#usize
    let pvSrc1 := index_mut_back a1
    ntt.SymCryptMlKemVectorNTT_loop pvSrc1 nRows i1
  else ok pvSrc

/- [symcrust::ntt::SymCryptMlKemVectorNTT]:
   Source: 'src/ntt.rs', lines 1116:0-1129:1 -/
def ntt.SymCryptMlKemVectorNTT
  (pvSrc : Slice (Array U16 256#usize)) :
  Result (Slice (Array U16 256#usize))
  :=
  do
  let nRows := Slice.len pvSrc
  massert (nRows > 0#usize)
  massert (nRows <= ntt.MATRIX_MAX_NROWS)
  ntt.SymCryptMlKemVectorNTT_loop pvSrc nRows 0#usize

/- [symcrust::ntt::SymCryptMlKemVectorINTTAndMulR]: loop 0:
   Source: 'src/ntt.rs', lines 44:8-1143:5 -/
divergent def ntt.SymCryptMlKemVectorINTTAndMulR_loop
  (pvSrc : Slice (Array U16 256#usize)) (nRows : Usize) (i : Usize) :
  Result (Slice (Array U16 256#usize))
  :=
  if i < nRows
  then
    do
    let (a, index_mut_back) ← Slice.index_mut_usize pvSrc i
    let a1 ← ntt.SymCryptMlKemPolyElementINTTAndMulR a
    let i1 ← i + 1#usize
    let pvSrc1 := index_mut_back a1
    ntt.SymCryptMlKemVectorINTTAndMulR_loop pvSrc1 nRows i1
  else ok pvSrc

/- [symcrust::ntt::SymCryptMlKemVectorINTTAndMulR]:
   Source: 'src/ntt.rs', lines 1131:0-1144:1 -/
def ntt.SymCryptMlKemVectorINTTAndMulR
  (pvSrc : Slice (Array U16 256#usize)) :
  Result (Slice (Array U16 256#usize))
  :=
  do
  let nRows := Slice.len pvSrc
  massert (nRows > 0#usize)
  massert (nRows <= ntt.MATRIX_MAX_NROWS)
  ntt.SymCryptMlKemVectorINTTAndMulR_loop pvSrc nRows 0#usize

/- [symcrust::ntt::SymCryptMlKemVectorCompressAndEncode]: loop 0:
   Source: 'src/ntt.rs', lines 44:8-1167:5 -/
divergent def ntt.SymCryptMlKemVectorCompressAndEncode_loop
  (pvSrc : Slice (Array U16 256#usize)) (nBitsPerCoefficient : U32)
  (pbDst : Slice U8) (nRows : Usize) (i : Usize) :
  Result (Slice U8)
  :=
  if i < nRows
  then
    do
    let i1 ← (↑(UScalar.cast .Usize nBitsPerCoefficient) : Result _)
    let i2 ← i * i1
    let i3 ← ntt.MLWE_POLYNOMIAL_COEFFICIENTS / 8#usize
    let pbDst_index ← i2 * i3
    let a ← Slice.index_usize pvSrc i
    let (s, index_mut_back) ←
      core.slice.index.Slice.index_mut
        (core.slice.index.SliceIndexRangeFromUsizeSlice U8) pbDst
        { start := pbDst_index }
    let s1 ←
      ntt.SymCryptMlKemPolyElementCompressAndEncode a nBitsPerCoefficient s
    let i4 ← i + 1#usize
    let pbDst1 := index_mut_back s1
    ntt.SymCryptMlKemVectorCompressAndEncode_loop pvSrc nBitsPerCoefficient
      pbDst1 nRows i4
  else ok pbDst

/- [symcrust::ntt::SymCryptMlKemVectorCompressAndEncode]:
   Source: 'src/ntt.rs', lines 1146:0-1168:1 -/
def ntt.SymCryptMlKemVectorCompressAndEncode
  (pvSrc : Slice (Array U16 256#usize)) (nBitsPerCoefficient : U32)
  (pbDst : Slice U8) (cbDst : Usize) :
  Result (Slice U8)
  :=
  do
  let nRows := Slice.len pvSrc
  massert (nRows > 0#usize)
  massert (nRows <= ntt.MATRIX_MAX_NROWS)
  massert (nBitsPerCoefficient > 0#u32)
  massert (nBitsPerCoefficient <= 12#u32)
  let i ←
    (↑(UScalar.cast .U32 ntt.MLWE_POLYNOMIAL_COEFFICIENTS) : Result _)
  let i1 ← i / 8#u32
  let i2 ← nBitsPerCoefficient * i1
  let i3 ← (↑(UScalar.cast .Usize i2) : Result _)
  let i4 ← nRows * i3
  massert (cbDst = i4)
  ntt.SymCryptMlKemVectorCompressAndEncode_loop pvSrc nBitsPerCoefficient pbDst
    nRows 0#usize

/- [symcrust::ntt::SymCryptMlKemVectorDecodeAndDecompress]: loop 0:
   Source: 'src/ntt.rs', lines 44:8-1192:1 -/
divergent def ntt.SymCryptMlKemVectorDecodeAndDecompress_loop
  (pbSrc : Slice U8) (nBitsPerCoefficient : U32)
  (pvDst : Slice (Array U16 256#usize)) (nRows : Usize) (i : Usize) :
  Result (ntt.MLKEM_ERROR × (Slice (Array U16 256#usize)))
  :=
  if i < nRows
  then
    do
    let i1 ← (↑(UScalar.cast .Usize nBitsPerCoefficient) : Result _)
    let i2 ← i * i1
    let i3 ← ntt.MLWE_POLYNOMIAL_COEFFICIENTS / 8#usize
    let pbSrc_index ← i2 * i3
    let s ←
      core.slice.index.Slice.index
        (core.slice.index.SliceIndexRangeFromUsizeSlice U8) pbSrc
        { start := pbSrc_index }
    let (a, index_mut_back) ← Slice.index_mut_usize pvDst i
    let (scError, a1) ←
      ntt.SymCryptMlKemPolyElementDecodeAndDecompress s nBitsPerCoefficient a
    match scError with
    | ntt.MLKEM_ERROR.NO_ERROR =>
      let pvDst1 := index_mut_back a1
      ok (ntt.MLKEM_ERROR.NO_ERROR, pvDst1)
    | ntt.MLKEM_ERROR.INVALID_BLOB =>
      do
      let i4 ← i + 1#usize
      let pvDst1 := index_mut_back a1
      ntt.SymCryptMlKemVectorDecodeAndDecompress_loop pbSrc nBitsPerCoefficient
        pvDst1 nRows i4
  else ok (ntt.MLKEM_ERROR.NO_ERROR, pvDst)

/- [symcrust::ntt::SymCryptMlKemVectorDecodeAndDecompress]:
   Source: 'src/ntt.rs', lines 1170:0-1192:1 -/
def ntt.SymCryptMlKemVectorDecodeAndDecompress
  (pbSrc : Slice U8) (cbSrc : Usize) (nBitsPerCoefficient : U32)
  (pvDst : Slice (Array U16 256#usize)) :
  Result (ntt.MLKEM_ERROR × (Slice (Array U16 256#usize)))
  :=
  do
  let nRows := Slice.len pvDst
  massert (nRows > 0#usize)
  massert (nRows <= ntt.MATRIX_MAX_NROWS)
  massert (nBitsPerCoefficient > 0#u32)
  massert (nBitsPerCoefficient <= 12#u32)
  let i ← (↑(UScalar.cast .Usize nBitsPerCoefficient) : Result _)
  let i1 ← nRows * i
  let i2 ← ntt.MLWE_POLYNOMIAL_COEFFICIENTS / 8#usize
  let i3 ← i1 * i2
  massert (cbSrc = i3)
  ntt.SymCryptMlKemVectorDecodeAndDecompress_loop pbSrc nBitsPerCoefficient
    pvDst nRows 0#usize

end Symcrust
