-- THIS FILE WAS AUTOMATICALLY GENERATED BY AENEAS
-- [symcrust]: function definitions
import Aeneas
import Symcrust.Code.Types
import Symcrust.Code.FunsExternal
open Aeneas.Std Result Error
set_option linter.dupNamespace false
set_option linter.hashCommand false
set_option linter.unusedVariables false

namespace Symcrust

/- Trait implementation: [symcrust::common::{core::marker::StructuralPartialEq for symcrust::common::Error}]
   Source: 'src/common.rs', lines 5:9-5:18 -/
@[reducible]
def core.marker.StructuralPartialEqsymcrustcommonError :
  core.marker.StructuralPartialEq common.Error := {
}

/- [symcrust::common::{core::cmp::PartialEq<symcrust::common::Error> for symcrust::common::Error}::eq]:
   Source: 'src/common.rs', lines 5:9-5:18 -/
def common.PartialEqsymcrustcommonErrorsymcrustcommonError.eq
  (self : common.Error) (other : common.Error) : Result Bool :=
  match self with
  | common.Error.NoError =>
    match other with
    | common.Error.NoError => ok (0#isize = 0#isize)
    | common.Error.Unused => ok (0#isize = 32768#isize)
    | common.Error.WrongKeySize => ok (0#isize = 32769#isize)
    | common.Error.WrongBlockSize => ok (0#isize = 32770#isize)
    | common.Error.WrongDataSize => ok (0#isize = 32771#isize)
    | common.Error.WrongNonceSize => ok (0#isize = 32772#isize)
    | common.Error.WrongTagSize => ok (0#isize = 32773#isize)
    | common.Error.WrongIterationCount => ok (0#isize = 32774#isize)
    | common.Error.AuthenticationFailure => ok (0#isize = 32775#isize)
    | common.Error.ExternalFailure => ok (0#isize = 32776#isize)
    | common.Error.FipsFailure => ok (0#isize = 32777#isize)
    | common.Error.HardwareFailure => ok (0#isize = 32778#isize)
    | common.Error.NotImplemented => ok (0#isize = 32779#isize)
    | common.Error.InvalidBlob => ok (0#isize = 32780#isize)
    | common.Error.BufferTooSmall => ok (0#isize = 32781#isize)
    | common.Error.InvalidArgument => ok (0#isize = 32782#isize)
    | common.Error.MemoryAllocationFailure => ok (0#isize = 32783#isize)
    | common.Error.SignatureVerificationFailure => ok (0#isize = 32784#isize)
    | common.Error.IncompatibleFormat => ok (0#isize = 32785#isize)
    | common.Error.ValueTooLarge => ok (0#isize = 32786#isize)
    | common.Error.SessionReplayFailure => ok (0#isize = 32787#isize)
    | common.Error.HbsNoOtsKeysLeft => ok (0#isize = 32788#isize)
    | common.Error.HbsPublicRootMismatch => ok (0#isize = 32789#isize)
  | common.Error.Unused =>
    match other with
    | common.Error.NoError => ok (32768#isize = 0#isize)
    | common.Error.Unused => ok (32768#isize = 32768#isize)
    | common.Error.WrongKeySize => ok (32768#isize = 32769#isize)
    | common.Error.WrongBlockSize => ok (32768#isize = 32770#isize)
    | common.Error.WrongDataSize => ok (32768#isize = 32771#isize)
    | common.Error.WrongNonceSize => ok (32768#isize = 32772#isize)
    | common.Error.WrongTagSize => ok (32768#isize = 32773#isize)
    | common.Error.WrongIterationCount => ok (32768#isize = 32774#isize)
    | common.Error.AuthenticationFailure => ok (32768#isize = 32775#isize)
    | common.Error.ExternalFailure => ok (32768#isize = 32776#isize)
    | common.Error.FipsFailure => ok (32768#isize = 32777#isize)
    | common.Error.HardwareFailure => ok (32768#isize = 32778#isize)
    | common.Error.NotImplemented => ok (32768#isize = 32779#isize)
    | common.Error.InvalidBlob => ok (32768#isize = 32780#isize)
    | common.Error.BufferTooSmall => ok (32768#isize = 32781#isize)
    | common.Error.InvalidArgument => ok (32768#isize = 32782#isize)
    | common.Error.MemoryAllocationFailure => ok (32768#isize = 32783#isize)
    | common.Error.SignatureVerificationFailure =>
      ok (32768#isize = 32784#isize)
    | common.Error.IncompatibleFormat => ok (32768#isize = 32785#isize)
    | common.Error.ValueTooLarge => ok (32768#isize = 32786#isize)
    | common.Error.SessionReplayFailure => ok (32768#isize = 32787#isize)
    | common.Error.HbsNoOtsKeysLeft => ok (32768#isize = 32788#isize)
    | common.Error.HbsPublicRootMismatch => ok (32768#isize = 32789#isize)
  | common.Error.WrongKeySize =>
    match other with
    | common.Error.NoError => ok (32769#isize = 0#isize)
    | common.Error.Unused => ok (32769#isize = 32768#isize)
    | common.Error.WrongKeySize => ok (32769#isize = 32769#isize)
    | common.Error.WrongBlockSize => ok (32769#isize = 32770#isize)
    | common.Error.WrongDataSize => ok (32769#isize = 32771#isize)
    | common.Error.WrongNonceSize => ok (32769#isize = 32772#isize)
    | common.Error.WrongTagSize => ok (32769#isize = 32773#isize)
    | common.Error.WrongIterationCount => ok (32769#isize = 32774#isize)
    | common.Error.AuthenticationFailure => ok (32769#isize = 32775#isize)
    | common.Error.ExternalFailure => ok (32769#isize = 32776#isize)
    | common.Error.FipsFailure => ok (32769#isize = 32777#isize)
    | common.Error.HardwareFailure => ok (32769#isize = 32778#isize)
    | common.Error.NotImplemented => ok (32769#isize = 32779#isize)
    | common.Error.InvalidBlob => ok (32769#isize = 32780#isize)
    | common.Error.BufferTooSmall => ok (32769#isize = 32781#isize)
    | common.Error.InvalidArgument => ok (32769#isize = 32782#isize)
    | common.Error.MemoryAllocationFailure => ok (32769#isize = 32783#isize)
    | common.Error.SignatureVerificationFailure =>
      ok (32769#isize = 32784#isize)
    | common.Error.IncompatibleFormat => ok (32769#isize = 32785#isize)
    | common.Error.ValueTooLarge => ok (32769#isize = 32786#isize)
    | common.Error.SessionReplayFailure => ok (32769#isize = 32787#isize)
    | common.Error.HbsNoOtsKeysLeft => ok (32769#isize = 32788#isize)
    | common.Error.HbsPublicRootMismatch => ok (32769#isize = 32789#isize)
  | common.Error.WrongBlockSize =>
    match other with
    | common.Error.NoError => ok (32770#isize = 0#isize)
    | common.Error.Unused => ok (32770#isize = 32768#isize)
    | common.Error.WrongKeySize => ok (32770#isize = 32769#isize)
    | common.Error.WrongBlockSize => ok (32770#isize = 32770#isize)
    | common.Error.WrongDataSize => ok (32770#isize = 32771#isize)
    | common.Error.WrongNonceSize => ok (32770#isize = 32772#isize)
    | common.Error.WrongTagSize => ok (32770#isize = 32773#isize)
    | common.Error.WrongIterationCount => ok (32770#isize = 32774#isize)
    | common.Error.AuthenticationFailure => ok (32770#isize = 32775#isize)
    | common.Error.ExternalFailure => ok (32770#isize = 32776#isize)
    | common.Error.FipsFailure => ok (32770#isize = 32777#isize)
    | common.Error.HardwareFailure => ok (32770#isize = 32778#isize)
    | common.Error.NotImplemented => ok (32770#isize = 32779#isize)
    | common.Error.InvalidBlob => ok (32770#isize = 32780#isize)
    | common.Error.BufferTooSmall => ok (32770#isize = 32781#isize)
    | common.Error.InvalidArgument => ok (32770#isize = 32782#isize)
    | common.Error.MemoryAllocationFailure => ok (32770#isize = 32783#isize)
    | common.Error.SignatureVerificationFailure =>
      ok (32770#isize = 32784#isize)
    | common.Error.IncompatibleFormat => ok (32770#isize = 32785#isize)
    | common.Error.ValueTooLarge => ok (32770#isize = 32786#isize)
    | common.Error.SessionReplayFailure => ok (32770#isize = 32787#isize)
    | common.Error.HbsNoOtsKeysLeft => ok (32770#isize = 32788#isize)
    | common.Error.HbsPublicRootMismatch => ok (32770#isize = 32789#isize)
  | common.Error.WrongDataSize =>
    match other with
    | common.Error.NoError => ok (32771#isize = 0#isize)
    | common.Error.Unused => ok (32771#isize = 32768#isize)
    | common.Error.WrongKeySize => ok (32771#isize = 32769#isize)
    | common.Error.WrongBlockSize => ok (32771#isize = 32770#isize)
    | common.Error.WrongDataSize => ok (32771#isize = 32771#isize)
    | common.Error.WrongNonceSize => ok (32771#isize = 32772#isize)
    | common.Error.WrongTagSize => ok (32771#isize = 32773#isize)
    | common.Error.WrongIterationCount => ok (32771#isize = 32774#isize)
    | common.Error.AuthenticationFailure => ok (32771#isize = 32775#isize)
    | common.Error.ExternalFailure => ok (32771#isize = 32776#isize)
    | common.Error.FipsFailure => ok (32771#isize = 32777#isize)
    | common.Error.HardwareFailure => ok (32771#isize = 32778#isize)
    | common.Error.NotImplemented => ok (32771#isize = 32779#isize)
    | common.Error.InvalidBlob => ok (32771#isize = 32780#isize)
    | common.Error.BufferTooSmall => ok (32771#isize = 32781#isize)
    | common.Error.InvalidArgument => ok (32771#isize = 32782#isize)
    | common.Error.MemoryAllocationFailure => ok (32771#isize = 32783#isize)
    | common.Error.SignatureVerificationFailure =>
      ok (32771#isize = 32784#isize)
    | common.Error.IncompatibleFormat => ok (32771#isize = 32785#isize)
    | common.Error.ValueTooLarge => ok (32771#isize = 32786#isize)
    | common.Error.SessionReplayFailure => ok (32771#isize = 32787#isize)
    | common.Error.HbsNoOtsKeysLeft => ok (32771#isize = 32788#isize)
    | common.Error.HbsPublicRootMismatch => ok (32771#isize = 32789#isize)
  | common.Error.WrongNonceSize =>
    match other with
    | common.Error.NoError => ok (32772#isize = 0#isize)
    | common.Error.Unused => ok (32772#isize = 32768#isize)
    | common.Error.WrongKeySize => ok (32772#isize = 32769#isize)
    | common.Error.WrongBlockSize => ok (32772#isize = 32770#isize)
    | common.Error.WrongDataSize => ok (32772#isize = 32771#isize)
    | common.Error.WrongNonceSize => ok (32772#isize = 32772#isize)
    | common.Error.WrongTagSize => ok (32772#isize = 32773#isize)
    | common.Error.WrongIterationCount => ok (32772#isize = 32774#isize)
    | common.Error.AuthenticationFailure => ok (32772#isize = 32775#isize)
    | common.Error.ExternalFailure => ok (32772#isize = 32776#isize)
    | common.Error.FipsFailure => ok (32772#isize = 32777#isize)
    | common.Error.HardwareFailure => ok (32772#isize = 32778#isize)
    | common.Error.NotImplemented => ok (32772#isize = 32779#isize)
    | common.Error.InvalidBlob => ok (32772#isize = 32780#isize)
    | common.Error.BufferTooSmall => ok (32772#isize = 32781#isize)
    | common.Error.InvalidArgument => ok (32772#isize = 32782#isize)
    | common.Error.MemoryAllocationFailure => ok (32772#isize = 32783#isize)
    | common.Error.SignatureVerificationFailure =>
      ok (32772#isize = 32784#isize)
    | common.Error.IncompatibleFormat => ok (32772#isize = 32785#isize)
    | common.Error.ValueTooLarge => ok (32772#isize = 32786#isize)
    | common.Error.SessionReplayFailure => ok (32772#isize = 32787#isize)
    | common.Error.HbsNoOtsKeysLeft => ok (32772#isize = 32788#isize)
    | common.Error.HbsPublicRootMismatch => ok (32772#isize = 32789#isize)
  | common.Error.WrongTagSize =>
    match other with
    | common.Error.NoError => ok (32773#isize = 0#isize)
    | common.Error.Unused => ok (32773#isize = 32768#isize)
    | common.Error.WrongKeySize => ok (32773#isize = 32769#isize)
    | common.Error.WrongBlockSize => ok (32773#isize = 32770#isize)
    | common.Error.WrongDataSize => ok (32773#isize = 32771#isize)
    | common.Error.WrongNonceSize => ok (32773#isize = 32772#isize)
    | common.Error.WrongTagSize => ok (32773#isize = 32773#isize)
    | common.Error.WrongIterationCount => ok (32773#isize = 32774#isize)
    | common.Error.AuthenticationFailure => ok (32773#isize = 32775#isize)
    | common.Error.ExternalFailure => ok (32773#isize = 32776#isize)
    | common.Error.FipsFailure => ok (32773#isize = 32777#isize)
    | common.Error.HardwareFailure => ok (32773#isize = 32778#isize)
    | common.Error.NotImplemented => ok (32773#isize = 32779#isize)
    | common.Error.InvalidBlob => ok (32773#isize = 32780#isize)
    | common.Error.BufferTooSmall => ok (32773#isize = 32781#isize)
    | common.Error.InvalidArgument => ok (32773#isize = 32782#isize)
    | common.Error.MemoryAllocationFailure => ok (32773#isize = 32783#isize)
    | common.Error.SignatureVerificationFailure =>
      ok (32773#isize = 32784#isize)
    | common.Error.IncompatibleFormat => ok (32773#isize = 32785#isize)
    | common.Error.ValueTooLarge => ok (32773#isize = 32786#isize)
    | common.Error.SessionReplayFailure => ok (32773#isize = 32787#isize)
    | common.Error.HbsNoOtsKeysLeft => ok (32773#isize = 32788#isize)
    | common.Error.HbsPublicRootMismatch => ok (32773#isize = 32789#isize)
  | common.Error.WrongIterationCount =>
    match other with
    | common.Error.NoError => ok (32774#isize = 0#isize)
    | common.Error.Unused => ok (32774#isize = 32768#isize)
    | common.Error.WrongKeySize => ok (32774#isize = 32769#isize)
    | common.Error.WrongBlockSize => ok (32774#isize = 32770#isize)
    | common.Error.WrongDataSize => ok (32774#isize = 32771#isize)
    | common.Error.WrongNonceSize => ok (32774#isize = 32772#isize)
    | common.Error.WrongTagSize => ok (32774#isize = 32773#isize)
    | common.Error.WrongIterationCount => ok (32774#isize = 32774#isize)
    | common.Error.AuthenticationFailure => ok (32774#isize = 32775#isize)
    | common.Error.ExternalFailure => ok (32774#isize = 32776#isize)
    | common.Error.FipsFailure => ok (32774#isize = 32777#isize)
    | common.Error.HardwareFailure => ok (32774#isize = 32778#isize)
    | common.Error.NotImplemented => ok (32774#isize = 32779#isize)
    | common.Error.InvalidBlob => ok (32774#isize = 32780#isize)
    | common.Error.BufferTooSmall => ok (32774#isize = 32781#isize)
    | common.Error.InvalidArgument => ok (32774#isize = 32782#isize)
    | common.Error.MemoryAllocationFailure => ok (32774#isize = 32783#isize)
    | common.Error.SignatureVerificationFailure =>
      ok (32774#isize = 32784#isize)
    | common.Error.IncompatibleFormat => ok (32774#isize = 32785#isize)
    | common.Error.ValueTooLarge => ok (32774#isize = 32786#isize)
    | common.Error.SessionReplayFailure => ok (32774#isize = 32787#isize)
    | common.Error.HbsNoOtsKeysLeft => ok (32774#isize = 32788#isize)
    | common.Error.HbsPublicRootMismatch => ok (32774#isize = 32789#isize)
  | common.Error.AuthenticationFailure =>
    match other with
    | common.Error.NoError => ok (32775#isize = 0#isize)
    | common.Error.Unused => ok (32775#isize = 32768#isize)
    | common.Error.WrongKeySize => ok (32775#isize = 32769#isize)
    | common.Error.WrongBlockSize => ok (32775#isize = 32770#isize)
    | common.Error.WrongDataSize => ok (32775#isize = 32771#isize)
    | common.Error.WrongNonceSize => ok (32775#isize = 32772#isize)
    | common.Error.WrongTagSize => ok (32775#isize = 32773#isize)
    | common.Error.WrongIterationCount => ok (32775#isize = 32774#isize)
    | common.Error.AuthenticationFailure => ok (32775#isize = 32775#isize)
    | common.Error.ExternalFailure => ok (32775#isize = 32776#isize)
    | common.Error.FipsFailure => ok (32775#isize = 32777#isize)
    | common.Error.HardwareFailure => ok (32775#isize = 32778#isize)
    | common.Error.NotImplemented => ok (32775#isize = 32779#isize)
    | common.Error.InvalidBlob => ok (32775#isize = 32780#isize)
    | common.Error.BufferTooSmall => ok (32775#isize = 32781#isize)
    | common.Error.InvalidArgument => ok (32775#isize = 32782#isize)
    | common.Error.MemoryAllocationFailure => ok (32775#isize = 32783#isize)
    | common.Error.SignatureVerificationFailure =>
      ok (32775#isize = 32784#isize)
    | common.Error.IncompatibleFormat => ok (32775#isize = 32785#isize)
    | common.Error.ValueTooLarge => ok (32775#isize = 32786#isize)
    | common.Error.SessionReplayFailure => ok (32775#isize = 32787#isize)
    | common.Error.HbsNoOtsKeysLeft => ok (32775#isize = 32788#isize)
    | common.Error.HbsPublicRootMismatch => ok (32775#isize = 32789#isize)
  | common.Error.ExternalFailure =>
    match other with
    | common.Error.NoError => ok (32776#isize = 0#isize)
    | common.Error.Unused => ok (32776#isize = 32768#isize)
    | common.Error.WrongKeySize => ok (32776#isize = 32769#isize)
    | common.Error.WrongBlockSize => ok (32776#isize = 32770#isize)
    | common.Error.WrongDataSize => ok (32776#isize = 32771#isize)
    | common.Error.WrongNonceSize => ok (32776#isize = 32772#isize)
    | common.Error.WrongTagSize => ok (32776#isize = 32773#isize)
    | common.Error.WrongIterationCount => ok (32776#isize = 32774#isize)
    | common.Error.AuthenticationFailure => ok (32776#isize = 32775#isize)
    | common.Error.ExternalFailure => ok (32776#isize = 32776#isize)
    | common.Error.FipsFailure => ok (32776#isize = 32777#isize)
    | common.Error.HardwareFailure => ok (32776#isize = 32778#isize)
    | common.Error.NotImplemented => ok (32776#isize = 32779#isize)
    | common.Error.InvalidBlob => ok (32776#isize = 32780#isize)
    | common.Error.BufferTooSmall => ok (32776#isize = 32781#isize)
    | common.Error.InvalidArgument => ok (32776#isize = 32782#isize)
    | common.Error.MemoryAllocationFailure => ok (32776#isize = 32783#isize)
    | common.Error.SignatureVerificationFailure =>
      ok (32776#isize = 32784#isize)
    | common.Error.IncompatibleFormat => ok (32776#isize = 32785#isize)
    | common.Error.ValueTooLarge => ok (32776#isize = 32786#isize)
    | common.Error.SessionReplayFailure => ok (32776#isize = 32787#isize)
    | common.Error.HbsNoOtsKeysLeft => ok (32776#isize = 32788#isize)
    | common.Error.HbsPublicRootMismatch => ok (32776#isize = 32789#isize)
  | common.Error.FipsFailure =>
    match other with
    | common.Error.NoError => ok (32777#isize = 0#isize)
    | common.Error.Unused => ok (32777#isize = 32768#isize)
    | common.Error.WrongKeySize => ok (32777#isize = 32769#isize)
    | common.Error.WrongBlockSize => ok (32777#isize = 32770#isize)
    | common.Error.WrongDataSize => ok (32777#isize = 32771#isize)
    | common.Error.WrongNonceSize => ok (32777#isize = 32772#isize)
    | common.Error.WrongTagSize => ok (32777#isize = 32773#isize)
    | common.Error.WrongIterationCount => ok (32777#isize = 32774#isize)
    | common.Error.AuthenticationFailure => ok (32777#isize = 32775#isize)
    | common.Error.ExternalFailure => ok (32777#isize = 32776#isize)
    | common.Error.FipsFailure => ok (32777#isize = 32777#isize)
    | common.Error.HardwareFailure => ok (32777#isize = 32778#isize)
    | common.Error.NotImplemented => ok (32777#isize = 32779#isize)
    | common.Error.InvalidBlob => ok (32777#isize = 32780#isize)
    | common.Error.BufferTooSmall => ok (32777#isize = 32781#isize)
    | common.Error.InvalidArgument => ok (32777#isize = 32782#isize)
    | common.Error.MemoryAllocationFailure => ok (32777#isize = 32783#isize)
    | common.Error.SignatureVerificationFailure =>
      ok (32777#isize = 32784#isize)
    | common.Error.IncompatibleFormat => ok (32777#isize = 32785#isize)
    | common.Error.ValueTooLarge => ok (32777#isize = 32786#isize)
    | common.Error.SessionReplayFailure => ok (32777#isize = 32787#isize)
    | common.Error.HbsNoOtsKeysLeft => ok (32777#isize = 32788#isize)
    | common.Error.HbsPublicRootMismatch => ok (32777#isize = 32789#isize)
  | common.Error.HardwareFailure =>
    match other with
    | common.Error.NoError => ok (32778#isize = 0#isize)
    | common.Error.Unused => ok (32778#isize = 32768#isize)
    | common.Error.WrongKeySize => ok (32778#isize = 32769#isize)
    | common.Error.WrongBlockSize => ok (32778#isize = 32770#isize)
    | common.Error.WrongDataSize => ok (32778#isize = 32771#isize)
    | common.Error.WrongNonceSize => ok (32778#isize = 32772#isize)
    | common.Error.WrongTagSize => ok (32778#isize = 32773#isize)
    | common.Error.WrongIterationCount => ok (32778#isize = 32774#isize)
    | common.Error.AuthenticationFailure => ok (32778#isize = 32775#isize)
    | common.Error.ExternalFailure => ok (32778#isize = 32776#isize)
    | common.Error.FipsFailure => ok (32778#isize = 32777#isize)
    | common.Error.HardwareFailure => ok (32778#isize = 32778#isize)
    | common.Error.NotImplemented => ok (32778#isize = 32779#isize)
    | common.Error.InvalidBlob => ok (32778#isize = 32780#isize)
    | common.Error.BufferTooSmall => ok (32778#isize = 32781#isize)
    | common.Error.InvalidArgument => ok (32778#isize = 32782#isize)
    | common.Error.MemoryAllocationFailure => ok (32778#isize = 32783#isize)
    | common.Error.SignatureVerificationFailure =>
      ok (32778#isize = 32784#isize)
    | common.Error.IncompatibleFormat => ok (32778#isize = 32785#isize)
    | common.Error.ValueTooLarge => ok (32778#isize = 32786#isize)
    | common.Error.SessionReplayFailure => ok (32778#isize = 32787#isize)
    | common.Error.HbsNoOtsKeysLeft => ok (32778#isize = 32788#isize)
    | common.Error.HbsPublicRootMismatch => ok (32778#isize = 32789#isize)
  | common.Error.NotImplemented =>
    match other with
    | common.Error.NoError => ok (32779#isize = 0#isize)
    | common.Error.Unused => ok (32779#isize = 32768#isize)
    | common.Error.WrongKeySize => ok (32779#isize = 32769#isize)
    | common.Error.WrongBlockSize => ok (32779#isize = 32770#isize)
    | common.Error.WrongDataSize => ok (32779#isize = 32771#isize)
    | common.Error.WrongNonceSize => ok (32779#isize = 32772#isize)
    | common.Error.WrongTagSize => ok (32779#isize = 32773#isize)
    | common.Error.WrongIterationCount => ok (32779#isize = 32774#isize)
    | common.Error.AuthenticationFailure => ok (32779#isize = 32775#isize)
    | common.Error.ExternalFailure => ok (32779#isize = 32776#isize)
    | common.Error.FipsFailure => ok (32779#isize = 32777#isize)
    | common.Error.HardwareFailure => ok (32779#isize = 32778#isize)
    | common.Error.NotImplemented => ok (32779#isize = 32779#isize)
    | common.Error.InvalidBlob => ok (32779#isize = 32780#isize)
    | common.Error.BufferTooSmall => ok (32779#isize = 32781#isize)
    | common.Error.InvalidArgument => ok (32779#isize = 32782#isize)
    | common.Error.MemoryAllocationFailure => ok (32779#isize = 32783#isize)
    | common.Error.SignatureVerificationFailure =>
      ok (32779#isize = 32784#isize)
    | common.Error.IncompatibleFormat => ok (32779#isize = 32785#isize)
    | common.Error.ValueTooLarge => ok (32779#isize = 32786#isize)
    | common.Error.SessionReplayFailure => ok (32779#isize = 32787#isize)
    | common.Error.HbsNoOtsKeysLeft => ok (32779#isize = 32788#isize)
    | common.Error.HbsPublicRootMismatch => ok (32779#isize = 32789#isize)
  | common.Error.InvalidBlob =>
    match other with
    | common.Error.NoError => ok (32780#isize = 0#isize)
    | common.Error.Unused => ok (32780#isize = 32768#isize)
    | common.Error.WrongKeySize => ok (32780#isize = 32769#isize)
    | common.Error.WrongBlockSize => ok (32780#isize = 32770#isize)
    | common.Error.WrongDataSize => ok (32780#isize = 32771#isize)
    | common.Error.WrongNonceSize => ok (32780#isize = 32772#isize)
    | common.Error.WrongTagSize => ok (32780#isize = 32773#isize)
    | common.Error.WrongIterationCount => ok (32780#isize = 32774#isize)
    | common.Error.AuthenticationFailure => ok (32780#isize = 32775#isize)
    | common.Error.ExternalFailure => ok (32780#isize = 32776#isize)
    | common.Error.FipsFailure => ok (32780#isize = 32777#isize)
    | common.Error.HardwareFailure => ok (32780#isize = 32778#isize)
    | common.Error.NotImplemented => ok (32780#isize = 32779#isize)
    | common.Error.InvalidBlob => ok (32780#isize = 32780#isize)
    | common.Error.BufferTooSmall => ok (32780#isize = 32781#isize)
    | common.Error.InvalidArgument => ok (32780#isize = 32782#isize)
    | common.Error.MemoryAllocationFailure => ok (32780#isize = 32783#isize)
    | common.Error.SignatureVerificationFailure =>
      ok (32780#isize = 32784#isize)
    | common.Error.IncompatibleFormat => ok (32780#isize = 32785#isize)
    | common.Error.ValueTooLarge => ok (32780#isize = 32786#isize)
    | common.Error.SessionReplayFailure => ok (32780#isize = 32787#isize)
    | common.Error.HbsNoOtsKeysLeft => ok (32780#isize = 32788#isize)
    | common.Error.HbsPublicRootMismatch => ok (32780#isize = 32789#isize)
  | common.Error.BufferTooSmall =>
    match other with
    | common.Error.NoError => ok (32781#isize = 0#isize)
    | common.Error.Unused => ok (32781#isize = 32768#isize)
    | common.Error.WrongKeySize => ok (32781#isize = 32769#isize)
    | common.Error.WrongBlockSize => ok (32781#isize = 32770#isize)
    | common.Error.WrongDataSize => ok (32781#isize = 32771#isize)
    | common.Error.WrongNonceSize => ok (32781#isize = 32772#isize)
    | common.Error.WrongTagSize => ok (32781#isize = 32773#isize)
    | common.Error.WrongIterationCount => ok (32781#isize = 32774#isize)
    | common.Error.AuthenticationFailure => ok (32781#isize = 32775#isize)
    | common.Error.ExternalFailure => ok (32781#isize = 32776#isize)
    | common.Error.FipsFailure => ok (32781#isize = 32777#isize)
    | common.Error.HardwareFailure => ok (32781#isize = 32778#isize)
    | common.Error.NotImplemented => ok (32781#isize = 32779#isize)
    | common.Error.InvalidBlob => ok (32781#isize = 32780#isize)
    | common.Error.BufferTooSmall => ok (32781#isize = 32781#isize)
    | common.Error.InvalidArgument => ok (32781#isize = 32782#isize)
    | common.Error.MemoryAllocationFailure => ok (32781#isize = 32783#isize)
    | common.Error.SignatureVerificationFailure =>
      ok (32781#isize = 32784#isize)
    | common.Error.IncompatibleFormat => ok (32781#isize = 32785#isize)
    | common.Error.ValueTooLarge => ok (32781#isize = 32786#isize)
    | common.Error.SessionReplayFailure => ok (32781#isize = 32787#isize)
    | common.Error.HbsNoOtsKeysLeft => ok (32781#isize = 32788#isize)
    | common.Error.HbsPublicRootMismatch => ok (32781#isize = 32789#isize)
  | common.Error.InvalidArgument =>
    match other with
    | common.Error.NoError => ok (32782#isize = 0#isize)
    | common.Error.Unused => ok (32782#isize = 32768#isize)
    | common.Error.WrongKeySize => ok (32782#isize = 32769#isize)
    | common.Error.WrongBlockSize => ok (32782#isize = 32770#isize)
    | common.Error.WrongDataSize => ok (32782#isize = 32771#isize)
    | common.Error.WrongNonceSize => ok (32782#isize = 32772#isize)
    | common.Error.WrongTagSize => ok (32782#isize = 32773#isize)
    | common.Error.WrongIterationCount => ok (32782#isize = 32774#isize)
    | common.Error.AuthenticationFailure => ok (32782#isize = 32775#isize)
    | common.Error.ExternalFailure => ok (32782#isize = 32776#isize)
    | common.Error.FipsFailure => ok (32782#isize = 32777#isize)
    | common.Error.HardwareFailure => ok (32782#isize = 32778#isize)
    | common.Error.NotImplemented => ok (32782#isize = 32779#isize)
    | common.Error.InvalidBlob => ok (32782#isize = 32780#isize)
    | common.Error.BufferTooSmall => ok (32782#isize = 32781#isize)
    | common.Error.InvalidArgument => ok (32782#isize = 32782#isize)
    | common.Error.MemoryAllocationFailure => ok (32782#isize = 32783#isize)
    | common.Error.SignatureVerificationFailure =>
      ok (32782#isize = 32784#isize)
    | common.Error.IncompatibleFormat => ok (32782#isize = 32785#isize)
    | common.Error.ValueTooLarge => ok (32782#isize = 32786#isize)
    | common.Error.SessionReplayFailure => ok (32782#isize = 32787#isize)
    | common.Error.HbsNoOtsKeysLeft => ok (32782#isize = 32788#isize)
    | common.Error.HbsPublicRootMismatch => ok (32782#isize = 32789#isize)
  | common.Error.MemoryAllocationFailure =>
    match other with
    | common.Error.NoError => ok (32783#isize = 0#isize)
    | common.Error.Unused => ok (32783#isize = 32768#isize)
    | common.Error.WrongKeySize => ok (32783#isize = 32769#isize)
    | common.Error.WrongBlockSize => ok (32783#isize = 32770#isize)
    | common.Error.WrongDataSize => ok (32783#isize = 32771#isize)
    | common.Error.WrongNonceSize => ok (32783#isize = 32772#isize)
    | common.Error.WrongTagSize => ok (32783#isize = 32773#isize)
    | common.Error.WrongIterationCount => ok (32783#isize = 32774#isize)
    | common.Error.AuthenticationFailure => ok (32783#isize = 32775#isize)
    | common.Error.ExternalFailure => ok (32783#isize = 32776#isize)
    | common.Error.FipsFailure => ok (32783#isize = 32777#isize)
    | common.Error.HardwareFailure => ok (32783#isize = 32778#isize)
    | common.Error.NotImplemented => ok (32783#isize = 32779#isize)
    | common.Error.InvalidBlob => ok (32783#isize = 32780#isize)
    | common.Error.BufferTooSmall => ok (32783#isize = 32781#isize)
    | common.Error.InvalidArgument => ok (32783#isize = 32782#isize)
    | common.Error.MemoryAllocationFailure => ok (32783#isize = 32783#isize)
    | common.Error.SignatureVerificationFailure =>
      ok (32783#isize = 32784#isize)
    | common.Error.IncompatibleFormat => ok (32783#isize = 32785#isize)
    | common.Error.ValueTooLarge => ok (32783#isize = 32786#isize)
    | common.Error.SessionReplayFailure => ok (32783#isize = 32787#isize)
    | common.Error.HbsNoOtsKeysLeft => ok (32783#isize = 32788#isize)
    | common.Error.HbsPublicRootMismatch => ok (32783#isize = 32789#isize)
  | common.Error.SignatureVerificationFailure =>
    match other with
    | common.Error.NoError => ok (32784#isize = 0#isize)
    | common.Error.Unused => ok (32784#isize = 32768#isize)
    | common.Error.WrongKeySize => ok (32784#isize = 32769#isize)
    | common.Error.WrongBlockSize => ok (32784#isize = 32770#isize)
    | common.Error.WrongDataSize => ok (32784#isize = 32771#isize)
    | common.Error.WrongNonceSize => ok (32784#isize = 32772#isize)
    | common.Error.WrongTagSize => ok (32784#isize = 32773#isize)
    | common.Error.WrongIterationCount => ok (32784#isize = 32774#isize)
    | common.Error.AuthenticationFailure => ok (32784#isize = 32775#isize)
    | common.Error.ExternalFailure => ok (32784#isize = 32776#isize)
    | common.Error.FipsFailure => ok (32784#isize = 32777#isize)
    | common.Error.HardwareFailure => ok (32784#isize = 32778#isize)
    | common.Error.NotImplemented => ok (32784#isize = 32779#isize)
    | common.Error.InvalidBlob => ok (32784#isize = 32780#isize)
    | common.Error.BufferTooSmall => ok (32784#isize = 32781#isize)
    | common.Error.InvalidArgument => ok (32784#isize = 32782#isize)
    | common.Error.MemoryAllocationFailure => ok (32784#isize = 32783#isize)
    | common.Error.SignatureVerificationFailure =>
      ok (32784#isize = 32784#isize)
    | common.Error.IncompatibleFormat => ok (32784#isize = 32785#isize)
    | common.Error.ValueTooLarge => ok (32784#isize = 32786#isize)
    | common.Error.SessionReplayFailure => ok (32784#isize = 32787#isize)
    | common.Error.HbsNoOtsKeysLeft => ok (32784#isize = 32788#isize)
    | common.Error.HbsPublicRootMismatch => ok (32784#isize = 32789#isize)
  | common.Error.IncompatibleFormat =>
    match other with
    | common.Error.NoError => ok (32785#isize = 0#isize)
    | common.Error.Unused => ok (32785#isize = 32768#isize)
    | common.Error.WrongKeySize => ok (32785#isize = 32769#isize)
    | common.Error.WrongBlockSize => ok (32785#isize = 32770#isize)
    | common.Error.WrongDataSize => ok (32785#isize = 32771#isize)
    | common.Error.WrongNonceSize => ok (32785#isize = 32772#isize)
    | common.Error.WrongTagSize => ok (32785#isize = 32773#isize)
    | common.Error.WrongIterationCount => ok (32785#isize = 32774#isize)
    | common.Error.AuthenticationFailure => ok (32785#isize = 32775#isize)
    | common.Error.ExternalFailure => ok (32785#isize = 32776#isize)
    | common.Error.FipsFailure => ok (32785#isize = 32777#isize)
    | common.Error.HardwareFailure => ok (32785#isize = 32778#isize)
    | common.Error.NotImplemented => ok (32785#isize = 32779#isize)
    | common.Error.InvalidBlob => ok (32785#isize = 32780#isize)
    | common.Error.BufferTooSmall => ok (32785#isize = 32781#isize)
    | common.Error.InvalidArgument => ok (32785#isize = 32782#isize)
    | common.Error.MemoryAllocationFailure => ok (32785#isize = 32783#isize)
    | common.Error.SignatureVerificationFailure =>
      ok (32785#isize = 32784#isize)
    | common.Error.IncompatibleFormat => ok (32785#isize = 32785#isize)
    | common.Error.ValueTooLarge => ok (32785#isize = 32786#isize)
    | common.Error.SessionReplayFailure => ok (32785#isize = 32787#isize)
    | common.Error.HbsNoOtsKeysLeft => ok (32785#isize = 32788#isize)
    | common.Error.HbsPublicRootMismatch => ok (32785#isize = 32789#isize)
  | common.Error.ValueTooLarge =>
    match other with
    | common.Error.NoError => ok (32786#isize = 0#isize)
    | common.Error.Unused => ok (32786#isize = 32768#isize)
    | common.Error.WrongKeySize => ok (32786#isize = 32769#isize)
    | common.Error.WrongBlockSize => ok (32786#isize = 32770#isize)
    | common.Error.WrongDataSize => ok (32786#isize = 32771#isize)
    | common.Error.WrongNonceSize => ok (32786#isize = 32772#isize)
    | common.Error.WrongTagSize => ok (32786#isize = 32773#isize)
    | common.Error.WrongIterationCount => ok (32786#isize = 32774#isize)
    | common.Error.AuthenticationFailure => ok (32786#isize = 32775#isize)
    | common.Error.ExternalFailure => ok (32786#isize = 32776#isize)
    | common.Error.FipsFailure => ok (32786#isize = 32777#isize)
    | common.Error.HardwareFailure => ok (32786#isize = 32778#isize)
    | common.Error.NotImplemented => ok (32786#isize = 32779#isize)
    | common.Error.InvalidBlob => ok (32786#isize = 32780#isize)
    | common.Error.BufferTooSmall => ok (32786#isize = 32781#isize)
    | common.Error.InvalidArgument => ok (32786#isize = 32782#isize)
    | common.Error.MemoryAllocationFailure => ok (32786#isize = 32783#isize)
    | common.Error.SignatureVerificationFailure =>
      ok (32786#isize = 32784#isize)
    | common.Error.IncompatibleFormat => ok (32786#isize = 32785#isize)
    | common.Error.ValueTooLarge => ok (32786#isize = 32786#isize)
    | common.Error.SessionReplayFailure => ok (32786#isize = 32787#isize)
    | common.Error.HbsNoOtsKeysLeft => ok (32786#isize = 32788#isize)
    | common.Error.HbsPublicRootMismatch => ok (32786#isize = 32789#isize)
  | common.Error.SessionReplayFailure =>
    match other with
    | common.Error.NoError => ok (32787#isize = 0#isize)
    | common.Error.Unused => ok (32787#isize = 32768#isize)
    | common.Error.WrongKeySize => ok (32787#isize = 32769#isize)
    | common.Error.WrongBlockSize => ok (32787#isize = 32770#isize)
    | common.Error.WrongDataSize => ok (32787#isize = 32771#isize)
    | common.Error.WrongNonceSize => ok (32787#isize = 32772#isize)
    | common.Error.WrongTagSize => ok (32787#isize = 32773#isize)
    | common.Error.WrongIterationCount => ok (32787#isize = 32774#isize)
    | common.Error.AuthenticationFailure => ok (32787#isize = 32775#isize)
    | common.Error.ExternalFailure => ok (32787#isize = 32776#isize)
    | common.Error.FipsFailure => ok (32787#isize = 32777#isize)
    | common.Error.HardwareFailure => ok (32787#isize = 32778#isize)
    | common.Error.NotImplemented => ok (32787#isize = 32779#isize)
    | common.Error.InvalidBlob => ok (32787#isize = 32780#isize)
    | common.Error.BufferTooSmall => ok (32787#isize = 32781#isize)
    | common.Error.InvalidArgument => ok (32787#isize = 32782#isize)
    | common.Error.MemoryAllocationFailure => ok (32787#isize = 32783#isize)
    | common.Error.SignatureVerificationFailure =>
      ok (32787#isize = 32784#isize)
    | common.Error.IncompatibleFormat => ok (32787#isize = 32785#isize)
    | common.Error.ValueTooLarge => ok (32787#isize = 32786#isize)
    | common.Error.SessionReplayFailure => ok (32787#isize = 32787#isize)
    | common.Error.HbsNoOtsKeysLeft => ok (32787#isize = 32788#isize)
    | common.Error.HbsPublicRootMismatch => ok (32787#isize = 32789#isize)
  | common.Error.HbsNoOtsKeysLeft =>
    match other with
    | common.Error.NoError => ok (32788#isize = 0#isize)
    | common.Error.Unused => ok (32788#isize = 32768#isize)
    | common.Error.WrongKeySize => ok (32788#isize = 32769#isize)
    | common.Error.WrongBlockSize => ok (32788#isize = 32770#isize)
    | common.Error.WrongDataSize => ok (32788#isize = 32771#isize)
    | common.Error.WrongNonceSize => ok (32788#isize = 32772#isize)
    | common.Error.WrongTagSize => ok (32788#isize = 32773#isize)
    | common.Error.WrongIterationCount => ok (32788#isize = 32774#isize)
    | common.Error.AuthenticationFailure => ok (32788#isize = 32775#isize)
    | common.Error.ExternalFailure => ok (32788#isize = 32776#isize)
    | common.Error.FipsFailure => ok (32788#isize = 32777#isize)
    | common.Error.HardwareFailure => ok (32788#isize = 32778#isize)
    | common.Error.NotImplemented => ok (32788#isize = 32779#isize)
    | common.Error.InvalidBlob => ok (32788#isize = 32780#isize)
    | common.Error.BufferTooSmall => ok (32788#isize = 32781#isize)
    | common.Error.InvalidArgument => ok (32788#isize = 32782#isize)
    | common.Error.MemoryAllocationFailure => ok (32788#isize = 32783#isize)
    | common.Error.SignatureVerificationFailure =>
      ok (32788#isize = 32784#isize)
    | common.Error.IncompatibleFormat => ok (32788#isize = 32785#isize)
    | common.Error.ValueTooLarge => ok (32788#isize = 32786#isize)
    | common.Error.SessionReplayFailure => ok (32788#isize = 32787#isize)
    | common.Error.HbsNoOtsKeysLeft => ok (32788#isize = 32788#isize)
    | common.Error.HbsPublicRootMismatch => ok (32788#isize = 32789#isize)
  | common.Error.HbsPublicRootMismatch =>
    match other with
    | common.Error.NoError => ok (32789#isize = 0#isize)
    | common.Error.Unused => ok (32789#isize = 32768#isize)
    | common.Error.WrongKeySize => ok (32789#isize = 32769#isize)
    | common.Error.WrongBlockSize => ok (32789#isize = 32770#isize)
    | common.Error.WrongDataSize => ok (32789#isize = 32771#isize)
    | common.Error.WrongNonceSize => ok (32789#isize = 32772#isize)
    | common.Error.WrongTagSize => ok (32789#isize = 32773#isize)
    | common.Error.WrongIterationCount => ok (32789#isize = 32774#isize)
    | common.Error.AuthenticationFailure => ok (32789#isize = 32775#isize)
    | common.Error.ExternalFailure => ok (32789#isize = 32776#isize)
    | common.Error.FipsFailure => ok (32789#isize = 32777#isize)
    | common.Error.HardwareFailure => ok (32789#isize = 32778#isize)
    | common.Error.NotImplemented => ok (32789#isize = 32779#isize)
    | common.Error.InvalidBlob => ok (32789#isize = 32780#isize)
    | common.Error.BufferTooSmall => ok (32789#isize = 32781#isize)
    | common.Error.InvalidArgument => ok (32789#isize = 32782#isize)
    | common.Error.MemoryAllocationFailure => ok (32789#isize = 32783#isize)
    | common.Error.SignatureVerificationFailure =>
      ok (32789#isize = 32784#isize)
    | common.Error.IncompatibleFormat => ok (32789#isize = 32785#isize)
    | common.Error.ValueTooLarge => ok (32789#isize = 32786#isize)
    | common.Error.SessionReplayFailure => ok (32789#isize = 32787#isize)
    | common.Error.HbsNoOtsKeysLeft => ok (32789#isize = 32788#isize)
    | common.Error.HbsPublicRootMismatch => ok (32789#isize = 32789#isize)

/- Trait implementation: [symcrust::common::{core::cmp::PartialEq<symcrust::common::Error> for symcrust::common::Error}]
   Source: 'src/common.rs', lines 5:9-5:18 -/
@[reducible]
def core.cmp.PartialEqsymcrustcommonErrorsymcrustcommonError :
  core.cmp.PartialEq common.Error common.Error := {
  eq := common.PartialEqsymcrustcommonErrorsymcrustcommonError.eq
  ne := common.PartialEqsymcrustcommonErrorsymcrustcommonError.ne
}

/- [symcrust::common::init]:
   Source: 'src/common.rs', lines 64:0-68:1 -/
def common.init : Result Unit :=
  common.SymCryptModuleInit 103#u32 8#u32

/- [symcrust::common::wipe]:
   Source: 'src/common.rs', lines 70:0-74:1 -/
def common.wipe (pb_data : MutRawPtr U8) (cb_data : Usize) : Result Unit :=
  common.SymCryptWipe pb_data cb_data

/- Trait implementation: [symcrust::key::{core::marker::StructuralPartialEq for symcrust::key::Params}]
   Source: 'src/key.rs', lines 30:9-30:18 -/
@[reducible]
def core.marker.StructuralPartialEqsymcrustkeyParams :
  core.marker.StructuralPartialEq key.Params := {
}

/- [symcrust::key::{core::cmp::PartialEq<symcrust::key::Params> for symcrust::key::Params}::eq]:
   Source: 'src/key.rs', lines 30:9-30:18 -/
def key.PartialEqsymcrustkeyParamssymcrustkeyParams.eq
  (self : key.Params) (other : key.Params) : Result Bool :=
  match self with
  | key.Params.MlKem512 =>
    match other with
    | key.Params.MlKem512 => ok (1#isize = 1#isize)
    | key.Params.MlKem768 => ok (1#isize = 2#isize)
    | key.Params.MlKem1024 => ok (1#isize = 3#isize)
  | key.Params.MlKem768 =>
    match other with
    | key.Params.MlKem512 => ok (2#isize = 1#isize)
    | key.Params.MlKem768 => ok (2#isize = 2#isize)
    | key.Params.MlKem1024 => ok (2#isize = 3#isize)
  | key.Params.MlKem1024 =>
    match other with
    | key.Params.MlKem512 => ok (3#isize = 1#isize)
    | key.Params.MlKem768 => ok (3#isize = 2#isize)
    | key.Params.MlKem1024 => ok (3#isize = 3#isize)

/- Trait implementation: [symcrust::key::{core::cmp::PartialEq<symcrust::key::Params> for symcrust::key::Params}]
   Source: 'src/key.rs', lines 30:9-30:18 -/
@[reducible]
def core.cmp.PartialEqsymcrustkeyParamssymcrustkeyParams : core.cmp.PartialEq
  key.Params key.Params := {
  eq := key.PartialEqsymcrustkeyParamssymcrustkeyParams.eq
  ne := key.PartialEqsymcrustkeyParamssymcrustkeyParams.ne
}

/- [symcrust::key::INTERNAL_PARAMS_ML_KEM512]
   Source: 'src/key.rs', lines 39:0-46:2 -/
@[global_simps]
def key.INTERNAL_PARAMS_ML_KEM512_body : Result key.InternalParams :=
  ok
    {
      params := key.Params.MlKem512,
      n_rows := 2#u8,
      n_eta1 := 3#u8,
      n_eta2 := 2#u8,
      n_bits_of_u := 10#u8,
      n_bits_of_v := 4#u8
    }
@[global_simps, irreducible]
def key.INTERNAL_PARAMS_ML_KEM512 : key.InternalParams :=
  eval_global key.INTERNAL_PARAMS_ML_KEM512_body

/- [symcrust::key::INTERNAL_PARAMS_ML_KEM768]
   Source: 'src/key.rs', lines 48:0-55:2 -/
@[global_simps]
def key.INTERNAL_PARAMS_ML_KEM768_body : Result key.InternalParams :=
  ok
    {
      params := key.Params.MlKem768,
      n_rows := 3#u8,
      n_eta1 := 2#u8,
      n_eta2 := 2#u8,
      n_bits_of_u := 10#u8,
      n_bits_of_v := 4#u8
    }
@[global_simps, irreducible]
def key.INTERNAL_PARAMS_ML_KEM768 : key.InternalParams :=
  eval_global key.INTERNAL_PARAMS_ML_KEM768_body

/- [symcrust::key::INTERNAL_PARAMS_ML_KEM1024]
   Source: 'src/key.rs', lines 57:0-64:2 -/
@[global_simps]
def key.INTERNAL_PARAMS_ML_KEM1024_body : Result key.InternalParams :=
  ok
    {
      params := key.Params.MlKem1024,
      n_rows := 4#u8,
      n_eta1 := 2#u8,
      n_eta2 := 2#u8,
      n_bits_of_u := 11#u8,
      n_bits_of_v := 5#u8
    }
@[global_simps, irreducible]
def key.INTERNAL_PARAMS_ML_KEM1024 : key.InternalParams :=
  eval_global key.INTERNAL_PARAMS_ML_KEM1024_body

/- [symcrust::key::get_internal_params_from_params]:
   Source: 'src/key.rs', lines 66:0-72:1 -/
def key.get_internal_params_from_params
  (params : key.Params) : Result key.InternalParams :=
  match params with
  | key.Params.MlKem512 => ok key.INTERNAL_PARAMS_ML_KEM512
  | key.Params.MlKem768 => ok key.INTERNAL_PARAMS_ML_KEM768
  | key.Params.MlKem1024 => ok key.INTERNAL_PARAMS_ML_KEM1024

/- [symcrust::key::MLWE_POLYNOMIAL_COEFFICIENTS]
   Source: 'src/key.rs', lines 74:0-74:59 -/
@[global_simps]
def key.MLWE_POLYNOMIAL_COEFFICIENTS_body : Result Usize := ok 256#usize
@[global_simps, irreducible]
def key.MLWE_POLYNOMIAL_COEFFICIENTS : Usize :=
  eval_global key.MLWE_POLYNOMIAL_COEFFICIENTS_body

/- [symcrust::key::POLYELEMENT_ZERO]
   Source: 'src/key.rs', lines 76:0-76:83 -/
@[global_simps]
def key.POLYELEMENT_ZERO_body : Result (Array U16 256#usize) :=
  ok (Array.repeat 256#usize 0#u16)
@[global_simps, irreducible]
def key.POLYELEMENT_ZERO : Array U16 256#usize :=
  eval_global key.POLYELEMENT_ZERO_body

/- [symcrust::key::KEY_MAX_SIZEOF_ENCODED_T]
   Source: 'src/key.rs', lines 87:0-87:56 -/
@[global_simps]
def key.KEY_MAX_SIZEOF_ENCODED_T_body : Result Usize := ok 1536#usize
@[global_simps, irreducible]
def key.KEY_MAX_SIZEOF_ENCODED_T : Usize :=
  eval_global key.KEY_MAX_SIZEOF_ENCODED_T_body

/- [symcrust::key::{symcrust::key::PreKey2<@Slice<@Array<u16, 256: usize>>>}::matrix_len]:
   Source: 'src/key.rs', lines 256:4-258:5 -/
def key.PreKey2SliceArrayU16256.matrix_len
  (self : key.PreKey2 (Slice (Array U16 256#usize))) : Result Usize :=
  self.n_rows * self.n_rows

/- [symcrust::key::{symcrust::key::PreKey2<@Slice<@Array<u16, 256: usize>>>}::atranspose]:
   Source: 'src/key.rs', lines 259:4-262:5 -/
def key.PreKey2SliceArrayU16256.atranspose
  (self : key.PreKey2 (Slice (Array U16 256#usize))) :
  Result (Slice (Array U16 256#usize))
  :=
  do
  let m_len ← key.PreKey2SliceArrayU16256.matrix_len self
  core.slice.index.Slice.index (core.slice.index.SliceIndexRangeUsizeSliceInst
    (Array U16 256#usize)) self.data { start := 0#usize, end_ := m_len }

/- [symcrust::key::{symcrust::key::PreKey2<@Slice<@Array<u16, 256: usize>>>}::t]:
   Source: 'src/key.rs', lines 263:4-266:5 -/
def key.PreKey2SliceArrayU16256.t
  (self : key.PreKey2 (Slice (Array U16 256#usize))) :
  Result (Slice (Array U16 256#usize))
  :=
  do
  let m_len ← key.PreKey2SliceArrayU16256.matrix_len self
  let i ← m_len + self.n_rows
  core.slice.index.Slice.index (core.slice.index.SliceIndexRangeUsizeSliceInst
    (Array U16 256#usize)) self.data { start := m_len, end_ := i }

/- [symcrust::key::{symcrust::key::PreKey2<@Slice<@Array<u16, 256: usize>>>}::s]:
   Source: 'src/key.rs', lines 267:4-270:5 -/
def key.PreKey2SliceArrayU16256.s
  (self : key.PreKey2 (Slice (Array U16 256#usize))) :
  Result (Slice (Array U16 256#usize))
  :=
  do
  let m_len ← key.PreKey2SliceArrayU16256.matrix_len self
  let i ← m_len + self.n_rows
  let i1 ← 2#usize * self.n_rows
  let i2 ← m_len + i1
  core.slice.index.Slice.index (core.slice.index.SliceIndexRangeUsizeSliceInst
    (Array U16 256#usize)) self.data { start := i, end_ := i2 }

/- [symcrust::key::{symcrust::key::PreKey2<@Slice<@Array<u16, 256: usize>>>}::atranspose_mut]:
   Source: 'src/key.rs', lines 271:4-274:5 -/
def key.PreKey2SliceArrayU16256.atranspose_mut
  (self : key.PreKey2 (Slice (Array U16 256#usize))) :
  Result ((Slice (Array U16 256#usize)) × (Slice (Array U16 256#usize) →
    key.PreKey2 (Slice (Array U16 256#usize))))
  :=
  do
  let m_len ← key.PreKey2SliceArrayU16256.matrix_len self
  let (s, index_mut_back) ←
    core.slice.index.Slice.index_mut
      (core.slice.index.SliceIndexRangeUsizeSliceInst (Array U16 256#usize))
      self.data { start := 0#usize, end_ := m_len }
  let back := fun ret => let s1 := index_mut_back ret
                         { self with data := s1 }
  ok (s, back)

/- [symcrust::key::{symcrust::key::PreKey2<@Slice<@Array<u16, 256: usize>>>}::t_mut]:
   Source: 'src/key.rs', lines 275:4-278:5 -/
def key.PreKey2SliceArrayU16256.t_mut
  (self : key.PreKey2 (Slice (Array U16 256#usize))) :
  Result ((Slice (Array U16 256#usize)) × (Slice (Array U16 256#usize) →
    key.PreKey2 (Slice (Array U16 256#usize))))
  :=
  do
  let m_len ← key.PreKey2SliceArrayU16256.matrix_len self
  let i ← m_len + self.n_rows
  let (s, index_mut_back) ←
    core.slice.index.Slice.index_mut
      (core.slice.index.SliceIndexRangeUsizeSliceInst (Array U16 256#usize))
      self.data { start := m_len, end_ := i }
  let back := fun ret => let s1 := index_mut_back ret
                         { self with data := s1 }
  ok (s, back)

/- [symcrust::key::{symcrust::key::PreKey2<@Slice<@Array<u16, 256: usize>>>}::s_mut]:
   Source: 'src/key.rs', lines 279:4-282:5 -/
def key.PreKey2SliceArrayU16256.s_mut
  (self : key.PreKey2 (Slice (Array U16 256#usize))) :
  Result ((Slice (Array U16 256#usize)) × (Slice (Array U16 256#usize) →
    key.PreKey2 (Slice (Array U16 256#usize))))
  :=
  do
  let m_len ← key.PreKey2SliceArrayU16256.matrix_len self
  let i ← m_len + self.n_rows
  let i1 ← 2#usize * self.n_rows
  let i2 ← m_len + i1
  let (s, index_mut_back) ←
    core.slice.index.Slice.index_mut
      (core.slice.index.SliceIndexRangeUsizeSliceInst (Array U16 256#usize))
      self.data { start := i, end_ := i2 }
  let back := fun ret => let s1 := index_mut_back ret
                         { self with data := s1 }
  ok (s, back)

/- [symcrust::key::{symcrust::key::PreKey2<@Slice<@Array<u16, 256: usize>>>}::ats_mut]:
   Source: 'src/key.rs', lines 287:4-292:5 -/
def key.PreKey2SliceArrayU16256.ats_mut
  (self : key.PreKey2 (Slice (Array U16 256#usize))) :
  Result (((Slice (Array U16 256#usize)) × (Slice (Array U16 256#usize)) ×
    (Slice (Array U16 256#usize))) × (((Slice (Array U16 256#usize)) × (Slice
    (Array U16 256#usize)) × (Slice (Array U16 256#usize))) → key.PreKey2
    (Slice (Array U16 256#usize))))
  :=
  do
  let m_len ← key.PreKey2SliceArrayU16256.matrix_len self
  let (p, split_at_mut_back) ← core.slice.Slice.split_at_mut self.data m_len
  let (a, ts) := p
  let (p1, split_at_mut_back1) ← core.slice.Slice.split_at_mut ts self.n_rows
  let (t, s) := p1
  let back :=
    fun ret =>
      let (s1, s2, s3) := ret
      let ts1 := split_at_mut_back1 (s2, s3)
      let s4 := split_at_mut_back (s1, ts1)
      { self with data := s4 }
  ok ((a, t, s), back)

/- [symcrust::key::{symcrust::key::PreKey2<@Slice<@Array<u16, 256: usize>>>}::t_encoded_t_mut]:
   Source: 'src/key.rs', lines 294:4-300:5 -/
def key.PreKey2SliceArrayU16256.t_encoded_t_mut
  (self : key.PreKey2 (Slice (Array U16 256#usize))) :
  Result (((Slice (Array U16 256#usize)) × (Array U8 1536#usize)) × (((Slice
    (Array U16 256#usize)) × (Array U8 1536#usize)) → key.PreKey2 (Slice
    (Array U16 256#usize))))
  :=
  do
  let m_len ← key.PreKey2SliceArrayU16256.matrix_len self
  let i ← m_len + self.n_rows
  let (s, index_mut_back) ←
    core.slice.index.Slice.index_mut
      (core.slice.index.SliceIndexRangeUsizeSliceInst (Array U16 256#usize))
      self.data { start := m_len, end_ := i }
  let back :=
    fun ret =>
      let (s1, a) := ret
      let s2 := index_mut_back s1
      { self with encoded_t := a, data := s2 }
  ok ((s, self.encoded_t), back)

/- [symcrust::key::key_allocate2::PARAMS#1]
   Source: 'src/key.rs', lines 328:12-329:66 -/
@[global_simps]
def key.key_allocate2.PARAMS_1_body : Result key.InternalParams :=
  key.get_internal_params_from_params key.Params.MlKem768
@[global_simps, irreducible]
def key.key_allocate2.PARAMS_1 : key.InternalParams :=
  eval_global key.key_allocate2.PARAMS_1_body

/- [symcrust::key::key_allocate2::N_ROWS#1]
   Source: 'src/key.rs', lines 330:12-330:57 -/
@[global_simps]
def key.key_allocate2.N_ROWS_1_body : Result Usize :=
  ok (UScalar.cast .Usize key.key_allocate2.PARAMS_1.n_rows)
@[global_simps, irreducible]
def key.key_allocate2.N_ROWS_1 : Usize :=
  eval_global key.key_allocate2.N_ROWS_1_body

/- [symcrust::key::key_allocate2::PARAMS#2]
   Source: 'src/key.rs', lines 348:12-349:67 -/
@[global_simps]
def key.key_allocate2.PARAMS_2_body : Result key.InternalParams :=
  key.get_internal_params_from_params key.Params.MlKem1024
@[global_simps, irreducible]
def key.key_allocate2.PARAMS_2 : key.InternalParams :=
  eval_global key.key_allocate2.PARAMS_2_body

/- [symcrust::key::key_allocate2::N_ROWS#2]
   Source: 'src/key.rs', lines 350:12-350:57 -/
@[global_simps]
def key.key_allocate2.N_ROWS_2_body : Result Usize :=
  ok (UScalar.cast .Usize key.key_allocate2.PARAMS_2.n_rows)
@[global_simps, irreducible]
def key.key_allocate2.N_ROWS_2 : Usize :=
  eval_global key.key_allocate2.N_ROWS_2_body

/- [symcrust::key::key_allocate2::PARAMS]
   Source: 'src/key.rs', lines 308:12-309:66 -/
@[global_simps]
def key.key_allocate2.PARAMS_body : Result key.InternalParams :=
  key.get_internal_params_from_params key.Params.MlKem512
@[global_simps, irreducible]
def key.key_allocate2.PARAMS : key.InternalParams :=
  eval_global key.key_allocate2.PARAMS_body

/- [symcrust::key::key_allocate2::N_ROWS]
   Source: 'src/key.rs', lines 310:12-310:57 -/
@[global_simps]
def key.key_allocate2.N_ROWS_body : Result Usize :=
  ok (UScalar.cast .Usize key.key_allocate2.PARAMS.n_rows)
@[global_simps, irreducible]
def key.key_allocate2.N_ROWS : Usize :=
  eval_global key.key_allocate2.N_ROWS_body

/- [symcrust::key::key_allocate2]:
   Source: 'src/key.rs', lines 305:0-368:1 -/
def key.key_allocate2
  (params : key.Params) :
  Result (core.result.Result (key.PreKey2 (Slice (Array U16 256#usize)))
    common.Error)
  :=
  match params with
  | key.Params.MlKem512 =>
    let a := Array.repeat 32#usize 0#u8
    let a1 := Array.repeat 32#usize 0#u8
    let a2 := Array.repeat 32#usize 0#u8
    let a3 := Array.repeat 1536#usize 0#u8
    let a4 := Array.repeat 32#usize 0#u8
    let a5 := Array.repeat 8#usize key.POLYELEMENT_ZERO
    let pk :=
      ({
         algorithm_info := 0#u32,
         params := key.key_allocate2.PARAMS,
         has_private_seed := false,
         has_private_key := false,
         private_seed := a,
         private_random := a1,
         public_seed := a2,
         encoded_t := a3,
         encaps_key_hash := a4,
         n_rows := key.key_allocate2.N_ROWS,
         data := a5
       } : key.PreKey2 (Array (Array U16 256#usize) 8#usize))
    ok (core.result.Result.Ok { pk with data := (Array.to_slice pk.data) })
  | key.Params.MlKem768 =>
    let a := Array.repeat 32#usize 0#u8
    let a1 := Array.repeat 32#usize 0#u8
    let a2 := Array.repeat 32#usize 0#u8
    let a3 := Array.repeat 1536#usize 0#u8
    let a4 := Array.repeat 32#usize 0#u8
    let a5 := Array.repeat 15#usize key.POLYELEMENT_ZERO
    let pk :=
      ({
         algorithm_info := 0#u32,
         params := key.key_allocate2.PARAMS_1,
         has_private_seed := false,
         has_private_key := false,
         private_seed := a,
         private_random := a1,
         public_seed := a2,
         encoded_t := a3,
         encaps_key_hash := a4,
         n_rows := key.key_allocate2.N_ROWS_1,
         data := a5
       } : key.PreKey2 (Array (Array U16 256#usize) 15#usize))
    ok (core.result.Result.Ok { pk with data := (Array.to_slice pk.data) })
  | key.Params.MlKem1024 =>
    let a := Array.repeat 32#usize 0#u8
    let a1 := Array.repeat 32#usize 0#u8
    let a2 := Array.repeat 32#usize 0#u8
    let a3 := Array.repeat 1536#usize 0#u8
    let a4 := Array.repeat 32#usize 0#u8
    let a5 := Array.repeat 24#usize key.POLYELEMENT_ZERO
    let pk :=
      ({
         algorithm_info := 0#u32,
         params := key.key_allocate2.PARAMS_2,
         has_private_seed := false,
         has_private_key := false,
         private_seed := a,
         private_random := a1,
         public_seed := a2,
         encoded_t := a3,
         encaps_key_hash := a4,
         n_rows := key.key_allocate2.N_ROWS_2,
         data := a5
       } : key.PreKey2 (Array (Array U16 256#usize) 24#usize))
    ok (core.result.Result.Ok { pk with data := (Array.to_slice pk.data) })

/- [symcrust::key::key_allocate]:
   Source: 'src/key.rs', lines 464:0-466:1 -/
def key.key_allocate
  (params : key.Params) :
  Result (core.result.Result (key.PreKey2 (Slice (Array U16 256#usize)))
    common.Error)
  :=
  key.key_allocate2 params

/- [symcrust::ntt::MATRIX_MAX_NROWS]
   Source: 'src/ntt.rs', lines 59:0-60:34 -/
@[global_simps] def ntt.MATRIX_MAX_NROWS_body : Result Usize := ok 4#usize
@[global_simps, irreducible]
def ntt.MATRIX_MAX_NROWS : Usize := eval_global ntt.MATRIX_MAX_NROWS_body

/- [symcrust::ntt::Q]
   Source: 'src/ntt.rs', lines 67:0-67:20 -/
@[global_simps] def ntt.Q_body : Result U32 := ok 3329#u32
@[global_simps, irreducible] def ntt.Q : U32 := eval_global ntt.Q_body

/- [symcrust::ntt::SIZEOF_MAX_CIPHERTEXT]
   Source: 'src/ntt.rs', lines 76:0-76:46 -/
@[global_simps]
def ntt.SIZEOF_MAX_CIPHERTEXT_body : Result Usize := ok 1568#usize
@[global_simps, irreducible]
def ntt.SIZEOF_MAX_CIPHERTEXT : Usize :=
  eval_global ntt.SIZEOF_MAX_CIPHERTEXT_body

/- [symcrust::ntt::SIZEOF_AGREED_SECRET]
   Source: 'src/ntt.rs', lines 77:0-77:43 -/
@[global_simps] def ntt.SIZEOF_AGREED_SECRET_body : Result Usize := ok 32#usize
@[global_simps, irreducible]
def ntt.SIZEOF_AGREED_SECRET : Usize :=
  eval_global ntt.SIZEOF_AGREED_SECRET_body

/- [symcrust::ntt::SIZEOF_ENCAPS_RANDOM]
   Source: 'src/ntt.rs', lines 78:0-78:43 -/
@[global_simps] def ntt.SIZEOF_ENCAPS_RANDOM_body : Result Usize := ok 32#usize
@[global_simps, irreducible]
def ntt.SIZEOF_ENCAPS_RANDOM : Usize :=
  eval_global ntt.SIZEOF_ENCAPS_RANDOM_body

/- [symcrust::ntt::RLOG2]
   Source: 'src/ntt.rs', lines 132:0-132:22 -/
@[global_simps] def ntt.RLOG2_body : Result U32 := ok 16#u32
@[global_simps, irreducible] def ntt.RLOG2 : U32 := eval_global ntt.RLOG2_body

/- [symcrust::ntt::RMASK]
   Source: 'src/ntt.rs', lines 133:0-133:26 -/
@[global_simps] def ntt.RMASK_body : Result U32 := ok 65535#u32
@[global_simps, irreducible] def ntt.RMASK : U32 := eval_global ntt.RMASK_body

/- [symcrust::ntt::NEG_Q_INV_MOD_R]
   Source: 'src/ntt.rs', lines 136:0-136:34 -/
@[global_simps] def ntt.NEG_Q_INV_MOD_R_body : Result U32 := ok 3327#u32
@[global_simps, irreducible]
def ntt.NEG_Q_INV_MOD_R : U32 := eval_global ntt.NEG_Q_INV_MOD_R_body

/- [symcrust::ntt::RSQR]
   Source: 'src/ntt.rs', lines 139:0-139:23 -/
@[global_simps] def ntt.RSQR_body : Result U32 := ok 1353#u32
@[global_simps, irreducible] def ntt.RSQR : U32 := eval_global ntt.RSQR_body

/- [symcrust::ntt::RSQR_TIMES_NEG_Q_INV_MOD_R]
   Source: 'src/ntt.rs', lines 141:0-141:46 -/
@[global_simps]
def ntt.RSQR_TIMES_NEG_Q_INV_MOD_R_body : Result U32 := ok 44983#u32
@[global_simps, irreducible]
def ntt.RSQR_TIMES_NEG_Q_INV_MOD_R : U32 :=
  eval_global ntt.RSQR_TIMES_NEG_Q_INV_MOD_R_body

/- [symcrust::ntt::ZETA_BIT_REV_TIMES_R]
   Source: 'src/ntt.rs', lines 156:0-173:2 -/
@[global_simps]
def ntt.ZETA_BIT_REV_TIMES_R_body : Result (Array U16 128#usize) :=
  ok
    (Array.make 128#usize [
      2285#u16, 2571#u16, 2970#u16, 1812#u16, 1493#u16, 1422#u16, 287#u16,
      202#u16, 3158#u16, 622#u16, 1577#u16, 182#u16, 962#u16, 2127#u16,
      1855#u16, 1468#u16, 573#u16, 2004#u16, 264#u16, 383#u16, 2500#u16,
      1458#u16, 1727#u16, 3199#u16, 2648#u16, 1017#u16, 732#u16, 608#u16,
      1787#u16, 411#u16, 3124#u16, 1758#u16, 1223#u16, 652#u16, 2777#u16,
      1015#u16, 2036#u16, 1491#u16, 3047#u16, 1785#u16, 516#u16, 3321#u16,
      3009#u16, 2663#u16, 1711#u16, 2167#u16, 126#u16, 1469#u16, 2476#u16,
      3239#u16, 3058#u16, 830#u16, 107#u16, 1908#u16, 3082#u16, 2378#u16,
      2931#u16, 961#u16, 1821#u16, 2604#u16, 448#u16, 2264#u16, 677#u16,
      2054#u16, 2226#u16, 430#u16, 555#u16, 843#u16, 2078#u16, 871#u16,
      1550#u16, 105#u16, 422#u16, 587#u16, 177#u16, 3094#u16, 3038#u16,
      2869#u16, 1574#u16, 1653#u16, 3083#u16, 778#u16, 1159#u16, 3182#u16,
      2552#u16, 1483#u16, 2727#u16, 1119#u16, 1739#u16, 644#u16, 2457#u16,
      349#u16, 418#u16, 329#u16, 3173#u16, 3254#u16, 817#u16, 1097#u16,
      603#u16, 610#u16, 1322#u16, 2044#u16, 1864#u16, 384#u16, 2114#u16,
      3193#u16, 1218#u16, 1994#u16, 2455#u16, 220#u16, 2142#u16, 1670#u16,
      2144#u16, 1799#u16, 2051#u16, 794#u16, 1819#u16, 2475#u16, 2459#u16,
      478#u16, 3221#u16, 3021#u16, 996#u16, 991#u16, 958#u16, 1869#u16,
      1522#u16, 1628#u16
      ])
@[global_simps, irreducible]
def ntt.ZETA_BIT_REV_TIMES_R : Array U16 128#usize :=
  eval_global ntt.ZETA_BIT_REV_TIMES_R_body

/- [symcrust::ntt::ZETA_BIT_REV_TIMES_R_TIMES_NEG_Q_INV_MOD_R]
   Source: 'src/ntt.rs', lines 179:0-196:2 -/
@[global_simps]
def ntt.ZETA_BIT_REV_TIMES_R_TIMES_NEG_Q_INV_MOD_R_body
  : Result (Array U16 128#usize) :=
  ok
    (Array.make 128#usize [
      19#u16, 34037#u16, 50790#u16, 64748#u16, 52011#u16, 12402#u16, 37345#u16,
      16694#u16, 20906#u16, 37778#u16, 3799#u16, 15690#u16, 54846#u16,
      64177#u16, 11201#u16, 34372#u16, 5827#u16, 48172#u16, 26360#u16,
      29057#u16, 59964#u16, 1102#u16, 44097#u16, 26241#u16, 28072#u16,
      41223#u16, 10532#u16, 56736#u16, 47109#u16, 56677#u16, 38860#u16,
      16162#u16, 5689#u16, 6516#u16, 64039#u16, 34569#u16, 23564#u16,
      45357#u16, 44825#u16, 40455#u16, 12796#u16, 38919#u16, 49471#u16,
      12441#u16, 56401#u16, 649#u16, 25986#u16, 37699#u16, 45652#u16,
      28249#u16, 15886#u16, 8898#u16, 28309#u16, 56460#u16, 30198#u16,
      47286#u16, 52109#u16, 51519#u16, 29155#u16, 12756#u16, 48704#u16,
      61224#u16, 24155#u16, 17914#u16, 334#u16, 54354#u16, 11477#u16,
      52149#u16, 32226#u16, 14233#u16, 45042#u16, 21655#u16, 27738#u16,
      52405#u16, 64591#u16, 4586#u16, 14882#u16, 42443#u16, 59354#u16,
      60043#u16, 33525#u16, 32502#u16, 54905#u16, 35218#u16, 36360#u16,
      18741#u16, 28761#u16, 52897#u16, 18485#u16, 45436#u16, 47975#u16,
      47011#u16, 14430#u16, 46007#u16, 5275#u16, 12618#u16, 31183#u16,
      45239#u16, 40101#u16, 63390#u16, 7382#u16, 50180#u16, 41144#u16,
      32384#u16, 20926#u16, 6279#u16, 54590#u16, 14902#u16, 41321#u16,
      11044#u16, 48546#u16, 51066#u16, 55200#u16, 21497#u16, 7933#u16,
      20198#u16, 22501#u16, 42325#u16, 54629#u16, 17442#u16, 33899#u16,
      23859#u16, 36892#u16, 20257#u16, 41538#u16, 57779#u16, 17422#u16,
      42404#u16
      ])
@[global_simps, irreducible]
def ntt.ZETA_BIT_REV_TIMES_R_TIMES_NEG_Q_INV_MOD_R : Array U16 128#usize :=
  eval_global ntt.ZETA_BIT_REV_TIMES_R_TIMES_NEG_Q_INV_MOD_R_body

/- [symcrust::ntt::ZETA_TO_TIMES_BIT_REV_PLUS_1_TIMES_R]
   Source: 'src/ntt.rs', lines 202:0-219:2 -/
@[global_simps]
def ntt.ZETA_TO_TIMES_BIT_REV_PLUS_1_TIMES_R_body
  : Result (Array U16 128#usize) :=
  ok
    (Array.make 128#usize [
      2226#u16, 1103#u16, 430#u16, 2899#u16, 555#u16, 2774#u16, 843#u16,
      2486#u16, 2078#u16, 1251#u16, 871#u16, 2458#u16, 1550#u16, 1779#u16,
      105#u16, 3224#u16, 422#u16, 2907#u16, 587#u16, 2742#u16, 177#u16,
      3152#u16, 3094#u16, 235#u16, 3038#u16, 291#u16, 2869#u16, 460#u16,
      1574#u16, 1755#u16, 1653#u16, 1676#u16, 3083#u16, 246#u16, 778#u16,
      2551#u16, 1159#u16, 2170#u16, 3182#u16, 147#u16, 2552#u16, 777#u16,
      1483#u16, 1846#u16, 2727#u16, 602#u16, 1119#u16, 2210#u16, 1739#u16,
      1590#u16, 644#u16, 2685#u16, 2457#u16, 872#u16, 349#u16, 2980#u16,
      418#u16, 2911#u16, 329#u16, 3000#u16, 3173#u16, 156#u16, 3254#u16,
      75#u16, 817#u16, 2512#u16, 1097#u16, 2232#u16, 603#u16, 2726#u16,
      610#u16, 2719#u16, 1322#u16, 2007#u16, 2044#u16, 1285#u16, 1864#u16,
      1465#u16, 384#u16, 2945#u16, 2114#u16, 1215#u16, 3193#u16, 136#u16,
      1218#u16, 2111#u16, 1994#u16, 1335#u16, 2455#u16, 874#u16, 220#u16,
      3109#u16, 2142#u16, 1187#u16, 1670#u16, 1659#u16, 2144#u16, 1185#u16,
      1799#u16, 1530#u16, 2051#u16, 1278#u16, 794#u16, 2535#u16, 1819#u16,
      1510#u16, 2475#u16, 854#u16, 2459#u16, 870#u16, 478#u16, 2851#u16,
      3221#u16, 108#u16, 3021#u16, 308#u16, 996#u16, 2333#u16, 991#u16,
      2338#u16, 958#u16, 2371#u16, 1869#u16, 1460#u16, 1522#u16, 1807#u16,
      1628#u16, 1701#u16
      ])
@[global_simps, irreducible]
def ntt.ZETA_TO_TIMES_BIT_REV_PLUS_1_TIMES_R : Array U16 128#usize :=
  eval_global ntt.ZETA_TO_TIMES_BIT_REV_PLUS_1_TIMES_R_body

/- [symcrust::ntt::mod_reduce]:
   Source: 'src/ntt.rs', lines 222:0-236:1 -/
def ntt.mod_reduce (a : U32) : Result U32 :=
  do
  let i ← 2#u32 * ntt.Q
  massert (a < i)
  let res ← (↑(core.num.U32.wrapping_sub a ntt.Q) : Result U32)
  let i1 ← res >>> 16#i32
  if i1 = 0#u32
  then
    do
    let i2 ← (↑(ntt.Q &&& i1) : Result U32)
    let res1 ← (↑(core.num.U32.wrapping_add res i2) : Result U32)
    massert (res1 < ntt.Q)
    ok res1
  else
    do
    massert (i1 = 65535#u32)
    let i2 ← (↑(ntt.Q &&& i1) : Result U32)
    let res1 ← (↑(core.num.U32.wrapping_add res i2) : Result U32)
    massert (res1 < ntt.Q)
    ok res1

/- [symcrust::ntt::mod_add]:
   Source: 'src/ntt.rs', lines 239:0-244:1 -/
def ntt.mod_add (a : U32) (b : U32) : Result U32 :=
  do
  massert (a < ntt.Q)
  massert (b < ntt.Q)
  let i ← a + b
  ntt.mod_reduce i

/- [symcrust::ntt::mod_sub]:
   Source: 'src/ntt.rs', lines 247:0-262:1 -/
def ntt.mod_sub (a : U32) (b : U32) : Result U32 :=
  do
  massert (a < ntt.Q)
  massert (b < ntt.Q)
  let res ← (↑(core.num.U32.wrapping_sub a b) : Result U32)
  let i ← res >>> 16#i32
  if i = 0#u32
  then
    do
    let i1 ← (↑(ntt.Q &&& i) : Result U32)
    let res1 ← (↑(core.num.U32.wrapping_add res i1) : Result U32)
    massert (res1 < ntt.Q)
    ok res1
  else
    do
    massert (i = 65535#u32)
    let i1 ← (↑(ntt.Q &&& i) : Result U32)
    let res1 ← (↑(core.num.U32.wrapping_add res i1) : Result U32)
    massert (res1 < ntt.Q)
    ok res1

/- [symcrust::ntt::mont_mul]:
   Source: 'src/ntt.rs', lines 272:0-284:1 -/
def ntt.mont_mul (a : U32) (b : U32) (b_mont : U32) : Result U32 :=
  do
  massert (a < ntt.Q)
  massert (b < ntt.Q)
  massert (b_mont <= ntt.RMASK)
  let i ← b * ntt.NEG_Q_INV_MOD_R
  let i1 ← (↑(i &&& ntt.RMASK) : Result U32)
  massert (b_mont = i1)
  let res ← a * b
  let i2 ← a * b_mont
  let inv ← (↑(i2 &&& ntt.RMASK) : Result U32)
  let i3 ← inv * ntt.Q
  let res1 ← res + i3
  let res2 ← res1 >>> ntt.RLOG2
  ntt.mod_reduce res2

/- [symcrust::ntt::poly_element_ntt_layer_c::inner_loop]: loop 0:
   Source: 'src/ntt.rs', lines 42:12-300:57 -/
def ntt.poly_element_ntt_layer_c.inner_loop_loop
  (pe_src : Array U16 256#usize) (len : Usize) (start : Usize)
  (twiddle_factor : U32) (twiddle_factor_mont : U32) (j : Usize) :
  Result (Array U16 256#usize)
  :=
  if j < len
  then
    do
    let i ← start + j
    let i1 ← Array.index_usize pe_src i
    let c0 ← core.convert.IntoFrom.into core.convert.FromU32U16 i1
    massert (c0 < ntt.Q)
    let i2 ← i + len
    let i3 ← Array.index_usize pe_src i2
    let c1 ← core.convert.IntoFrom.into core.convert.FromU32U16 i3
    massert (c1 < ntt.Q)
    let c1_times_twiddle ← ntt.mont_mul c1 twiddle_factor twiddle_factor_mont
    let c11 ← ntt.mod_sub c0 c1_times_twiddle
    let c01 ← ntt.mod_add c0 c1_times_twiddle
    let i4 ← (↑(UScalar.cast .U16 c01) : Result U16)
    let pe_src1 ← Array.update pe_src i i4
    let i5 ← i + len
    let i6 ← (↑(UScalar.cast .U16 c11) : Result U16)
    let pe_src2 ← Array.update pe_src1 i5 i6
    let j1 ← j + 1#usize
    ntt.poly_element_ntt_layer_c.inner_loop_loop pe_src2 len start
      twiddle_factor twiddle_factor_mont j1
  else ok pe_src
partial_fixpoint

/- [symcrust::ntt::poly_element_ntt_layer_c::inner_loop]:
   Source: 'src/ntt.rs', lines 297:8-318:9 -/
@[reducible]
def ntt.poly_element_ntt_layer_c.inner_loop
  (pe_src : Array U16 256#usize) (len : Usize) (start : Usize)
  (twiddle_factor : U32) (twiddle_factor_mont : U32) :
  Result (Array U16 256#usize)
  :=
  ntt.poly_element_ntt_layer_c.inner_loop_loop pe_src len start twiddle_factor
    twiddle_factor_mont 0#usize

/- [symcrust::ntt::poly_element_ntt_layer_c]: loop 0:
   Source: 'src/ntt.rs', lines 41:8-320:5 -/
def ntt.poly_element_ntt_layer_c_loop
  (pe_src : Array U16 256#usize) (k : Usize) (len : Usize) (start : Usize) :
  Result (Array U16 256#usize)
  :=
  if start < 256#usize
  then
    do
    let i ← Array.index_usize ntt.ZETA_BIT_REV_TIMES_R k
    let twiddle_factor ← core.convert.IntoFrom.into core.convert.FromU32U16 i
    let i1 ←
      Array.index_usize ntt.ZETA_BIT_REV_TIMES_R_TIMES_NEG_Q_INV_MOD_R k
    let twiddle_factor_mont ←
      core.convert.IntoFrom.into core.convert.FromU32U16 i1
    let k1 ← k + 1#usize
    let pe_src1 ←
      ntt.poly_element_ntt_layer_c.inner_loop pe_src len start twiddle_factor
        twiddle_factor_mont
    let i2 ← 2#usize * len
    let start1 ← start + i2
    ntt.poly_element_ntt_layer_c_loop pe_src1 k1 len start1
  else ok pe_src
partial_fixpoint

/- [symcrust::ntt::poly_element_ntt_layer_c]:
   Source: 'src/ntt.rs', lines 286:0-321:1 -/
@[reducible]
def ntt.poly_element_ntt_layer_c
  (pe_src : Array U16 256#usize) (k : Usize) (len : Usize) :
  Result (Array U16 256#usize)
  :=
  ntt.poly_element_ntt_layer_c_loop pe_src k len 0#usize

/- [symcrust::ntt::poly_element_intt_layer_c::inner_loop]: loop 0:
   Source: 'src/ntt.rs', lines 42:12-338:53 -/
def ntt.poly_element_intt_layer_c.inner_loop_loop
  (pe_src : Array U16 256#usize) (len : Usize) (start : Usize)
  (twiddle_factor : U32) (twiddle_factor_mont : U32) (j : Usize) :
  Result (Array U16 256#usize)
  :=
  if j < len
  then
    do
    let i ← start + j
    let i1 ← Array.index_usize pe_src i
    let c0 ← core.convert.IntoFrom.into core.convert.FromU32U16 i1
    massert (c0 < ntt.Q)
    let i2 ← i + len
    let i3 ← Array.index_usize pe_src i2
    let c1 ← core.convert.IntoFrom.into core.convert.FromU32U16 i3
    massert (c1 < ntt.Q)
    let tmp ← ntt.mod_add c0 c1
    let c11 ← ntt.mod_sub c1 c0
    let c12 ← ntt.mont_mul c11 twiddle_factor twiddle_factor_mont
    let i4 ← (↑(UScalar.cast .U16 tmp) : Result U16)
    let pe_src1 ← Array.update pe_src i i4
    let i5 ← i + len
    let i6 ← (↑(UScalar.cast .U16 c12) : Result U16)
    let pe_src2 ← Array.update pe_src1 i5 i6
    let j1 ← j + 1#usize
    ntt.poly_element_intt_layer_c.inner_loop_loop pe_src2 len start
      twiddle_factor twiddle_factor_mont j1
  else ok pe_src
partial_fixpoint

/- [symcrust::ntt::poly_element_intt_layer_c::inner_loop]:
   Source: 'src/ntt.rs', lines 335:8-350:9 -/
@[reducible]
def ntt.poly_element_intt_layer_c.inner_loop
  (pe_src : Array U16 256#usize) (len : Usize) (start : Usize)
  (twiddle_factor : U32) (twiddle_factor_mont : U32) :
  Result (Array U16 256#usize)
  :=
  ntt.poly_element_intt_layer_c.inner_loop_loop pe_src len start twiddle_factor
    twiddle_factor_mont 0#usize

/- [symcrust::ntt::poly_element_intt_layer_c]: loop 0:
   Source: 'src/ntt.rs', lines 41:8-351:5 -/
def ntt.poly_element_intt_layer_c_loop
  (pe_src : Array U16 256#usize) (k : Usize) (len : Usize) (start : Usize) :
  Result (Array U16 256#usize)
  :=
  if start < 256#usize
  then
    do
    let i ← Array.index_usize ntt.ZETA_BIT_REV_TIMES_R k
    let twiddle_factor ← core.convert.IntoFrom.into core.convert.FromU32U16 i
    let i1 ←
      Array.index_usize ntt.ZETA_BIT_REV_TIMES_R_TIMES_NEG_Q_INV_MOD_R k
    let twiddle_factor_mont ←
      core.convert.IntoFrom.into core.convert.FromU32U16 i1
    let k1 ← k - 1#usize
    let pe_src1 ←
      ntt.poly_element_intt_layer_c.inner_loop pe_src len start twiddle_factor
        twiddle_factor_mont
    let i2 ← 2#usize * len
    let start1 ← start + i2
    ntt.poly_element_intt_layer_c_loop pe_src1 k1 len start1
  else ok pe_src
partial_fixpoint

/- [symcrust::ntt::poly_element_intt_layer_c]:
   Source: 'src/ntt.rs', lines 323:0-352:1 -/
@[reducible]
def ntt.poly_element_intt_layer_c
  (pe_src : Array U16 256#usize) (k : Usize) (len : Usize) :
  Result (Array U16 256#usize)
  :=
  ntt.poly_element_intt_layer_c_loop pe_src k len 0#usize

/- [symcrust::ntt::poly_element_ntt_layer]:
   Source: 'src/ntt.rs', lines 355:0-357:1 -/
def ntt.poly_element_ntt_layer
  (pe_src : Array U16 256#usize) (k : Usize) (len : Usize) :
  Result (Array U16 256#usize)
  :=
  ntt.poly_element_ntt_layer_c pe_src k len

/- [symcrust::ntt::poly_element_intt_layer]:
   Source: 'src/ntt.rs', lines 360:0-362:1 -/
def ntt.poly_element_intt_layer
  (pe_src : Array U16 256#usize) (k : Usize) (len : Usize) :
  Result (Array U16 256#usize)
  :=
  ntt.poly_element_intt_layer_c pe_src k len

/- [symcrust::ntt::poly_element_mul_and_accumulate]: loop 0:
   Source: 'src/ntt.rs', lines 41:8-424:5 -/
def ntt.poly_element_mul_and_accumulate_loop
  (pe_src1 : Array U16 256#usize) (pe_src2 : Array U16 256#usize)
  (pa_dst : Array U32 256#usize) (i : Usize) :
  Result (Array U32 256#usize)
  :=
  do
  let i1 ← key.MLWE_POLYNOMIAL_COEFFICIENTS / 2#usize
  if i < i1
  then
    do
    let i2 ← 2#usize * i
    let i3 ← Array.index_usize pe_src1 i2
    let a0 ← core.convert.IntoFrom.into core.convert.FromU32U16 i3
    let i4 ← i2 + 1#usize
    let i5 ← Array.index_usize pe_src1 i4
    let a1 ← core.convert.IntoFrom.into core.convert.FromU32U16 i5
    let i6 ← Array.index_usize pe_src2 i2
    let b0 ← core.convert.IntoFrom.into core.convert.FromU32U16 i6
    let i7 ← i2 + 1#usize
    let i8 ← Array.index_usize pe_src2 i7
    let b1 ← core.convert.IntoFrom.into core.convert.FromU32U16 i8
    let c0 ← Array.index_usize pa_dst i2
    let i9 ← i2 + 1#usize
    let c1 ← Array.index_usize pa_dst i9
    let a0b0 ← a0 * b0
    let a1b1 ← a1 * b1
    let a0b1 ← a0 * b1
    let a1b0 ← a1 * b0
    let i10 ←
      (↑(core.num.U32.wrapping_mul a1b1 ntt.NEG_Q_INV_MOD_R) : Result U32)
    let inv ← (↑(i10 &&& ntt.RMASK) : Result U32)
    let i11 ← inv * ntt.Q
    let i12 ← a1b1 + i11
    let a1b11 ← i12 >>> ntt.RLOG2
    let i13 ← Array.index_usize ntt.ZETA_TO_TIMES_BIT_REV_PLUS_1_TIMES_R i
    let i14 ← (↑(UScalar.cast .U32 i13) : Result U32)
    let a1b1zetapow ← a1b11 * i14
    let a0b01 ← a0b0 + a1b1zetapow
    let a0b11 ← a0b1 + a1b0
    let c01 ← c0 + a0b01
    let c11 ← c1 + a0b11
    let pa_dst1 ← Array.update pa_dst i2 c01
    let i15 ← i2 + 1#usize
    let pa_dst2 ← Array.update pa_dst1 i15 c11
    let i16 ← i + 1#usize
    ntt.poly_element_mul_and_accumulate_loop pe_src1 pe_src2 pa_dst2 i16
  else ok pa_dst
partial_fixpoint

/- [symcrust::ntt::poly_element_mul_and_accumulate]:
   Source: 'src/ntt.rs', lines 364:0-425:1 -/
@[reducible]
def ntt.poly_element_mul_and_accumulate
  (pe_src1 : Array U16 256#usize) (pe_src2 : Array U16 256#usize)
  (pa_dst : Array U32 256#usize) :
  Result (Array U32 256#usize)
  :=
  ntt.poly_element_mul_and_accumulate_loop pe_src1 pe_src2 pa_dst 0#usize

/- [symcrust::ntt::montgomery_reduce_and_add_poly_element_accumulator_to_poly_element]: loop 0:
   Source: 'src/ntt.rs', lines 41:8-459:5 -/
def ntt.montgomery_reduce_and_add_poly_element_accumulator_to_poly_element_loop
  (pa_src : Array U32 256#usize) (pe_dst : Array U16 256#usize) (i : Usize) :
  Result ((Array U32 256#usize) × (Array U16 256#usize))
  :=
  if i < key.MLWE_POLYNOMIAL_COEFFICIENTS
  then
    do
    let a ← Array.index_usize pa_src i
    let pa_src1 ← Array.update pa_src i 0#u32
    let i1 ← Array.index_usize pe_dst i
    let c ← core.convert.IntoFrom.into core.convert.FromU32U16 i1
    let i2 ←
      (↑(core.num.U32.wrapping_mul a ntt.NEG_Q_INV_MOD_R) : Result U32)
    let inv ← (↑(i2 &&& ntt.RMASK) : Result U32)
    let i3 ← inv * ntt.Q
    let i4 ← a + i3
    let a1 ← i4 >>> ntt.RLOG2
    let c1 ← c + a1
    let i5 ← 2#u32 * ntt.Q
    let c2 ← (↑(core.num.U32.wrapping_sub c1 i5) : Result U32)
    let i6 ← c2 >>> 16#i32
    let i7 ← (↑(ntt.Q &&& i6) : Result U32)
    let c3 ← (↑(core.num.U32.wrapping_add c2 i7) : Result U32)
    let i8 ← c3 >>> 16#i32
    let i9 ← (↑(ntt.Q &&& i8) : Result U32)
    let c4 ← (↑(core.num.U32.wrapping_add c3 i9) : Result U32)
    let i10 ← (↑(UScalar.cast .U16 c4) : Result U16)
    let pe_dst1 ← Array.update pe_dst i i10
    let i11 ← i + 1#usize
    ntt.montgomery_reduce_and_add_poly_element_accumulator_to_poly_element_loop
      pa_src1 pe_dst1 i11
  else ok (pa_src, pe_dst)
partial_fixpoint

/- [symcrust::ntt::montgomery_reduce_and_add_poly_element_accumulator_to_poly_element]:
   Source: 'src/ntt.rs', lines 427:0-460:1 -/
@[reducible]
def ntt.montgomery_reduce_and_add_poly_element_accumulator_to_poly_element
  (pa_src : Array U32 256#usize) (pe_dst : Array U16 256#usize) :
  Result ((Array U32 256#usize) × (Array U16 256#usize))
  :=
  ntt.montgomery_reduce_and_add_poly_element_accumulator_to_poly_element_loop
    pa_src pe_dst 0#usize

/- [symcrust::ntt::poly_element_mul_r]: loop 0:
   Source: 'src/ntt.rs', lines 41:8-471:5 -/
def ntt.poly_element_mul_r_loop
  (pe_src : Array U16 256#usize) (pe_dst : Array U16 256#usize) (i : Usize) :
  Result (Array U16 256#usize)
  :=
  if i < key.MLWE_POLYNOMIAL_COEFFICIENTS
  then
    do
    let i1 ← Array.index_usize pe_src i
    let i2 ← core.convert.IntoFrom.into core.convert.FromU32U16 i1
    let i3 ← ntt.mont_mul i2 ntt.RSQR ntt.RSQR_TIMES_NEG_Q_INV_MOD_R
    let i4 ← (↑(UScalar.cast .U16 i3) : Result U16)
    let pe_dst1 ← Array.update pe_dst i i4
    let i5 ← i + 1#usize
    ntt.poly_element_mul_r_loop pe_src pe_dst1 i5
  else ok pe_dst
partial_fixpoint

/- [symcrust::ntt::poly_element_mul_r]:
   Source: 'src/ntt.rs', lines 462:0-472:1 -/
@[reducible]
def ntt.poly_element_mul_r
  (pe_src : Array U16 256#usize) (pe_dst : Array U16 256#usize) :
  Result (Array U16 256#usize)
  :=
  ntt.poly_element_mul_r_loop pe_src pe_dst 0#usize

/- [symcrust::ntt::poly_element_add]: loop 0:
   Source: 'src/ntt.rs', lines 41:8-484:5 -/
def ntt.poly_element_add_loop
  (pe_src1 : Array U16 256#usize) (pe_src2 : Array U16 256#usize)
  (pe_dst : Array U16 256#usize) (i : Usize) :
  Result (Array U16 256#usize)
  :=
  if i < key.MLWE_POLYNOMIAL_COEFFICIENTS
  then
    do
    let i1 ← Array.index_usize pe_src1 i
    let i2 ← core.convert.IntoFrom.into core.convert.FromU32U16 i1
    let i3 ← Array.index_usize pe_src2 i
    let i4 ← core.convert.IntoFrom.into core.convert.FromU32U16 i3
    let i5 ← ntt.mod_add i2 i4
    let i6 ← (↑(UScalar.cast .U16 i5) : Result U16)
    let pe_dst1 ← Array.update pe_dst i i6
    let i7 ← i + 1#usize
    ntt.poly_element_add_loop pe_src1 pe_src2 pe_dst1 i7
  else ok pe_dst
partial_fixpoint

/- [symcrust::ntt::poly_element_add]:
   Source: 'src/ntt.rs', lines 474:0-485:1 -/
@[reducible]
def ntt.poly_element_add
  (pe_src1 : Array U16 256#usize) (pe_src2 : Array U16 256#usize)
  (pe_dst : Array U16 256#usize) :
  Result (Array U16 256#usize)
  :=
  ntt.poly_element_add_loop pe_src1 pe_src2 pe_dst 0#usize

/- [symcrust::ntt::poly_element_sub]: loop 0:
   Source: 'src/ntt.rs', lines 41:8-496:5 -/
def ntt.poly_element_sub_loop
  (pe_src1 : Array U16 256#usize) (pe_src2 : Array U16 256#usize)
  (pe_dst : Array U16 256#usize) (i : Usize) :
  Result (Array U16 256#usize)
  :=
  if i < key.MLWE_POLYNOMIAL_COEFFICIENTS
  then
    do
    let i1 ← Array.index_usize pe_src1 i
    let i2 ← core.convert.IntoFrom.into core.convert.FromU32U16 i1
    let i3 ← Array.index_usize pe_src2 i
    let i4 ← core.convert.IntoFrom.into core.convert.FromU32U16 i3
    let i5 ← ntt.mod_sub i2 i4
    let i6 ← (↑(UScalar.cast .U16 i5) : Result U16)
    let pe_dst1 ← Array.update pe_dst i i6
    let i7 ← i + 1#usize
    ntt.poly_element_sub_loop pe_src1 pe_src2 pe_dst1 i7
  else ok pe_dst
partial_fixpoint

/- [symcrust::ntt::poly_element_sub]:
   Source: 'src/ntt.rs', lines 487:0-497:1 -/
@[reducible]
def ntt.poly_element_sub
  (pe_src1 : Array U16 256#usize) (pe_src2 : Array U16 256#usize)
  (pe_dst : Array U16 256#usize) :
  Result (Array U16 256#usize)
  :=
  ntt.poly_element_sub_loop pe_src1 pe_src2 pe_dst 0#usize

/- [symcrust::ntt::poly_element_ntt]:
   Source: 'src/ntt.rs', lines 499:0-509:1 -/
def ntt.poly_element_ntt
  (pe_src : Array U16 256#usize) : Result (Array U16 256#usize) :=
  do
  let pe_src1 ← ntt.poly_element_ntt_layer pe_src 1#usize 128#usize
  let pe_src2 ← ntt.poly_element_ntt_layer pe_src1 2#usize 64#usize
  let pe_src3 ← ntt.poly_element_ntt_layer pe_src2 4#usize 32#usize
  let pe_src4 ← ntt.poly_element_ntt_layer pe_src3 8#usize 16#usize
  let pe_src5 ← ntt.poly_element_ntt_layer pe_src4 16#usize 8#usize
  let pe_src6 ← ntt.poly_element_ntt_layer pe_src5 32#usize 4#usize
  ntt.poly_element_ntt_layer pe_src6 64#usize 2#usize

/- [symcrust::ntt::INTT_FIXUP_TIMES_RSQR]
   Source: 'src/ntt.rs', lines 514:0-514:40 -/
@[global_simps] def ntt.INTT_FIXUP_TIMES_RSQR_body : Result U32 := ok 1441#u32
@[global_simps, irreducible]
def ntt.INTT_FIXUP_TIMES_RSQR : U32 :=
  eval_global ntt.INTT_FIXUP_TIMES_RSQR_body

/- [symcrust::ntt::INTT_FIXUP_TIMES_RSQR_TIMES_NEQ_Q_INV_MOD_R]
   Source: 'src/ntt.rs', lines 515:0-515:63 -/
@[global_simps]
def ntt.INTT_FIXUP_TIMES_RSQR_TIMES_NEQ_Q_INV_MOD_R_body : Result U32 :=
  ok 10079#u32
@[global_simps, irreducible]
def ntt.INTT_FIXUP_TIMES_RSQR_TIMES_NEQ_Q_INV_MOD_R : U32 :=
  eval_global ntt.INTT_FIXUP_TIMES_RSQR_TIMES_NEQ_Q_INV_MOD_R_body

/- [symcrust::ntt::poly_element_intt_and_mul_r]: loop 0:
   Source: 'src/ntt.rs', lines 41:8-533:5 -/
def ntt.poly_element_intt_and_mul_r_loop
  (pe_src : Array U16 256#usize) (i : Usize) : Result (Array U16 256#usize) :=
  if i < key.MLWE_POLYNOMIAL_COEFFICIENTS
  then
    do
    let i1 ← Array.index_usize pe_src i
    let i2 ← core.convert.IntoFrom.into core.convert.FromU32U16 i1
    let i3 ←
      ntt.mont_mul i2 ntt.INTT_FIXUP_TIMES_RSQR
        ntt.INTT_FIXUP_TIMES_RSQR_TIMES_NEQ_Q_INV_MOD_R
    let i4 ← (↑(UScalar.cast .U16 i3) : Result U16)
    let pe_src1 ← Array.update pe_src i i4
    let i5 ← i + 1#usize
    ntt.poly_element_intt_and_mul_r_loop pe_src1 i5
  else ok pe_src
partial_fixpoint

/- [symcrust::ntt::poly_element_intt_and_mul_r]:
   Source: 'src/ntt.rs', lines 517:0-534:1 -/
def ntt.poly_element_intt_and_mul_r
  (pe_src : Array U16 256#usize) : Result (Array U16 256#usize) :=
  do
  let pe_src1 ← ntt.poly_element_intt_layer pe_src 127#usize 2#usize
  let pe_src2 ← ntt.poly_element_intt_layer pe_src1 63#usize 4#usize
  let pe_src3 ← ntt.poly_element_intt_layer pe_src2 31#usize 8#usize
  let pe_src4 ← ntt.poly_element_intt_layer pe_src3 15#usize 16#usize
  let pe_src5 ← ntt.poly_element_intt_layer pe_src4 7#usize 32#usize
  let pe_src6 ← ntt.poly_element_intt_layer pe_src5 3#usize 64#usize
  let pe_src7 ← ntt.poly_element_intt_layer pe_src6 1#usize 128#usize
  ntt.poly_element_intt_and_mul_r_loop pe_src7 0#usize

/- [symcrust::ntt::COMPRESS_MULCONSTANT]
   Source: 'src/ntt.rs', lines 542:0-542:43 -/
@[global_simps]
def ntt.COMPRESS_MULCONSTANT_body : Result U32 := ok 10321339#u32
@[global_simps, irreducible]
def ntt.COMPRESS_MULCONSTANT : U32 := eval_global ntt.COMPRESS_MULCONSTANT_body

/- [symcrust::ntt::COMPRESS_SHIFTCONSTANT]
   Source: 'src/ntt.rs', lines 543:0-543:39 -/
@[global_simps] def ntt.COMPRESS_SHIFTCONSTANT_body : Result U32 := ok 35#u32
@[global_simps, irreducible]
def ntt.COMPRESS_SHIFTCONSTANT : U32 :=
  eval_global ntt.COMPRESS_SHIFTCONSTANT_body

/- [symcrust::ntt::min]:
   Source: 'src/ntt.rs', lines 547:0-547:60 -/
def ntt.min (x : U32) (y : U32) : Result U32 :=
  if x <= y
  then ok x
  else ok y

/- [symcrust::ntt::compress_coefficient]:
   Source: 'src/ntt.rs', lines 550:0-570:1 -/
def ntt.compress_coefficient
  (n_bits_per_coefficient : U32) (coefficient : U32) : Result U32 :=
  if n_bits_per_coefficient < 12#u32
  then
    do
    let i ← (↑(UScalar.cast .U64 coefficient) : Result U64)
    let i1 ← (↑(UScalar.cast .U64 ntt.COMPRESS_MULCONSTANT) : Result U64)
    let multiplication ← i * i1
    let i2 ← n_bits_per_coefficient + 1#u32
    let i3 ← ntt.COMPRESS_SHIFTCONSTANT - i2
    let i4 ← multiplication >>> i3
    let coefficient1 ← (↑(UScalar.cast .U32 i4) : Result U32)
    let coefficient2 ← coefficient1 + 1#u32
    let coefficient3 ← coefficient2 >>> 1#i32
    let i5 ← 1#u32 <<< n_bits_per_coefficient
    let i6 ← i5 - 1#u32
    ok (coefficient3 &&& i6)
  else ok coefficient

/- [symcrust::ntt::encode_coefficient]:
   Source: 'src/ntt.rs', lines 573:0-601:1 -/
def ntt.encode_coefficient
  (coefficient : U32) (n_bits_in_coefficient : U32) (pb_dst : Slice U8)
  (cb_dst_written : Usize) (accumulator : U32) (n_bits_in_accumulator : U32) :
  Result ((Slice U8) × Usize × U32 × U32)
  :=
  do
  let i ← 32#u32 - n_bits_in_accumulator
  let n_bits_to_encode ← ntt.min n_bits_in_coefficient i
  let i1 ← 1#u32 <<< n_bits_to_encode
  let i2 ← i1 - 1#u32
  let bits_to_encode ← (↑(coefficient &&& i2) : Result U32)
  let n_bits_in_coefficient1 ← n_bits_in_coefficient - n_bits_to_encode
  let i3 ← bits_to_encode <<< n_bits_in_accumulator
  let accumulator1 ← (↑(accumulator ||| i3) : Result U32)
  let n_bits_in_accumulator1 ← n_bits_in_accumulator + n_bits_to_encode
  if n_bits_in_accumulator1 = 32#u32
  then
    do
    let i4 ← cb_dst_written + 4#usize
    let (s, index_mut_back) ←
      core.slice.index.Slice.index_mut
        (core.slice.index.SliceIndexRangeUsizeSliceInst U8) pb_dst
        { start := cb_dst_written, end_ := i4 }
    let a ←
      (↑(core.num.U32.to_le_bytes accumulator1) : Result (Array U8 4#usize))
    let s1 ← (↑(Array.to_slice a) : Result (Slice U8))
    let s2 ← core.slice.Slice.copy_from_slice core.marker.CopyU8 s s1
    let accumulator2 ← coefficient >>> n_bits_to_encode
    let pb_dst1 := index_mut_back s2
    ok (pb_dst1, i4, accumulator2, n_bits_in_coefficient1)
  else ok (pb_dst, cb_dst_written, accumulator1, n_bits_in_accumulator1)

/- [symcrust::ntt::poly_element_compress_and_encode]: loop 0:
   Source: 'src/ntt.rs', lines 42:12-619:48 -/
def ntt.poly_element_compress_and_encode_loop
  (pe_src : Array U16 256#usize) (n_bits_per_coefficient : U32)
  (pb_dst : Slice U8) (cb_dst_written : Usize) (accumulator : U32)
  (n_bits_in_accumulator : U32) (i : Usize) :
  Result (Slice U8)
  :=
  if i < key.MLWE_POLYNOMIAL_COEFFICIENTS
  then
    do
    let i1 ← Array.index_usize pe_src i
    let coefficient ← core.convert.IntoFrom.into core.convert.FromU32U16 i1
    massert (coefficient < ntt.Q)
    let coefficient1 ←
      ntt.compress_coefficient n_bits_per_coefficient coefficient
    let (pb_dst1, cb_dst_written1, accumulator1, n_bits_in_accumulator1) ←
      ntt.encode_coefficient coefficient1 n_bits_per_coefficient pb_dst
        cb_dst_written accumulator n_bits_in_accumulator
    let i2 ← i + 1#usize
    ntt.poly_element_compress_and_encode_loop pe_src n_bits_per_coefficient
      pb_dst1 cb_dst_written1 accumulator1 n_bits_in_accumulator1 i2
  else do
       massert (n_bits_in_accumulator = 0#u32)
       ok pb_dst
partial_fixpoint

/- [symcrust::ntt::poly_element_compress_and_encode]:
   Source: 'src/ntt.rs', lines 603:0-631:1 -/
def ntt.poly_element_compress_and_encode
  (pe_src : Array U16 256#usize) (n_bits_per_coefficient : U32)
  (pb_dst : Slice U8) :
  Result (Slice U8)
  :=
  do
  massert (n_bits_per_coefficient > 0#u32)
  massert (n_bits_per_coefficient <= 12#u32)
  ntt.poly_element_compress_and_encode_loop pe_src n_bits_per_coefficient
    pb_dst 0#usize 0#u32 0#u32 0#usize

/- [symcrust::ntt::slice_to_sub_array2]:
   Source: 'src/ntt.rs', lines 646:0-648:1 -/
def ntt.slice_to_sub_array2
  (s : Slice U8) (i : Usize) : Result (Array U8 2#usize) :=
  do
  let i1 ← Slice.index_usize s i
  let i2 ← i + 1#usize
  let i3 ← Slice.index_usize s i2
  ok (Array.make 2#usize [ i1, i3 ])

/- [symcrust::ntt::slice_to_sub_array4]:
   Source: 'src/ntt.rs', lines 651:0-653:1 -/
def ntt.slice_to_sub_array4
  (s : Slice U8) (i : Usize) : Result (Array U8 4#usize) :=
  do
  let i1 ← Slice.index_usize s i
  let i2 ← i + 1#usize
  let i3 ← Slice.index_usize s i2
  let i4 ← i + 2#usize
  let i5 ← Slice.index_usize s i4
  let i6 ← i + 3#usize
  let i7 ← Slice.index_usize s i6
  ok (Array.make 4#usize [ i1, i3, i5, i7 ])

/- [symcrust::ntt::decode_coefficient]:
   Source: 'src/ntt.rs', lines 656:0-704:1 -/
def ntt.decode_coefficient
  (pb_src : Slice U8) (n_bits_per_coefficient : U32) (cb_src_read : Usize)
  (accumulator : U32) (n_bits_in_accumulator : U32) (coefficient : U32) :
  Result (Usize × U32 × U32 × U32)
  :=
  if n_bits_in_accumulator = 0#u32
  then
    do
    let a ← ntt.slice_to_sub_array4 pb_src cb_src_read
    let accumulator1 ← (↑(core.num.U32.from_le_bytes a) : Result U32)
    let cb_src_read1 ← cb_src_read + 4#usize
    let n_bits_to_decode ← ntt.min n_bits_per_coefficient 32#u32
    massert (n_bits_to_decode <= 32#u32)
    let i ← 1#u32 <<< n_bits_to_decode
    let i1 ← i - 1#u32
    let bits_to_decode ← (↑(accumulator1 &&& i1) : Result U32)
    let accumulator2 ← accumulator1 >>> n_bits_to_decode
    let n_bits_in_accumulator1 ← 32#u32 - n_bits_to_decode
    let coefficient1 ← (↑(coefficient ||| bits_to_decode) : Result U32)
    if n_bits_per_coefficient > n_bits_to_decode
    then
      do
      massert (n_bits_in_accumulator1 = 0#u32)
      let a1 ← ntt.slice_to_sub_array4 pb_src cb_src_read1
      let accumulator3 ← (↑(core.num.U32.from_le_bytes a1) : Result U32)
      let cb_src_read2 ← cb_src_read1 + 4#usize
      let n_bits_to_decode1 ← n_bits_per_coefficient - n_bits_to_decode
      massert (n_bits_to_decode1 <= 32#u32)
      let i2 ← 1#u32 <<< n_bits_to_decode1
      let i3 ← i2 - 1#u32
      let bits_to_decode1 ← (↑(accumulator3 &&& i3) : Result U32)
      let accumulator4 ← accumulator3 >>> n_bits_to_decode1
      let n_bits_in_accumulator2 ← 32#u32 - n_bits_to_decode1
      let i4 ← bits_to_decode1 <<< n_bits_to_decode
      let coefficient2 ← (↑(coefficient1 ||| i4) : Result U32)
      ok (cb_src_read2, accumulator4, n_bits_in_accumulator2, coefficient2)
    else ok (cb_src_read1, accumulator2, n_bits_in_accumulator1, coefficient1)
  else
    do
    let n_bits_to_decode ←
      ntt.min n_bits_per_coefficient n_bits_in_accumulator
    massert (n_bits_to_decode <= n_bits_in_accumulator)
    let i ← 1#u32 <<< n_bits_to_decode
    let i1 ← i - 1#u32
    let bits_to_decode ← (↑(accumulator &&& i1) : Result U32)
    let accumulator1 ← accumulator >>> n_bits_to_decode
    let n_bits_in_accumulator1 ← n_bits_in_accumulator - n_bits_to_decode
    let coefficient1 ← (↑(coefficient ||| bits_to_decode) : Result U32)
    if n_bits_per_coefficient > n_bits_to_decode
    then
      do
      massert (n_bits_in_accumulator1 = 0#u32)
      let a ← ntt.slice_to_sub_array4 pb_src cb_src_read
      let accumulator2 ← (↑(core.num.U32.from_le_bytes a) : Result U32)
      let cb_src_read1 ← cb_src_read + 4#usize
      let n_bits_to_decode1 ← n_bits_per_coefficient - n_bits_to_decode
      massert (n_bits_to_decode1 <= 32#u32)
      let i2 ← 1#u32 <<< n_bits_to_decode1
      let i3 ← i2 - 1#u32
      let bits_to_decode1 ← (↑(accumulator2 &&& i3) : Result U32)
      let accumulator3 ← accumulator2 >>> n_bits_to_decode1
      let n_bits_in_accumulator2 ← 32#u32 - n_bits_to_decode1
      let i4 ← bits_to_decode1 <<< n_bits_to_decode
      let coefficient2 ← (↑(coefficient1 ||| i4) : Result U32)
      ok (cb_src_read1, accumulator3, n_bits_in_accumulator2, coefficient2)
    else ok (cb_src_read, accumulator1, n_bits_in_accumulator1, coefficient1)

/- [symcrust::ntt::decompress_coefficient]:
   Source: 'src/ntt.rs', lines 707:0-742:1 -/
def ntt.decompress_coefficient
  (i : Usize) (n_bits_per_coefficient : U32) (coefficient : U32)
  (pe_dst : Array U16 256#usize) :
  Result (common.Error × U32 × (Array U16 256#usize))
  :=
  if n_bits_per_coefficient < 12#u32
  then
    do
    let coefficient1 ← coefficient * ntt.Q
    let i1 ← n_bits_per_coefficient - 1#u32
    let coefficient2 ← coefficient1 >>> i1
    let coefficient3 ← coefficient2 + 1#u32
    let coefficient4 ← coefficient3 >>> 1#i32
    massert (coefficient4 < ntt.Q)
    let i2 ← (↑(UScalar.cast .U16 coefficient4) : Result U16)
    let pe_dst1 ← Array.update pe_dst i i2
    ok (common.Error.NoError, coefficient4, pe_dst1)
  else
    if coefficient > ntt.Q
    then ok (common.Error.InvalidBlob, coefficient, pe_dst)
    else
      do
      let i1 ← (↑(UScalar.cast .U16 coefficient) : Result U16)
      let pe_dst1 ← Array.update pe_dst i i1
      ok (common.Error.NoError, coefficient, pe_dst1)

/- [symcrust::ntt::poly_element_decode_and_decompress]: loop 0:
   Source: 'src/ntt.rs', lines 41:8-768:5 -/
def ntt.poly_element_decode_and_decompress_loop
  (pb_src : Slice U8) (n_bits_per_coefficient : U32)
  (pe_dst : Array U16 256#usize) (cb_src_read : Usize) (accumulator : U32)
  (n_bits_in_accumulator : U32) (i : Usize) :
  Result (common.Error × (Array U16 256#usize))
  :=
  if i < key.MLWE_POLYNOMIAL_COEFFICIENTS
  then
    do
    let (cb_src_read1, accumulator1, n_bits_in_accumulator1, coefficient) ←
      ntt.decode_coefficient pb_src n_bits_per_coefficient cb_src_read
        accumulator n_bits_in_accumulator 0#u32
    let (_, _, pe_dst1) ←
      ntt.decompress_coefficient i n_bits_per_coefficient coefficient pe_dst
    let i1 ← i + 1#usize
    ntt.poly_element_decode_and_decompress_loop pb_src n_bits_per_coefficient
      pe_dst1 cb_src_read1 accumulator1 n_bits_in_accumulator1 i1
  else ok (common.Error.NoError, pe_dst)
partial_fixpoint

/- [symcrust::ntt::poly_element_decode_and_decompress]:
   Source: 'src/ntt.rs', lines 744:0-777:1 -/
def ntt.poly_element_decode_and_decompress
  (pb_src : Slice U8) (n_bits_per_coefficient : U32)
  (pe_dst : Array U16 256#usize) :
  Result (common.Error × (Array U16 256#usize))
  :=
  do
  massert (n_bits_per_coefficient > 0#u32)
  massert (n_bits_per_coefficient <= 12#u32)
  ntt.poly_element_decode_and_decompress_loop pb_src n_bits_per_coefficient
    pe_dst 0#usize 0#u32 0#u32 0#usize

/- [symcrust::ntt::poly_element_sample_ntt_from_shake128]: loop 0:
   Source: 'src/ntt.rs', lines 788:10-788:40 -/
def ntt.poly_element_sample_ntt_from_shake128_loop
  (p_state : hash.HashState) (pe_dst : Array U16 256#usize) (i : Usize)
  (shake_output_buf : Array U8 24#usize) (curr_buf_index : Usize) :
  Result (hash.HashState × (Array U16 256#usize))
  :=
  if i < key.MLWE_POLYNOMIAL_COEFFICIENTS
  then
    do
    let s ← (↑(Array.to_slice shake_output_buf) : Result (Slice U8))
    let i1 := Slice.len s
    massert (curr_buf_index <= i1)
    let s1 ← (↑(Array.to_slice shake_output_buf) : Result (Slice U8))
    let i2 := Slice.len s1
    if curr_buf_index = i2
    then
      do
      let (s2, to_slice_mut_back) ←
        (↑(Array.to_slice_mut shake_output_buf) : Result ((Slice U8) ×
          (Slice U8 → Array U8 24#usize)))
      let (p_state1, s3) ← hash.shake128_extract p_state s2 false
      let shake_output_buf1 := to_slice_mut_back s3
      let s4 ← (↑(Array.to_slice shake_output_buf1) : Result (Slice U8))
      let a ← ntt.slice_to_sub_array2 s4 0#usize
      let i3 ← (↑(core.num.U16.from_le_bytes a) : Result U16)
      let sample0 ← (↑(i3 &&& 4095#u16) : Result U16)
      let s5 ← (↑(Array.to_slice shake_output_buf1) : Result (Slice U8))
      let i4 ← 0#usize + 1#usize
      let a1 ← ntt.slice_to_sub_array2 s5 i4
      let i5 ← (↑(core.num.U16.from_le_bytes a1) : Result U16)
      let sample1 ← i5 >>> 4#i32
      let curr_buf_index1 ← 0#usize + 3#usize
      let i6 ← (↑(UScalar.cast .U32 sample0) : Result U32)
      let i7 ←
        (↑(UScalar.cast_fromBool .Usize (i6 < ntt.Q)) : Result Usize)
      let i8 ← i + i7
      if i8 < key.MLWE_POLYNOMIAL_COEFFICIENTS
      then
        do
        let pe_dst1 ← Array.update pe_dst i sample0
        let pe_dst2 ← Array.update pe_dst1 i8 sample1
        let i9 ← (↑(UScalar.cast .U32 sample1) : Result U32)
        let i10 ←
          (↑(UScalar.cast_fromBool .Usize (i9 < ntt.Q)) : Result Usize)
        let i11 ← i8 + i10
        ntt.poly_element_sample_ntt_from_shake128_loop p_state1 pe_dst2 i11
          shake_output_buf1 curr_buf_index1
      else
        do
        let pe_dst1 ← Array.update pe_dst i sample0
        ntt.poly_element_sample_ntt_from_shake128_loop p_state1 pe_dst1 i8
          shake_output_buf1 curr_buf_index1
    else
      do
      let s2 ← (↑(Array.to_slice shake_output_buf) : Result (Slice U8))
      let a ← ntt.slice_to_sub_array2 s2 curr_buf_index
      let i3 ← (↑(core.num.U16.from_le_bytes a) : Result U16)
      let sample0 ← (↑(i3 &&& 4095#u16) : Result U16)
      let s3 ← (↑(Array.to_slice shake_output_buf) : Result (Slice U8))
      let i4 ← curr_buf_index + 1#usize
      let a1 ← ntt.slice_to_sub_array2 s3 i4
      let i5 ← (↑(core.num.U16.from_le_bytes a1) : Result U16)
      let sample1 ← i5 >>> 4#i32
      let curr_buf_index1 ← curr_buf_index + 3#usize
      let i6 ← (↑(UScalar.cast .U32 sample0) : Result U32)
      let i7 ←
        (↑(UScalar.cast_fromBool .Usize (i6 < ntt.Q)) : Result Usize)
      let i8 ← i + i7
      if i8 < key.MLWE_POLYNOMIAL_COEFFICIENTS
      then
        do
        let pe_dst1 ← Array.update pe_dst i sample0
        let pe_dst2 ← Array.update pe_dst1 i8 sample1
        let i9 ← (↑(UScalar.cast .U32 sample1) : Result U32)
        let i10 ←
          (↑(UScalar.cast_fromBool .Usize (i9 < ntt.Q)) : Result Usize)
        let i11 ← i8 + i10
        ntt.poly_element_sample_ntt_from_shake128_loop p_state pe_dst2 i11
          shake_output_buf curr_buf_index1
      else
        do
        let pe_dst1 ← Array.update pe_dst i sample0
        ntt.poly_element_sample_ntt_from_shake128_loop p_state pe_dst1 i8
          shake_output_buf curr_buf_index1
  else ok (p_state, pe_dst)
partial_fixpoint

/- [symcrust::ntt::poly_element_sample_ntt_from_shake128]:
   Source: 'src/ntt.rs', lines 779:0-812:1 -/
def ntt.poly_element_sample_ntt_from_shake128
  (p_state : hash.HashState) (pe_dst : Array U16 256#usize) :
  Result (hash.HashState × (Array U16 256#usize))
  :=
  do
  let shake_output_buf := Array.repeat 24#usize 0#u8
  let s ← (↑(Array.to_slice shake_output_buf) : Result (Slice U8))
  let curr_buf_index := Slice.len s
  ntt.poly_element_sample_ntt_from_shake128_loop p_state pe_dst 0#usize
    shake_output_buf curr_buf_index

/- [symcrust::ntt::poly_element_sample_cbd_from_bytes_eta3_inner_loop]: loop 0:
   Source: 'src/ntt.rs', lines 42:12-826:75 -/
def ntt.poly_element_sample_cbd_from_bytes_eta3_inner_loop_loop
  (pe_dst : Array U16 256#usize) (i : Usize) (sample_bits : U32) (j : Usize) :
  Result ((Array U16 256#usize) × U32)
  :=
  if j < 4#usize
  then
    do
    let coefficient ← (↑(sample_bits &&& 63#u32) : Result U32)
    let sample_bits1 ← sample_bits >>> 6#i32
    let i1 ← (↑(coefficient &&& 3#u32) : Result U32)
    let i2 ← coefficient >>> 3#i32
    let coefficient1 ← (↑(core.num.U32.wrapping_sub i1 i2) : Result U32)
    let i3 ← coefficient1 >>> 16#i32
    let i4 ← (↑(ntt.Q &&& i3) : Result U32)
    let coefficient2 ←
      (↑(core.num.U32.wrapping_add coefficient1 i4) : Result U32)
    massert (coefficient2 < ntt.Q)
    let i5 ← i + j
    let i6 ← (↑(UScalar.cast .U16 coefficient2) : Result U16)
    let pe_dst1 ← Array.update pe_dst i5 i6
    let j1 ← j + 1#usize
    ntt.poly_element_sample_cbd_from_bytes_eta3_inner_loop_loop pe_dst1 i
      sample_bits1 j1
  else ok (pe_dst, sample_bits)
partial_fixpoint

/- [symcrust::ntt::poly_element_sample_cbd_from_bytes_eta3_inner_loop]:
   Source: 'src/ntt.rs', lines 815:0-831:1 -/
@[reducible]
def ntt.poly_element_sample_cbd_from_bytes_eta3_inner_loop
  (pe_dst : Array U16 256#usize) (i : Usize) (sample_bits : U32) :
  Result ((Array U16 256#usize) × U32)
  :=
  ntt.poly_element_sample_cbd_from_bytes_eta3_inner_loop_loop pe_dst i
    sample_bits 0#usize

/- [symcrust::ntt::poly_element_sample_cbd_from_bytes_eta3_loop]: loop 0:
   Source: 'src/ntt.rs', lines 41:8-849:9 -/
def ntt.poly_element_sample_cbd_from_bytes_eta3_loop_loop
  (pb_src : Slice U8) (pe_dst : Array U16 256#usize) (src_i : Usize)
  (i : Usize) :
  Result (Array U16 256#usize)
  :=
  if i < key.MLWE_POLYNOMIAL_COEFFICIENTS
  then
    do
    let a ← ntt.slice_to_sub_array4 pb_src src_i
    let sample_bits ← (↑(core.num.U32.from_le_bytes a) : Result U32)
    let src_i1 ← src_i + 3#usize
    let i1 ← (↑(sample_bits &&& 2396745#u32) : Result U32)
    let i2 ← sample_bits >>> 1#i32
    let i3 ← (↑(i2 &&& 2396745#u32) : Result U32)
    let i4 ← i1 + i3
    let i5 ← sample_bits >>> 2#i32
    let i6 ← (↑(i5 &&& 2396745#u32) : Result U32)
    let sample_bits1 ← i4 + i6
    let (pe_dst1, _) ←
      ntt.poly_element_sample_cbd_from_bytes_eta3_inner_loop pe_dst i
        sample_bits1
    let i7 ← i + 4#usize
    ntt.poly_element_sample_cbd_from_bytes_eta3_loop_loop pb_src pe_dst1 src_i1
      i7
  else ok pe_dst
partial_fixpoint

/- [symcrust::ntt::poly_element_sample_cbd_from_bytes_eta3_loop]:
   Source: 'src/ntt.rs', lines 834:0-850:1 -/
@[reducible]
def ntt.poly_element_sample_cbd_from_bytes_eta3_loop
  (pb_src : Slice U8) (pe_dst : Array U16 256#usize) :
  Result (Array U16 256#usize)
  :=
  ntt.poly_element_sample_cbd_from_bytes_eta3_loop_loop pb_src pe_dst 0#usize
    0#usize

/- [symcrust::ntt::poly_element_sample_cbd_from_bytes_eta2_inner_loop]: loop 0:
   Source: 'src/ntt.rs', lines 42:12-864:75 -/
def ntt.poly_element_sample_cbd_from_bytes_eta2_inner_loop_loop
  (pe_dst : Array U16 256#usize) (i : Usize) (sample_bits : U32) (j : Usize) :
  Result ((Array U16 256#usize) × U32)
  :=
  if j < 8#usize
  then
    do
    let coefficient ← (↑(sample_bits &&& 15#u32) : Result U32)
    let sample_bits1 ← sample_bits >>> 4#i32
    let i1 ← (↑(coefficient &&& 3#u32) : Result U32)
    let i2 ← coefficient >>> 2#i32
    let coefficient1 ← (↑(core.num.U32.wrapping_sub i1 i2) : Result U32)
    let i3 ← coefficient1 >>> 16#i32
    let i4 ← (↑(ntt.Q &&& i3) : Result U32)
    let coefficient2 ←
      (↑(core.num.U32.wrapping_add coefficient1 i4) : Result U32)
    massert (coefficient2 < ntt.Q)
    let i5 ← i + j
    let i6 ← (↑(UScalar.cast .U16 coefficient2) : Result U16)
    let pe_dst1 ← Array.update pe_dst i5 i6
    let j1 ← j + 1#usize
    ntt.poly_element_sample_cbd_from_bytes_eta2_inner_loop_loop pe_dst1 i
      sample_bits1 j1
  else ok (pe_dst, sample_bits)
partial_fixpoint

/- [symcrust::ntt::poly_element_sample_cbd_from_bytes_eta2_inner_loop]:
   Source: 'src/ntt.rs', lines 853:0-869:1 -/
@[reducible]
def ntt.poly_element_sample_cbd_from_bytes_eta2_inner_loop
  (pe_dst : Array U16 256#usize) (i : Usize) (sample_bits : U32) :
  Result ((Array U16 256#usize) × U32)
  :=
  ntt.poly_element_sample_cbd_from_bytes_eta2_inner_loop_loop pe_dst i
    sample_bits 0#usize

/- [symcrust::ntt::poly_element_sample_cbd_from_bytes_eta2_loop]: loop 0:
   Source: 'src/ntt.rs', lines 41:8-885:9 -/
def ntt.poly_element_sample_cbd_from_bytes_eta2_loop_loop
  (pb_src : Slice U8) (pe_dst : Array U16 256#usize) (src_i : Usize)
  (i : Usize) :
  Result (Array U16 256#usize)
  :=
  if i < key.MLWE_POLYNOMIAL_COEFFICIENTS
  then
    do
    let a ← ntt.slice_to_sub_array4 pb_src src_i
    let sample_bits ← (↑(core.num.U32.from_le_bytes a) : Result U32)
    let src_i1 ← src_i + 4#usize
    let i1 ← (↑(sample_bits &&& 1431655765#u32) : Result U32)
    let i2 ← sample_bits >>> 1#i32
    let i3 ← (↑(i2 &&& 1431655765#u32) : Result U32)
    let sample_bits1 ← i1 + i3
    let (pe_dst1, _) ←
      ntt.poly_element_sample_cbd_from_bytes_eta2_inner_loop pe_dst i
        sample_bits1
    let i4 ← i + 8#usize
    ntt.poly_element_sample_cbd_from_bytes_eta2_loop_loop pb_src pe_dst1 src_i1
      i4
  else ok pe_dst
partial_fixpoint

/- [symcrust::ntt::poly_element_sample_cbd_from_bytes_eta2_loop]:
   Source: 'src/ntt.rs', lines 872:0-886:1 -/
@[reducible]
def ntt.poly_element_sample_cbd_from_bytes_eta2_loop
  (pb_src : Slice U8) (pe_dst : Array U16 256#usize) :
  Result (Array U16 256#usize)
  :=
  ntt.poly_element_sample_cbd_from_bytes_eta2_loop_loop pb_src pe_dst 0#usize
    0#usize

/- [symcrust::ntt::poly_element_sample_cbd_from_bytes]:
   Source: 'src/ntt.rs', lines 888:0-904:1 -/
def ntt.poly_element_sample_cbd_from_bytes
  (pb_src : Slice U8) (eta : U32) (pe_dst : Array U16 256#usize) :
  Result (Array U16 256#usize)
  :=
  if eta = 3#u32
  then ntt.poly_element_sample_cbd_from_bytes_eta3_loop pb_src pe_dst
  else ntt.poly_element_sample_cbd_from_bytes_eta2_loop pb_src pe_dst

/- [symcrust::ntt::matrix_transpose::inner_loop]: loop 0:
   Source: 'src/ntt.rs', lines 41:8-922:13 -/
def ntt.matrix_transpose.inner_loop_loop
  (pm_src : Slice (Array U16 256#usize)) (n_rows : Usize) (i : Usize)
  (j : Usize) :
  Result (Slice (Array U16 256#usize))
  :=
  if j < n_rows
  then
    do
    let i1 ← i * n_rows
    let i2 ← i1 + j
    let i3 ← j * n_rows
    let i4 ← i3 + i
    let pm_src1 ← core.slice.Slice.swap pm_src i2 i4
    let j1 ← j + 1#usize
    ntt.matrix_transpose.inner_loop_loop pm_src1 n_rows i j1
  else ok pm_src
partial_fixpoint

/- [symcrust::ntt::matrix_transpose::inner_loop]:
   Source: 'src/ntt.rs', lines 918:8-923:9 -/
def ntt.matrix_transpose.inner_loop
  (pm_src : Slice (Array U16 256#usize)) (n_rows : Usize) (i : Usize) :
  Result (Slice (Array U16 256#usize))
  :=
  do
  let j ← i + 1#usize
  ntt.matrix_transpose.inner_loop_loop pm_src n_rows i j

/- [symcrust::ntt::matrix_transpose]: loop 0:
   Source: 'src/ntt.rs', lines 41:8-925:5 -/
def ntt.matrix_transpose_loop
  (pm_src : Slice (Array U16 256#usize)) (n_rows : Usize) (i : Usize) :
  Result (Slice (Array U16 256#usize))
  :=
  if i < n_rows
  then
    do
    let pm_src1 ← ntt.matrix_transpose.inner_loop pm_src n_rows i
    let i1 ← i + 1#usize
    ntt.matrix_transpose_loop pm_src1 n_rows i1
  else ok pm_src
partial_fixpoint

/- [symcrust::ntt::matrix_transpose]:
   Source: 'src/ntt.rs', lines 906:0-926:1 -/
def ntt.matrix_transpose
  (pm_src : Slice (Array U16 256#usize)) (n_rows : U8) :
  Result (Slice (Array U16 256#usize))
  :=
  do
  let n_rows1 ← (↑(UScalar.cast .Usize n_rows) : Result Usize)
  massert (n_rows1 > 0#usize)
  massert (n_rows1 <= ntt.MATRIX_MAX_NROWS)
  ntt.matrix_transpose_loop pm_src n_rows1 0#usize

/- [symcrust::ntt::poly_element_mul_and_accumulate_aux]:
   Source: 'src/ntt.rs', lines 930:0-940:1 -/
def ntt.poly_element_mul_and_accumulate_aux
  (pm_src1 : Slice (Array U16 256#usize)) (n_rows : Usize) (i : Usize)
  (j : Usize) (pe_src2 : Array U16 256#usize) (pa_tmp : Array U32 256#usize) :
  Result ((Slice (Array U16 256#usize)) × (Array U32 256#usize))
  :=
  do
  let i1 ← i * n_rows
  let i2 ← i1 + j
  let src1 ← Slice.index_usize pm_src1 i2
  let pa_tmp1 ← ntt.poly_element_mul_and_accumulate src1 pe_src2 pa_tmp
  ok (pm_src1, pa_tmp1)

/- [symcrust::ntt::matrix_vector_mont_mul_and_add::inner_loop]: loop 0:
   Source: 'src/ntt.rs', lines 41:8-974:13 -/
def ntt.matrix_vector_mont_mul_and_add.inner_loop_loop
  (pm_src1 : Slice (Array U16 256#usize))
  (pv_src2 : Slice (Array U16 256#usize)) (pa_tmp : Array U32 256#usize)
  (n_rows : Usize) (i : Usize) (j : Usize) :
  Result ((Slice (Array U16 256#usize)) × (Array U32 256#usize))
  :=
  if j < n_rows
  then
    do
    let a ← Slice.index_usize pv_src2 j
    let (pm_src11, pa_tmp1) ←
      ntt.poly_element_mul_and_accumulate_aux pm_src1 n_rows i j a pa_tmp
    let j1 ← j + 1#usize
    ntt.matrix_vector_mont_mul_and_add.inner_loop_loop pm_src11 pv_src2 pa_tmp1
      n_rows i j1
  else ok (pm_src1, pa_tmp)
partial_fixpoint

/- [symcrust::ntt::matrix_vector_mont_mul_and_add::inner_loop]:
   Source: 'src/ntt.rs', lines 965:8-975:9 -/
@[reducible]
def ntt.matrix_vector_mont_mul_and_add.inner_loop
  (pm_src1 : Slice (Array U16 256#usize))
  (pv_src2 : Slice (Array U16 256#usize)) (pa_tmp : Array U32 256#usize)
  (n_rows : Usize) (i : Usize) :
  Result ((Slice (Array U16 256#usize)) × (Array U32 256#usize))
  :=
  ntt.matrix_vector_mont_mul_and_add.inner_loop_loop pm_src1 pv_src2 pa_tmp
    n_rows i 0#usize

/- [symcrust::ntt::matrix_vector_mont_mul_and_add]: loop 0:
   Source: 'src/ntt.rs', lines 41:8-980:5 -/
def ntt.matrix_vector_mont_mul_and_add_loop
  (pm_src1 : Slice (Array U16 256#usize))
  (pv_src2 : Slice (Array U16 256#usize))
  (pv_dst : Slice (Array U16 256#usize)) (pa_tmp : Array U32 256#usize)
  (n_rows : Usize) (i : Usize) :
  Result ((Slice (Array U16 256#usize)) × (Slice (Array U16 256#usize)) ×
    (Array U32 256#usize))
  :=
  if i < n_rows
  then
    do
    let (pm_src11, pa_tmp1) ←
      ntt.matrix_vector_mont_mul_and_add.inner_loop pm_src1 pv_src2 pa_tmp
        n_rows i
    let (a, index_mut_back) ← Slice.index_mut_usize pv_dst i
    let (pa_tmp2, a1) ←
      ntt.montgomery_reduce_and_add_poly_element_accumulator_to_poly_element
        pa_tmp1 a
    let i1 ← i + 1#usize
    let pv_dst1 := index_mut_back a1
    ntt.matrix_vector_mont_mul_and_add_loop pm_src11 pv_src2 pv_dst1 pa_tmp2
      n_rows i1
  else ok (pm_src1, pv_dst, pa_tmp)
partial_fixpoint

/- [symcrust::ntt::matrix_vector_mont_mul_and_add]:
   Source: 'src/ntt.rs', lines 942:0-981:1 -/
def ntt.matrix_vector_mont_mul_and_add
  (pm_src1 : Slice (Array U16 256#usize))
  (pv_src2 : Slice (Array U16 256#usize))
  (pv_dst : Slice (Array U16 256#usize)) (pa_tmp : Array U32 256#usize)
  (n_rows : U8) :
  Result ((Slice (Array U16 256#usize)) × (Slice (Array U16 256#usize)) ×
    (Array U32 256#usize))
  :=
  do
  let n_rows1 ← (↑(UScalar.cast .Usize n_rows) : Result Usize)
  massert (n_rows1 > 0#usize)
  massert (n_rows1 <= ntt.MATRIX_MAX_NROWS)
  let left_val := Slice.len pv_src2
  massert (left_val = n_rows1)
  let left_val1 := Slice.len pv_dst
  massert (left_val1 = n_rows1)
  let (s, to_slice_mut_back) ←
    (↑(Array.to_slice_mut pa_tmp) : Result ((Slice U32) × (Slice U32 →
      Array U32 256#usize)))
  let s1 ← common.wipe_slice s
  let pa_tmp1 := to_slice_mut_back s1
  ntt.matrix_vector_mont_mul_and_add_loop pm_src1 pv_src2 pv_dst pa_tmp1
    n_rows1 0#usize

/- [symcrust::ntt::vector_mont_dot_product]: loop 0:
   Source: 'src/ntt.rs', lines 41:8-1004:5 -/
def ntt.vector_mont_dot_product_loop
  (pv_src1 : Slice (Array U16 256#usize))
  (pv_src2 : Slice (Array U16 256#usize)) (pe_dst : Array U16 256#usize)
  (pa_tmp : Array U32 256#usize) (n_rows : Usize) (i : Usize) :
  Result (Array U32 256#usize)
  :=
  if i < n_rows
  then
    do
    let a ← Slice.index_usize pv_src1 i
    let a1 ← Slice.index_usize pv_src2 i
    let pa_tmp1 ← ntt.poly_element_mul_and_accumulate a a1 pa_tmp
    let i1 ← i + 1#usize
    ntt.vector_mont_dot_product_loop pv_src1 pv_src2 pe_dst pa_tmp1 n_rows i1
  else
    do
    let (pa_tmp1, _) ←
      ntt.montgomery_reduce_and_add_poly_element_accumulator_to_poly_element
        pa_tmp pe_dst
    ok pa_tmp1
partial_fixpoint

/- [symcrust::ntt::vector_mont_dot_product]:
   Source: 'src/ntt.rs', lines 983:0-1008:1 -/
def ntt.vector_mont_dot_product
  (pv_src1 : Slice (Array U16 256#usize))
  (pv_src2 : Slice (Array U16 256#usize)) (pe_dst : Array U16 256#usize)
  (pa_tmp : Array U32 256#usize) :
  Result ((Slice (Array U16 256#usize)) × (Slice (Array U16 256#usize)) ×
    (Array U16 256#usize) × (Array U32 256#usize))
  :=
  do
  let n_rows := Slice.len pv_src1
  massert (n_rows > 0#usize)
  massert (n_rows <= ntt.MATRIX_MAX_NROWS)
  let i := Slice.len pv_src2
  massert (i = n_rows)
  let (s, to_slice_mut_back) ←
    (↑(Array.to_slice_mut pa_tmp) : Result ((Slice U32) × (Slice U32 →
      Array U32 256#usize)))
  let s1 ← common.wipe_slice s
  let (s2, to_slice_mut_back1) ←
    (↑(Array.to_slice_mut pe_dst) : Result ((Slice U16) × (Slice U16 →
      Array U16 256#usize)))
  let s3 ← common.wipe_slice s2
  let pe_dst1 := to_slice_mut_back1 s3
  let pa_tmp1 := to_slice_mut_back s1
  let pa_tmp2 ←
    ntt.vector_mont_dot_product_loop pv_src1 pv_src2 pe_dst1 pa_tmp1 n_rows
      0#usize
  ok (pv_src1, pv_src2, pe_dst1, pa_tmp2)

/- [symcrust::ntt::vector_set_zero]: loop 0:
   Source: 'src/ntt.rs', lines 41:8-1023:5 -/
def ntt.vector_set_zero_loop
  (pv_src : Slice (Array U16 256#usize)) (n_rows : Usize) (i : Usize) :
  Result (Slice (Array U16 256#usize))
  :=
  if i < n_rows
  then
    do
    let (a, index_mut_back) ← Slice.index_mut_usize pv_src i
    let (s, to_slice_mut_back) ←
      (↑(Array.to_slice_mut a) : Result ((Slice U16) × (Slice U16 → Array
        U16 256#usize)))
    let s1 ← common.wipe_slice s
    let i1 ← i + 1#usize
    let a1 := to_slice_mut_back s1
    let pv_src1 := index_mut_back a1
    ntt.vector_set_zero_loop pv_src1 n_rows i1
  else ok pv_src
partial_fixpoint

/- [symcrust::ntt::vector_set_zero]:
   Source: 'src/ntt.rs', lines 1010:0-1024:1 -/
def ntt.vector_set_zero
  (pv_src : Slice (Array U16 256#usize)) :
  Result (Slice (Array U16 256#usize))
  :=
  do
  let n_rows := Slice.len pv_src
  massert (n_rows > 0#usize)
  massert (n_rows <= ntt.MATRIX_MAX_NROWS)
  ntt.vector_set_zero_loop pv_src n_rows 0#usize

/- [symcrust::ntt::vector_mul_r]: loop 0:
   Source: 'src/ntt.rs', lines 41:8-1041:5 -/
def ntt.vector_mul_r_loop
  (pv_src : Slice (Array U16 256#usize)) (pv_dst : Slice (Array U16 256#usize))
  (n_rows : Usize) (i : Usize) :
  Result (Slice (Array U16 256#usize))
  :=
  if i < n_rows
  then
    do
    let a ← Slice.index_usize pv_src i
    let (a1, index_mut_back) ← Slice.index_mut_usize pv_dst i
    let a2 ← ntt.poly_element_mul_r a a1
    let i1 ← i + 1#usize
    let pv_dst1 := index_mut_back a2
    ntt.vector_mul_r_loop pv_src pv_dst1 n_rows i1
  else ok pv_dst
partial_fixpoint

/- [symcrust::ntt::vector_mul_r]:
   Source: 'src/ntt.rs', lines 1026:0-1042:1 -/
def ntt.vector_mul_r
  (pv_src : Slice (Array U16 256#usize)) (pv_dst : Slice (Array U16 256#usize))
  :
  Result (Slice (Array U16 256#usize))
  :=
  do
  let n_rows := Slice.len pv_src
  massert (n_rows > 0#usize)
  massert (n_rows <= ntt.MATRIX_MAX_NROWS)
  let i := Slice.len pv_dst
  massert (i = n_rows)
  ntt.vector_mul_r_loop pv_src pv_dst n_rows 0#usize

/- [symcrust::ntt::vector_add]: loop 0:
   Source: 'src/ntt.rs', lines 41:8-1060:5 -/
def ntt.vector_add_loop
  (pv_src1 : Slice (Array U16 256#usize))
  (pv_src2 : Slice (Array U16 256#usize))
  (pv_dst : Slice (Array U16 256#usize)) (n_rows : Usize) (i : Usize) :
  Result (Slice (Array U16 256#usize))
  :=
  if i < n_rows
  then
    do
    let a ← Slice.index_usize pv_src1 i
    let a1 ← Slice.index_usize pv_src2 i
    let (a2, index_mut_back) ← Slice.index_mut_usize pv_dst i
    let a3 ← ntt.poly_element_add a a1 a2
    let i1 ← i + 1#usize
    let pv_dst1 := index_mut_back a3
    ntt.vector_add_loop pv_src1 pv_src2 pv_dst1 n_rows i1
  else ok pv_dst
partial_fixpoint

/- [symcrust::ntt::vector_add]:
   Source: 'src/ntt.rs', lines 1044:0-1061:1 -/
def ntt.vector_add
  (pv_src1 : Slice (Array U16 256#usize))
  (pv_src2 : Slice (Array U16 256#usize))
  (pv_dst : Slice (Array U16 256#usize)) :
  Result (Slice (Array U16 256#usize))
  :=
  do
  let n_rows := Slice.len pv_src1
  massert (n_rows > 0#usize)
  massert (n_rows <= ntt.MATRIX_MAX_NROWS)
  let i := Slice.len pv_src2
  massert (i = n_rows)
  let i1 := Slice.len pv_dst
  massert (i1 = n_rows)
  ntt.vector_add_loop pv_src1 pv_src2 pv_dst n_rows 0#usize

/- [symcrust::ntt::vector_sub]: loop 0:
   Source: 'src/ntt.rs', lines 41:8-1079:5 -/
def ntt.vector_sub_loop
  (pv_src1 : Slice (Array U16 256#usize))
  (pv_src2 : Slice (Array U16 256#usize))
  (pv_dst : Slice (Array U16 256#usize)) (n_rows : Usize) (i : Usize) :
  Result (Slice (Array U16 256#usize))
  :=
  if i < n_rows
  then
    do
    let a ← Slice.index_usize pv_src1 i
    let a1 ← Slice.index_usize pv_src2 i
    let (a2, index_mut_back) ← Slice.index_mut_usize pv_dst i
    let a3 ← ntt.poly_element_sub a a1 a2
    let i1 ← i + 1#usize
    let pv_dst1 := index_mut_back a3
    ntt.vector_sub_loop pv_src1 pv_src2 pv_dst1 n_rows i1
  else ok pv_dst
partial_fixpoint

/- [symcrust::ntt::vector_sub]:
   Source: 'src/ntt.rs', lines 1063:0-1080:1 -/
def ntt.vector_sub
  (pv_src1 : Slice (Array U16 256#usize))
  (pv_src2 : Slice (Array U16 256#usize))
  (pv_dst : Slice (Array U16 256#usize)) :
  Result (Slice (Array U16 256#usize))
  :=
  do
  let n_rows := Slice.len pv_src1
  massert (n_rows > 0#usize)
  massert (n_rows <= ntt.MATRIX_MAX_NROWS)
  let i := Slice.len pv_src2
  massert (i = n_rows)
  let i1 := Slice.len pv_dst
  massert (i1 = n_rows)
  ntt.vector_sub_loop pv_src1 pv_src2 pv_dst n_rows 0#usize

/- [symcrust::ntt::vector_ntt]: loop 0:
   Source: 'src/ntt.rs', lines 41:8-1095:5 -/
def ntt.vector_ntt_loop
  (pv_src : Slice (Array U16 256#usize)) (n_rows : Usize) (i : Usize) :
  Result (Slice (Array U16 256#usize))
  :=
  if i < n_rows
  then
    do
    let (a, index_mut_back) ← Slice.index_mut_usize pv_src i
    let a1 ← ntt.poly_element_ntt a
    let i1 ← i + 1#usize
    let pv_src1 := index_mut_back a1
    ntt.vector_ntt_loop pv_src1 n_rows i1
  else ok pv_src
partial_fixpoint

/- [symcrust::ntt::vector_ntt]:
   Source: 'src/ntt.rs', lines 1082:0-1096:1 -/
def ntt.vector_ntt
  (pv_src : Slice (Array U16 256#usize)) :
  Result (Slice (Array U16 256#usize))
  :=
  do
  let n_rows := Slice.len pv_src
  massert (n_rows > 0#usize)
  massert (n_rows <= ntt.MATRIX_MAX_NROWS)
  ntt.vector_ntt_loop pv_src n_rows 0#usize

/- [symcrust::ntt::vector_intt_and_mul_r]: loop 0:
   Source: 'src/ntt.rs', lines 41:8-1111:5 -/
def ntt.vector_intt_and_mul_r_loop
  (pv_src : Slice (Array U16 256#usize)) (n_rows : Usize) (i : Usize) :
  Result (Slice (Array U16 256#usize))
  :=
  if i < n_rows
  then
    do
    let (a, index_mut_back) ← Slice.index_mut_usize pv_src i
    let a1 ← ntt.poly_element_intt_and_mul_r a
    let i1 ← i + 1#usize
    let pv_src1 := index_mut_back a1
    ntt.vector_intt_and_mul_r_loop pv_src1 n_rows i1
  else ok pv_src
partial_fixpoint

/- [symcrust::ntt::vector_intt_and_mul_r]:
   Source: 'src/ntt.rs', lines 1098:0-1112:1 -/
def ntt.vector_intt_and_mul_r
  (pv_src : Slice (Array U16 256#usize)) :
  Result (Slice (Array U16 256#usize))
  :=
  do
  let n_rows := Slice.len pv_src
  massert (n_rows > 0#usize)
  massert (n_rows <= ntt.MATRIX_MAX_NROWS)
  ntt.vector_intt_and_mul_r_loop pv_src n_rows 0#usize

/- [symcrust::ntt::vector_compress_and_encode]: loop 0:
   Source: 'src/ntt.rs', lines 41:8-1135:5 -/
def ntt.vector_compress_and_encode_loop
  (pv_src : Slice (Array U16 256#usize)) (n_bits_per_coefficient : U32)
  (pb_dst : Slice U8) (n_rows : Usize) (i : Usize) :
  Result (Slice U8)
  :=
  if i < n_rows
  then
    do
    let i1 ← (↑(UScalar.cast .Usize n_bits_per_coefficient) : Result Usize)
    let i2 ← i * i1
    let i3 ← key.MLWE_POLYNOMIAL_COEFFICIENTS / 8#usize
    let pb_dst_index ← i2 * i3
    let a ← Slice.index_usize pv_src i
    let (s, index_mut_back) ←
      core.slice.index.Slice.index_mut
        (core.slice.index.SliceIndexRangeFromUsizeSlice U8) pb_dst
        { start := pb_dst_index }
    let s1 ← ntt.poly_element_compress_and_encode a n_bits_per_coefficient s
    let i4 ← i + 1#usize
    let pb_dst1 := index_mut_back s1
    ntt.vector_compress_and_encode_loop pv_src n_bits_per_coefficient pb_dst1
      n_rows i4
  else ok pb_dst
partial_fixpoint

/- [symcrust::ntt::vector_compress_and_encode]:
   Source: 'src/ntt.rs', lines 1114:0-1136:1 -/
def ntt.vector_compress_and_encode
  (pv_src : Slice (Array U16 256#usize)) (n_bits_per_coefficient : U32)
  (pb_dst : Slice U8) :
  Result (Slice U8)
  :=
  do
  let n_rows := Slice.len pv_src
  massert (n_rows > 0#usize)
  massert (n_rows <= ntt.MATRIX_MAX_NROWS)
  massert (n_bits_per_coefficient > 0#u32)
  massert (n_bits_per_coefficient <= 12#u32)
  let i := Slice.len pb_dst
  let i1 ←
    (↑(UScalar.cast .U32 key.MLWE_POLYNOMIAL_COEFFICIENTS) : Result U32)
  let i2 ← i1 / 8#u32
  let i3 ← n_bits_per_coefficient * i2
  let i4 ← (↑(UScalar.cast .Usize i3) : Result Usize)
  let i5 ← n_rows * i4
  massert (i = i5)
  ntt.vector_compress_and_encode_loop pv_src n_bits_per_coefficient pb_dst
    n_rows 0#usize

/- [symcrust::ntt::vector_decode_and_decompress]: loop 0:
   Source: 'src/ntt.rs', lines 41:8-1160:1 -/
def ntt.vector_decode_and_decompress_loop
  (pb_src : Slice U8) (n_bits_per_coefficient : U32)
  (pv_dst : Slice (Array U16 256#usize)) (n_rows : Usize) (i : Usize) :
  Result (common.Error × (Slice (Array U16 256#usize)))
  :=
  if i < n_rows
  then
    do
    let i1 ← (↑(UScalar.cast .Usize n_bits_per_coefficient) : Result Usize)
    let i2 ← i * i1
    let i3 ← key.MLWE_POLYNOMIAL_COEFFICIENTS / 8#usize
    let pb_src_index ← i2 * i3
    let s ←
      core.slice.index.Slice.index
        (core.slice.index.SliceIndexRangeFromUsizeSlice U8) pb_src
        { start := pb_src_index }
    let (a, index_mut_back) ← Slice.index_mut_usize pv_dst i
    let (sc_error, a1) ←
      ntt.poly_element_decode_and_decompress s n_bits_per_coefficient a
    match sc_error with
    | common.Error.NoError =>
      do
      let i4 ← i + 1#usize
      let pv_dst1 := index_mut_back a1
      ntt.vector_decode_and_decompress_loop pb_src n_bits_per_coefficient
        pv_dst1 n_rows i4
    | common.Error.Unused =>
      let pv_dst1 := index_mut_back a1
      ok (common.Error.Unused, pv_dst1)
    | common.Error.WrongKeySize =>
      let pv_dst1 := index_mut_back a1
      ok (common.Error.WrongKeySize, pv_dst1)
    | common.Error.WrongBlockSize =>
      let pv_dst1 := index_mut_back a1
      ok (common.Error.WrongBlockSize, pv_dst1)
    | common.Error.WrongDataSize =>
      let pv_dst1 := index_mut_back a1
      ok (common.Error.WrongDataSize, pv_dst1)
    | common.Error.WrongNonceSize =>
      let pv_dst1 := index_mut_back a1
      ok (common.Error.WrongNonceSize, pv_dst1)
    | common.Error.WrongTagSize =>
      let pv_dst1 := index_mut_back a1
      ok (common.Error.WrongTagSize, pv_dst1)
    | common.Error.WrongIterationCount =>
      let pv_dst1 := index_mut_back a1
      ok (common.Error.WrongIterationCount, pv_dst1)
    | common.Error.AuthenticationFailure =>
      let pv_dst1 := index_mut_back a1
      ok (common.Error.AuthenticationFailure, pv_dst1)
    | common.Error.ExternalFailure =>
      let pv_dst1 := index_mut_back a1
      ok (common.Error.ExternalFailure, pv_dst1)
    | common.Error.FipsFailure =>
      let pv_dst1 := index_mut_back a1
      ok (common.Error.FipsFailure, pv_dst1)
    | common.Error.HardwareFailure =>
      let pv_dst1 := index_mut_back a1
      ok (common.Error.HardwareFailure, pv_dst1)
    | common.Error.NotImplemented =>
      let pv_dst1 := index_mut_back a1
      ok (common.Error.NotImplemented, pv_dst1)
    | common.Error.InvalidBlob =>
      let pv_dst1 := index_mut_back a1
      ok (common.Error.InvalidBlob, pv_dst1)
    | common.Error.BufferTooSmall =>
      let pv_dst1 := index_mut_back a1
      ok (common.Error.BufferTooSmall, pv_dst1)
    | common.Error.InvalidArgument =>
      let pv_dst1 := index_mut_back a1
      ok (common.Error.InvalidArgument, pv_dst1)
    | common.Error.MemoryAllocationFailure =>
      let pv_dst1 := index_mut_back a1
      ok (common.Error.MemoryAllocationFailure, pv_dst1)
    | common.Error.SignatureVerificationFailure =>
      let pv_dst1 := index_mut_back a1
      ok (common.Error.SignatureVerificationFailure, pv_dst1)
    | common.Error.IncompatibleFormat =>
      let pv_dst1 := index_mut_back a1
      ok (common.Error.IncompatibleFormat, pv_dst1)
    | common.Error.ValueTooLarge =>
      let pv_dst1 := index_mut_back a1
      ok (common.Error.ValueTooLarge, pv_dst1)
    | common.Error.SessionReplayFailure =>
      let pv_dst1 := index_mut_back a1
      ok (common.Error.SessionReplayFailure, pv_dst1)
    | common.Error.HbsNoOtsKeysLeft =>
      let pv_dst1 := index_mut_back a1
      ok (common.Error.HbsNoOtsKeysLeft, pv_dst1)
    | common.Error.HbsPublicRootMismatch =>
      let pv_dst1 := index_mut_back a1
      ok (common.Error.HbsPublicRootMismatch, pv_dst1)
  else ok (common.Error.NoError, pv_dst)
partial_fixpoint

/- [symcrust::ntt::vector_decode_and_decompress]:
   Source: 'src/ntt.rs', lines 1138:0-1160:1 -/
def ntt.vector_decode_and_decompress
  (pb_src : Slice U8) (n_bits_per_coefficient : U32)
  (pv_dst : Slice (Array U16 256#usize)) :
  Result (common.Error × (Slice (Array U16 256#usize)))
  :=
  do
  let n_rows := Slice.len pv_dst
  massert (n_rows > 0#usize)
  massert (n_rows <= ntt.MATRIX_MAX_NROWS)
  massert (n_bits_per_coefficient > 0#u32)
  massert (n_bits_per_coefficient <= 12#u32)
  let i := Slice.len pb_src
  let i1 ← (↑(UScalar.cast .Usize n_bits_per_coefficient) : Result Usize)
  let i2 ← n_rows * i1
  let i3 ← key.MLWE_POLYNOMIAL_COEFFICIENTS / 8#usize
  let i4 ← i2 * i3
  massert (i = i4)
  ntt.vector_decode_and_decompress_loop pb_src n_bits_per_coefficient pv_dst
    n_rows 0#usize

end Symcrust
